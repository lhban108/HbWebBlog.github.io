<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>628</title>
  
  <subtitle>年轻无为, 卖马为生</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-06T06:35:11.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>海霸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>飞书一次面经</title>
    <link href="http://example.com/2021/07/06/text/%E9%A3%9E%E4%B9%A6%E9%9D%A2%E7%BB%8F/"/>
    <id>http://example.com/2021/07/06/text/%E9%A3%9E%E4%B9%A6%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-06T06:35:11.000Z</published>
    <updated>2021-07-06T06:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="飞书一面"><a href="#飞书一面" class="headerlink" title="飞书一面"></a>飞书一面</h2><h3 id="1、微前端拆分过程中遇到哪些问题"><a href="#1、微前端拆分过程中遇到哪些问题" class="headerlink" title="1、微前端拆分过程中遇到哪些问题"></a>1、微前端拆分过程中遇到哪些问题</h3><pre><code>问题：将一个应用拆分为多个子应用后， 项目的构建、打包、发布等如何做统一化管理        答案：我封装了一个 webpack 的npm包，在这个npm包中做统一处理，子应用只需要引入这个包即可</code></pre><h3 id="2、微前端shared文件夹-如何处理-不同子应用之间的冲突关系"><a href="#2、微前端shared文件夹-如何处理-不同子应用之间的冲突关系" class="headerlink" title="2、微前端shared文件夹 如何处理 不同子应用之间的冲突关系"></a>2、微前端shared文件夹 如何处理 不同子应用之间的冲突关系</h3><pre><code>答：shared文件夹使用的是subgit，多个子应用之间只维护shared文件夹中对应的模块，如果修改了公共的模块，要做降级处理</code></pre><h3 id="3、沙箱模式有哪几种实现方式"><a href="#3、沙箱模式有哪几种实现方式" class="headerlink" title="3、沙箱模式有哪几种实现方式"></a>3、沙箱模式有哪几种实现方式</h3><pre><code>答：（1）H5的一个对iframe新特性&lt;iframe sandbox src= ’.....’&gt; ，不过有些缺点需要手动抹平（2）用同一构造器（Constructor）生成彼此独立且互不干扰（self-contained）的实例对象，而从避免污染全局对象（3）NodeJS提供了原生的VM模块，也可以快速创建沙箱，同时指定上下文</code></pre><h3 id="4、性能监控过程，如何拿到首屏渲染时间，如何衡量每个页面的渲染时间是否符合预期-答：首屏渲染时间，可以通过-performance-API中-loadEventStart-fetchStart-的时间"><a href="#4、性能监控过程，如何拿到首屏渲染时间，如何衡量每个页面的渲染时间是否符合预期-答：首屏渲染时间，可以通过-performance-API中-loadEventStart-fetchStart-的时间" class="headerlink" title="4、性能监控过程，如何拿到首屏渲染时间，如何衡量每个页面的渲染时间是否符合预期    答：首屏渲染时间，可以通过 performance API中 loadEventStart - fetchStart 的时间"></a>4、性能监控过程，如何拿到首屏渲染时间，如何衡量每个页面的渲染时间是否符合预期    答：首屏渲染时间，可以通过 performance API中 loadEventStart - fetchStart 的时间</h3><pre><code>页面是否符合预期，需要根据不同页面的具体情况，在可视化图表中判断实际渲染时间与预期时间的对比</code></pre><h3 id="5、算法题一"><a href="#5、算法题一" class="headerlink" title="5、算法题一"></a>5、算法题一</h3><pre><code>买卖股票的最佳时机：给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 1 笔交易。例如 prices = [1,5,11,2,4,3,0,9]答案：这个题相对比较简单，大概5分钟左右写出来，面试官觉得没有问题</code></pre><h3 id="6、手写一个promiseAll"><a href="#6、手写一个promiseAll" class="headerlink" title="6、手写一个promiseAll"></a>6、手写一个promiseAll</h3><pre><code>答案：比较常见的题，大概几分钟就写出来了</code></pre><h3 id="7、cookie了解多少"><a href="#7、cookie了解多少" class="headerlink" title="7、cookie了解多少"></a>7、cookie了解多少</h3><p>cookie有哪些特性<br>是否可以跨域进行设置cookie<br>cookie是通过什么与域名进行绑定的，哪个字段<br>后端是怎样把cookie给到前端的<br>    答：回答的话述比较多，面试官也没有过于为难</p><h3 id="8、事件流是什么"><a href="#8、事件流是什么" class="headerlink" title="8、事件流是什么"></a>8、事件流是什么</h3><p>如果一个事件没有冒泡，可能有哪几个原因造成的？<br>如果一个元素的事件是可以冒泡的，但是没有冒泡到最外层元素，请问有什么办法去找到是哪个父元素阻止了冒泡？<br>答：事件流：捕捉（从Document-&gt;HTML标签-&gt;Body-&gt;目标） =&gt; 到达目标元素 =&gt; 冒泡<br>没有冒泡的原因：可能是addEventListener时设置了第二个属性为true，也可能是目标元素阻止了冒泡，也可能是某个父元素阻止了冒泡。如何判断是哪个父元素阻止了冒泡：可以在几个有可能阻止冒泡的父元素中去捕获，依次排查。也可以 重写 addEventListener 方法，加入获取阻止冒泡的代码逻辑（这个方法没有实践过，不太确定）</p><h3 id="9、跨域是什么，怎么处理跨域"><a href="#9、跨域是什么，怎么处理跨域" class="headerlink" title="9、跨域是什么，怎么处理跨域"></a>9、跨域是什么，怎么处理跨域</h3><p>CORS跨域 前端的请求头上需要怎么去设置，具体说明一下<br>    答：JSONP、Hash、H5 PostMessage、CORS、Nginx代理、Node层处理<br>    Access-Control-Allow-Origin: *<br>    Access-Control-Allow-Credentials: true<br>    Content-Type: text/html; charset=utf-8</p><h3 id="10、CSRF是什么，token为什么可以防止CSRF"><a href="#10、CSRF是什么，token为什么可以防止CSRF" class="headerlink" title="10、CSRF是什么，token为什么可以防止CSRF"></a>10、CSRF是什么，token为什么可以防止CSRF</h3><pre><code>答：回答了CSRF攻击的原理，防止方法：SameSite、Refer Check、Anti CSRF Token    Token可以防止CSRF的原因是 Token没有放在cookie中，不会自动携带。</code></pre><h3 id="11、打印结果：包含-Promise、SetTimeout、Promise中又产生一个Promise、RequestAnimationFrame"><a href="#11、打印结果：包含-Promise、SetTimeout、Promise中又产生一个Promise、RequestAnimationFrame" class="headerlink" title="11、打印结果：包含 Promise、SetTimeout、Promise中又产生一个Promise、RequestAnimationFrame"></a>11、打印结果：包含 Promise、SetTimeout、Promise中又产生一个Promise、RequestAnimationFrame</h3><pre><code><pre><code class="hljs javaScript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>); <span class="hljs-keyword">await</span> async2() <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);&#125;async1()<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5 - setTimeOut&#x27;</span>)&#125;, <span class="hljs-number">0</span>)requestAnimationFrame(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>));requestIdleCallback(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>));<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>) resolve()&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>)&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>) <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;13&#x27;</span>) &#125;, <span class="hljs-number">0</span>) <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;14&#x27;</span>))&#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>)</code></pre></code></pre><h2 id="飞书二面"><a href="#飞书二面" class="headerlink" title="飞书二面"></a>飞书二面</h2><h3 id="1、项目遇到哪些问题-分别是怎么解决的"><a href="#1、项目遇到哪些问题-分别是怎么解决的" class="headerlink" title="1、项目遇到哪些问题 分别是怎么解决的"></a>1、项目遇到哪些问题 分别是怎么解决的</h3><pre><code>答：问题一：业务中比较复杂的一个项目，需要用到贪心算法和动态规划，对数据做了几层处理问题二：项目中发现 Number.prototype.toFixed 精度缺少，通过 MDN、262.ecma-international.org 等找到了详细的原因，并给出了较好的解决方案</code></pre><h3 id="2、微前端怎么实现的，迁移遇到什么问题-怎么解决的"><a href="#2、微前端怎么实现的，迁移遇到什么问题-怎么解决的" class="headerlink" title="2、微前端怎么实现的，迁移遇到什么问题 怎么解决的"></a>2、微前端怎么实现的，迁移遇到什么问题 怎么解决的</h3><pre><code>答：跟一面的答案比较类似</code></pre><h3 id="3、说一下React-fiber"><a href="#3、说一下React-fiber" class="headerlink" title="3、说一下React fiber"></a>3、说一下React fiber</h3><pre><code>答：（1）通过fiberNode 将任务切片，在fiberNode 中包含 虚拟DOM、上下文信息、链表信息、更新相关、调度相关的信息等（2） 通过相关的调度过程，对fiber Node 实现优先级、回溯等调度</code></pre><h3 id="4、react-diff-和-vue-diff"><a href="#4、react-diff-和-vue-diff" class="headerlink" title="4、react diff 和 vue diff"></a>4、react diff 和 vue diff</h3><pre><code>答：描述了 React diff 的结论，Vue 2 和 Vue 3 的区别</code></pre><h3 id="5、笔试题一：实现两个树的diff算法。分别打印出新增、删除、修改的节点"><a href="#5、笔试题一：实现两个树的diff算法。分别打印出新增、删除、修改的节点" class="headerlink" title="5、笔试题一：实现两个树的diff算法。分别打印出新增、删除、修改的节点"></a>5、笔试题一：实现两个树的diff算法。分别打印出新增、删除、修改的节点</h3><pre><code>答：写的也没有什么问题，面试官比较满意</code></pre><h3 id="6、你的技术栈有哪些"><a href="#6、你的技术栈有哪些" class="headerlink" title="6、你的技术栈有哪些"></a>6、你的技术栈有哪些</h3><h3 id="7、说一下你所了解的性能优化"><a href="#7、说一下你所了解的性能优化" class="headerlink" title="7、说一下你所了解的性能优化"></a>7、说一下你所了解的性能优化</h3><pre><code>从调试工具（DOMContentLoaded、waterfall、webpack-bundle-analyze、performance API）入手，讲了一下 优化请求数量、减少请求文件体积、提高DOM解析速度、减少重排重绘次数、骨架屏、缓存策略、预加载/懒加载、SSR等</code></pre><h3 id="8、笔试题二：实现一个promise并发调度，-每次最多请求两个"><a href="#8、笔试题二：实现一个promise并发调度，-每次最多请求两个" class="headerlink" title="8、笔试题二：实现一个promise并发调度， 每次最多请求两个"></a>8、笔试题二：实现一个promise并发调度， 每次最多请求两个</h3><pre><code><pre><code class="hljs javaScript"><span class="hljs-comment">// 实现一个并发请求的函数</span><span class="hljs-keyword">var</span> jsonArr = [<span class="hljs-string">&#x27;api1.json&#x27;</span>, <span class="hljs-string">&#x27;api2.json&#x27;</span>, <span class="hljs-string">&#x27;api3.json&#x27;</span>, <span class="hljs-string">&#x27;api4.json&#x27;</span>, <span class="hljs-string">&#x27;api5.json&#x27;</span>, <span class="hljs-string">&#x27;api6.json&#x27;</span>]<span class="hljs-comment">// 答：</span><span class="hljs-comment">// 其中 jsonArr 为包含需要请求接口名的数组，limit 为最大并发请求数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAll</span>(<span class="hljs-params">jsonArr, limit=<span class="hljs-number">2</span></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<span class="hljs-comment">// 结果</span><span class="hljs-keyword">let</span> resList = [];<span class="hljs-comment">// 当前正在执行的并发任务队列</span><span class="hljs-keyword">const</span> currPList = [];<span class="hljs-keyword">let</span> i = jsonArr.length - <span class="hljs-number">1</span>;<span class="hljs-comment">// 调度任务队列</span><span class="hljs-keyword">const</span> fetcher = <span class="hljs-keyword">async</span> () =&gt; &#123;<span class="hljs-keyword">while</span>(jsonArr.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">let</span> j = i = i - <span class="hljs-number">1</span>;resList[j] = <span class="hljs-keyword">await</span> fetch(jsonArr.shift());&#125;&#125;<span class="hljs-comment">// 线程池</span><span class="hljs-keyword">while</span>(limit) &#123;--limit;<span class="hljs-comment">// 控制当前并发调度队列只有2个</span>currPList.push(fetcher());&#125;<span class="hljs-comment">// 让2个并发队列同时执行</span><span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(currPList);resolve(resList);&#125;);&#125;</code></pre></code></pre><h3 id="9、给你一个网站，你有哪些办法判断该网站是否有内存泄漏"><a href="#9、给你一个网站，你有哪些办法判断该网站是否有内存泄漏" class="headerlink" title="9、给你一个网站，你有哪些办法判断该网站是否有内存泄漏"></a>9、给你一个网站，你有哪些办法判断该网站是否有内存泄漏</h3><pre><code>答：（1）使用 Chrome 任务管理器实时监视内存使用（2）利用chrome 的Performance 中时间轴记录可视化内存泄漏（3）利用Chrome的Memory （Heap Snapshot）录制一段过程，根据结果进行分析</code></pre><h3 id="10、笔试题三：给了一段代码，判断哪里可能会造成内存泄漏，在不修改源代码的基础上，如何优化，避免内存泄漏"><a href="#10、笔试题三：给了一段代码，判断哪里可能会造成内存泄漏，在不修改源代码的基础上，如何优化，避免内存泄漏" class="headerlink" title="10、笔试题三：给了一段代码，判断哪里可能会造成内存泄漏，在不修改源代码的基础上，如何优化，避免内存泄漏"></a>10、笔试题三：给了一段代码，判断哪里可能会造成内存泄漏，在不修改源代码的基础上，如何优化，避免内存泄漏</h3><pre><code><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> timee = <span class="hljs-literal">null</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> originTimee = timee;<span class="hljs-keyword">var</span> unused = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span>(originTimee) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;111&#x27;</span>);&#125;timee = &#123;<span class="hljs-attr">arr</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10000000</span>).fill(<span class="hljs-number">1</span>),<span class="hljs-attr">str</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10000000</span>).fill(<span class="hljs-number">1</span>).splice(<span class="hljs-string">&#x27;&#x27;</span>),&#125;&#125;<span class="hljs-built_in">setInterval</span>(fn1, <span class="hljs-number">10</span>);</code></pre></code></pre><p>答：在fn1方法中 originTimee 变量会造成内存泄漏，解决方法：在fn1的最后一行，originTimee = null 即可</p><h3 id="11、笔试题四：js手写动画的优化方式"><a href="#11、笔试题四：js手写动画的优化方式" class="headerlink" title="11、笔试题四：js手写动画的优化方式"></a>11、笔试题四：js手写动画的优化方式</h3><pre><code>答：把获取DOM的一些代码进行提取封装，不需要每次重复获取、赋值 等</code></pre><h3 id="12、如何看待自驱力，你认为你的自驱力怎么样，如何保持自驱力"><a href="#12、如何看待自驱力，你认为你的自驱力怎么样，如何保持自驱力" class="headerlink" title="12、如何看待自驱力，你认为你的自驱力怎么样，如何保持自驱力"></a>12、如何看待自驱力，你认为你的自驱力怎么样，如何保持自驱力</h3><h3 id="13、有哪些管理方法、管理工具"><a href="#13、有哪些管理方法、管理工具" class="headerlink" title="13、有哪些管理方法、管理工具"></a>13、有哪些管理方法、管理工具</h3><h3 id="14、个人成长计划"><a href="#14、个人成长计划" class="headerlink" title="14、个人成长计划"></a>14、个人成长计划</h3><h2 id="飞书三面"><a href="#飞书三面" class="headerlink" title="飞书三面"></a>飞书三面</h2><h3 id="1、详细描述一下-React-DIff的过程"><a href="#1、详细描述一下-React-DIff的过程" class="headerlink" title="1、详细描述一下 React DIff的过程"></a>1、详细描述一下 React DIff的过程</h3><pre><code>答：我回答了diff 的结果，但是面试官 说要React源码中diff的具体实现流程，不要回答别人总结的结果，    又说 比如 A/B/C/D变成 D/C/B/A，React Diff是怎么做到的。我没有看过源码，回答的让面试官不满意</code></pre><h3 id="2、HTTPS中SSL握手的过程，对称加密和非对称加密的过程，如果CA证书被中间代理商劫持了怎么处理"><a href="#2、HTTPS中SSL握手的过程，对称加密和非对称加密的过程，如果CA证书被中间代理商劫持了怎么处理" class="headerlink" title="2、HTTPS中SSL握手的过程，对称加密和非对称加密的过程，如果CA证书被中间代理商劫持了怎么处理"></a>2、HTTPS中SSL握手的过程，对称加密和非对称加密的过程，如果CA证书被中间代理商劫持了怎么处理</h3><pre><code>答：SSL和非对称加密、对称加密 回答的比较流畅、没有问题。但是CA证书被中间商劫持的问题没有回答上来</code></pre><h3 id="3、个人发展计划，职业规划"><a href="#3、个人发展计划，职业规划" class="headerlink" title="3、个人发展计划，职业规划"></a>3、个人发展计划，职业规划</h3><h3 id="4、算法题：让字符串成为回文串的最少插入次数。给任意一个字符串，每次操作只能在任意位置进行插入字符，让字符串成为回文字符串"><a href="#4、算法题：让字符串成为回文串的最少插入次数。给任意一个字符串，每次操作只能在任意位置进行插入字符，让字符串成为回文字符串" class="headerlink" title="4、算法题：让字符串成为回文串的最少插入次数。给任意一个字符串，每次操作只能在任意位置进行插入字符，让字符串成为回文字符串"></a>4、算法题：让字符串成为回文串的最少插入次数。给任意一个字符串，每次操作只能在任意位置进行插入字符，让字符串成为回文字符串</h3><pre><code>答：我的解法是，首先找到最大回文子串，以此为基础找到目标的回文串，再获取从原串变成目标串的最少操作次数。但是面试官说我的方法只能解决部分问题（有些字符串是没有最大回文子串的），不能解决全部问题</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;飞书一面&quot;&gt;&lt;a href=&quot;#飞书一面&quot; class=&quot;headerlink&quot; title=&quot;飞书一面&quot;&gt;&lt;/a&gt;飞书一面&lt;/h2&gt;&lt;h3 id=&quot;1、微前端拆分过程中遇到哪些问题&quot;&gt;&lt;a href=&quot;#1、微前端拆分过程中遇到哪些问题&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js-手写代码</title>
    <link href="http://example.com/2021/07/01/interview/js-Code/"/>
    <id>http://example.com/2021/07/01/interview/js-Code/</id>
    <published>2021-07-01T07:49:11.000Z</published>
    <updated>2021-07-01T07:49:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-JS"><a href="#一-JS" class="headerlink" title="一 JS"></a>一 JS</h2><p>1 手写 new Object.create<br>2 获取JS类型<br>3 instanceOf<br>4 深拷贝<br>5 call/apply/bind<br>6 防抖节流<br>7 JSONP<br>8 sum(2,3) === sum(2)(3)<br>9 图片懒加载<br>10 每隔一秒打印 1,2,3,4</p><h3 id="1-new-Object-create"><a href="#1-new-Object-create" class="headerlink" title="1 new/Object.create"></a>1 new/Object.create</h3><p>new 实现的原理:<br>(1) 创建一个新对象<br>(2) 将构造函数的作用域赋给新对象（将新对象的 <strong>proto</strong> 指向构造函数的prototype对象）<br>(3) 为这个新对象添加属性（将构造函数的this通过call/apply指向这个新对象，并执行了构造函数中的方法）<br>(4) 如果构造函数没有返回其他方法，那么 this 指向这个对象，否则 this 指向构造函数中返回的对象</p><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-built_in">this</span>.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123; <span class="hljs-built_in">this</span>.name = name &#125;;<span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name &#125;;&#125;<span class="hljs-comment">// 第一步:创建一个新对象</span><span class="hljs-keyword">let</span> p1 = &#123;&#125;;<span class="hljs-comment">// 第二步:将构造函数的作用域赋给新对象（</span><span class="hljs-comment">// 将新对象的 __proto__ 指向构造函数的prototype对象）</span>p1.__proto__ = Person.prototype;<span class="hljs-comment">// 第三步:为这个新对象添加属性</span><span class="hljs-comment">//（将构造函数的this通过call/apply指向这个新对象，并执行了构造函数中的方法）</span>Person.call(p1);<span class="hljs-comment">// 手写一个 new 函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// 1、创建一个新的空对象</span><span class="hljs-keyword">let</span> target = &#123;&#125;;<span class="hljs-comment">// 获取构造函数</span><span class="hljs-keyword">let</span> [<span class="hljs-title">constructor</span>, ...<span class="hljs-title">args</span>] = [...<span class="hljs-title">arguments</span>]// 2、将构造函数的作用域赋值给这个新对象<span class="hljs-title">target</span>.<span class="hljs-title">__proto__</span> = <span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>;<span class="hljs-comment">// 3、执行构造函数，将属性或方法添加到这个空对象上</span><span class="hljs-keyword">let</span> result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">target, args</span>);<span class="hljs-comment">// 4、如果构造函数执行的结构返回的是一个对象，那么返回这个对象；</span><span class="hljs-comment">//如果构造函数返回的不是一个对象，返回创建的新对象</span><span class="hljs-keyword">if</span> (result &amp;&amp; (<span class="hljs-keyword">typeof</span> (result) == <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> (result) == <span class="hljs-string">&quot;function&quot;</span>)) &#123;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">return</span> target;&#125;<span class="hljs-comment">// 测试用例 ---- start</span><span class="hljs-keyword">const</span> person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;&#125;person.prototype.getName = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;&#125;person.prototype.setName = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> &#123;<span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> person(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);p1.setName(<span class="hljs-string">&#x27;lisi&#x27;</span>);</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// Object.create方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">proto</span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;F.prototype = proto;F.prototype.constructor = F;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();&#125;<span class="hljs-comment">//官方版Polyfill</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.create !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">proto, propertiesObject</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Object prototype may only be an Object: &#x27;</span> + proto);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;This browser&#x27;s implementation of Object.create is a shim and doesn&#x27;t support &#x27;null&#x27; as the first argument.&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> propertiesObject !== <span class="hljs-string">&#x27;undefined&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;This browser&#x27;s implementation of Object.create is a shim and doesn&#x27;t support a second argument.&quot;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;F.prototype = proto;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();&#125;;&#125;</code></pre><h3 id="2-获取JS类型"><a href="#2-获取JS类型" class="headerlink" title="2 获取JS类型"></a>2 获取JS类型</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 获取JavaScript类型的函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span>(<span class="hljs-params">obj</span>) </span>&#123;<span class="hljs-comment">// 因为 typeof null = &#x27;object&#x27;</span><span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> obj + <span class="hljs-string">&#x27;&#x27;</span>;&#125;<span class="hljs-comment">// 判断是引用类型还是基本类型</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<span class="hljs-comment">// const objClass = Object.prototype.toString.call(obj);</span><span class="hljs-comment">// let type = objClass.split(&#x27; &#x27;)[1].replace(&#x27;]&#x27;, &#x27;&#x27;);</span><span class="hljs-comment">// return type.toLowerCase();</span><span class="hljs-keyword">const</span> typeStr = <span class="hljs-built_in">Object</span>.prototype.toString.call(obj);<span class="hljs-comment">// [object Array]</span><span class="hljs-keyword">return</span> typeStr.substring(<span class="hljs-number">8</span>, typeStr.length - <span class="hljs-number">1</span>).toLowerCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj;&#125;&#125;</code></pre><h3 id="3-instanceOf"><a href="#3-instanceOf" class="headerlink" title="3 instanceOf"></a>3 instanceOf</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instanceOf</span>(<span class="hljs-params">left, right</span>) </span>&#123;<span class="hljs-keyword">let</span> proto = left.__proto__; <span class="hljs-keyword">let</span> prototype = right.prototype<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span>(proto == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-keyword">if</span>(proto == prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>proto = proto.__proto__;&#125;&#125;</code></pre><h3 id="4-深拷贝-浅拷贝"><a href="#4-深拷贝-浅拷贝" class="headerlink" title="4 深拷贝/浅拷贝"></a>4 深拷贝/浅拷贝</h3><p>深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。</p><ul><li><strong>深拷贝</strong>：深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</li><li><strong>浅拷贝</strong>：浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</li></ul><p>浅拷贝的实现方式：</p><ul><li>Object.assign()</li><li>函数库 lodash 的 lodash.clone 方法</li><li>展开运算符…</li><li>Array.prototype.concat()</li><li>Array.prototype.slice()</li></ul><pre><code class="hljs javaScript"><span class="hljs-comment">// 浅拷贝实现过程</span><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Yvette&#x27;</span>,<span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<span class="hljs-attr">hobbies</span>: [<span class="hljs-string">&#x27;reading&#x27;</span>, <span class="hljs-string">&#x27;photography&#x27;</span>]&#125;<span class="hljs-comment">// 浅拷贝实现方式一: Object.assign()</span><span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj);<span class="hljs-comment">// 浅拷贝实现方式二: 函数库lodash的_.clone方法</span><span class="hljs-keyword">let</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<span class="hljs-keyword">let</span> obj3 = lodash.clone(obj);<span class="hljs-comment">// 浅拷贝实现方式三: 展开运算符...</span><span class="hljs-keyword">let</span> obj4 = &#123;...obj&#125;;<span class="hljs-comment">// 浅拷贝实现方式四: Array.prototype.concat()</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;kobe&#x27;</span> &#125;];<span class="hljs-keyword">let</span> arr2 = arr.concat();  <span class="hljs-comment">// 浅拷贝实现方式五: Array.prototype.concat()</span><span class="hljs-keyword">let</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;kobe&#x27;</span> &#125;];<span class="hljs-keyword">let</span> arr4 = arr3.slice();</code></pre><p>可以看出，浅拷贝<strong>只对第一层属性</strong>进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么<em>新对象和原对象的属性值其指向的是同一块内存地址</em>。</p><p>深拷贝的实现方式：</p><ul><li><p>JSON.parse(JSON.stringify(obj))</p></li><li><p>函数库 lodash 的 lodash.cloneDeep 方法</p></li><li><p>jQuery.extend()方法</p></li><li><p>手写递归方法</p>  <pre><code class="hljs javascript"><span class="hljs-comment">// 方法一: JSON.parse(JSON.stringify(obj))</span><span class="hljs-comment">/*</span><span class="hljs-comment">缺陷：</span><span class="hljs-comment">1、对象属性是函数时，无法拷贝</span><span class="hljs-comment">2、原型链上的属性无法拷贝</span><span class="hljs-comment">3、不能正确处理 Date 了类型的数据</span><span class="hljs-comment">4、不能处理 RegExp</span><span class="hljs-comment">5、会忽略 Symbol 和 undefined</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 方法二: 函数库 lodash 的 lodash.cloneDeep 方法</span><span class="hljs-keyword">let</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;;<span class="hljs-keyword">let</span> obj2 = lodash.cloneDeep(obj);<span class="hljs-comment">// 方法三: .jQuery.extend()方法</span><span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>);<span class="hljs-keyword">var</span> obj3 = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;;<span class="hljs-keyword">var</span> obj4 = $.extend(<span class="hljs-literal">true</span>, &#123;&#125;, obj3); <span class="hljs-comment">//第一个参数为true,就是深拷贝</span><span class="hljs-comment">// 方法四: 实现一个 deepClone 函数</span><span class="hljs-comment">/*</span><span class="hljs-comment">步骤:</span><span class="hljs-comment">1、如果是基本数据类型，直接返回</span><span class="hljs-comment">2、如果是 RegExp 或者 Date 类型，返回对应类型</span><span class="hljs-comment">3、如果是复杂数据类型，递归</span><span class="hljs-comment">4、考虑循环引用的问题</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 深拷贝</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;<span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<span class="hljs-comment">//如果不是复杂数据类型 或者是 Null ，直接返回</span><span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj);<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj);<span class="hljs-comment">// 考虑循环引用的问题</span><span class="hljs-keyword">if</span> (hash.has(obj)) &#123;<span class="hljs-keyword">return</span> hash.get(obj);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span><span class="hljs-comment"> * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span><span class="hljs-comment"> */</span><span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.constructor();hash.set(obj, cloneObj);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-comment">//递归</span><span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123; <span class="hljs-comment">// 是否是自身的属性</span>cloneObj[key] = deepClone(obj[key], hash);&#125;&#125;<span class="hljs-keyword">return</span> cloneObj;&#125;</code></pre>  <pre><code class="hljs javaScript"><span class="hljs-comment">// 满分答案</span><span class="hljs-comment">// https://github.com/ConardLi/ConardLi.github.io/blob/master/demo/deepClone/src/clone_6.js</span><span class="hljs-keyword">const</span> mapTag = <span class="hljs-string">&#x27;[object Map]&#x27;</span>;<span class="hljs-keyword">const</span> setTag = <span class="hljs-string">&#x27;[object Set]&#x27;</span>;<span class="hljs-keyword">const</span> arrayTag = <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<span class="hljs-keyword">const</span> objectTag = <span class="hljs-string">&#x27;[object Object]&#x27;</span>;<span class="hljs-keyword">const</span> argsTag = <span class="hljs-string">&#x27;[object Arguments]&#x27;</span>;<span class="hljs-keyword">const</span> boolTag = <span class="hljs-string">&#x27;[object Boolean]&#x27;</span>;<span class="hljs-keyword">const</span> dateTag = <span class="hljs-string">&#x27;[object Date]&#x27;</span>;<span class="hljs-keyword">const</span> numberTag = <span class="hljs-string">&#x27;[object Number]&#x27;</span>;<span class="hljs-keyword">const</span> stringTag = <span class="hljs-string">&#x27;[object String]&#x27;</span>;<span class="hljs-keyword">const</span> symbolTag = <span class="hljs-string">&#x27;[object Symbol]&#x27;</span>;<span class="hljs-keyword">const</span> errorTag = <span class="hljs-string">&#x27;[object Error]&#x27;</span>;<span class="hljs-keyword">const</span> regexpTag = <span class="hljs-string">&#x27;[object RegExp]&#x27;</span>;<span class="hljs-keyword">const</span> funcTag = <span class="hljs-string">&#x27;[object Function]&#x27;</span>;<span class="hljs-keyword">const</span> deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span>(<span class="hljs-params">array, iteratee</span>) </span>&#123;<span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> length = array.length;<span class="hljs-keyword">while</span> (++index &lt; length) &#123;iteratee(array[index], index);&#125;<span class="hljs-keyword">return</span> array;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> target;<span class="hljs-keyword">return</span> target !== <span class="hljs-literal">null</span> &amp;&amp; (type === <span class="hljs-string">&#x27;object&#x27;</span> || type === <span class="hljs-string">&#x27;function&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(target);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInit</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">const</span> Ctor = target.constructor;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Ctor();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneSymbol</span>(<span class="hljs-params">targe</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">Symbol</span>.prototype.valueOf.call(targe));&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneReg</span>(<span class="hljs-params">targe</span>) </span>&#123;<span class="hljs-keyword">const</span> reFlags = <span class="hljs-regexp">/\w*$/</span>;<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> targe.constructor(targe.source, reFlags.exec(targe));result.lastIndex = targe.lastIndex;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneFunction</span>(<span class="hljs-params">func</span>) </span>&#123;<span class="hljs-keyword">const</span> bodyReg = <span class="hljs-regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;<span class="hljs-keyword">const</span> paramReg = <span class="hljs-regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;<span class="hljs-keyword">const</span> funcString = func.toString();<span class="hljs-keyword">if</span> (func.prototype) &#123;<span class="hljs-keyword">const</span> param = paramReg.exec(funcString);<span class="hljs-keyword">const</span> body = bodyReg.exec(funcString);<span class="hljs-keyword">if</span> (body) &#123;<span class="hljs-keyword">if</span> (param) &#123;<span class="hljs-keyword">const</span> paramArr = param[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(...paramArr, body[<span class="hljs-number">0</span>]);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(body[<span class="hljs-number">0</span>]);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(funcString);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneOtherType</span>(<span class="hljs-params">targe, type</span>) </span>&#123;<span class="hljs-keyword">const</span> Ctor = targe.constructor;<span class="hljs-keyword">switch</span> (type) &#123;<span class="hljs-keyword">case</span> boolTag:<span class="hljs-keyword">case</span> numberTag:<span class="hljs-keyword">case</span> stringTag:<span class="hljs-keyword">case</span> errorTag:<span class="hljs-keyword">case</span> dateTag:<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Ctor(targe);<span class="hljs-keyword">case</span> regexpTag:<span class="hljs-keyword">return</span> cloneReg(targe);<span class="hljs-keyword">case</span> symbolTag:<span class="hljs-keyword">return</span> cloneSymbol(targe);<span class="hljs-keyword">case</span> funcTag:<span class="hljs-keyword">return</span> cloneFunction(targe);<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">target, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;<span class="hljs-comment">// 克隆原始类型</span><span class="hljs-keyword">if</span> (!isObject(target)) &#123;<span class="hljs-keyword">return</span> target;&#125;<span class="hljs-comment">// 初始化</span><span class="hljs-keyword">const</span> type = getType(target);<span class="hljs-keyword">let</span> cloneTarget;<span class="hljs-keyword">if</span> (deepTag.includes(type)) &#123;cloneTarget = getInit(target, type);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> cloneOtherType(target, type);&#125;<span class="hljs-comment">// 防止循环引用</span><span class="hljs-keyword">if</span> (map.get(target)) &#123;<span class="hljs-keyword">return</span> map.get(target);&#125;map.set(target, cloneTarget);<span class="hljs-comment">// 克隆set</span><span class="hljs-keyword">if</span> (type === setTag) &#123;target.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;cloneTarget.add(clone(value, map));&#125;);<span class="hljs-keyword">return</span> cloneTarget;&#125;<span class="hljs-comment">// 克隆map</span><span class="hljs-keyword">if</span> (type === mapTag) &#123;target.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;cloneTarget.set(key, clone(value, map));&#125;);<span class="hljs-keyword">return</span> cloneTarget;&#125;<span class="hljs-comment">// 克隆对象和数组</span><span class="hljs-keyword">const</span> keys = type === arrayTag ? <span class="hljs-literal">undefined</span> : <span class="hljs-built_in">Object</span>.keys(target);forEach(keys || target, <span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (keys) &#123;key = value;&#125;cloneTarget[key] = clone(target[key], map);&#125;);<span class="hljs-keyword">return</span> cloneTarget;&#125;<span class="hljs-built_in">module</span>.exports = &#123;clone&#125;;</code></pre></li></ul><h3 id="5-call-apply-bind"><a href="#5-call-apply-bind" class="headerlink" title="5 call/apply/bind"></a>5 call/apply/bind</h3><p>call 和 apply 的功能相同，都是改变 this 指向，并立即执行函数。区别在于传参方式不同：</p><ul><li>func.call(this, arg1, arg2, …)</li><li>func.apply(this, [arg1, arg2, …])</li></ul><p>实现步骤：</p><ol><li>如果第一个参数没有传入，那么默认指向 window / global(非严格模式)</li><li>传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj; 因此我们可以这样调用函数 thisArgs.func(…args)</li><li>返回执行结果</li></ol><pre><code class="hljs javaScript"><span class="hljs-comment">// call</span><span class="hljs-built_in">Function</span>.prototype.call2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">let</span> [thisArg, ...args] = [...arguments];<span class="hljs-keyword">if</span> (!thisArg) &#123;<span class="hljs-comment">// context 为null 或者是 undefined</span>thisArg = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-built_in">global</span> : <span class="hljs-built_in">window</span>;&#125;<span class="hljs-comment">// this 就是当前函数 func(func.call)</span>thisArg.func = <span class="hljs-built_in">this</span>;<span class="hljs-comment">// 执行函数</span><span class="hljs-keyword">let</span> result = thisArg.func(...args);<span class="hljs-comment">// 由于thisArg 上原本没有 func，因此执行完后需要删除</span><span class="hljs-keyword">delete</span> thisArg.func;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">// 测试用例 --------start</span><span class="hljs-comment">// test1</span><span class="hljs-keyword">const</span> c = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;c罗&#x27;</span>,<span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;34&#x27;</span>,<span class="hljs-attr">func</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27;-&#x27;</span> + arg1 + <span class="hljs-string">&#x27;-&#x27;</span> + arg2);&#125;&#125;<span class="hljs-keyword">const</span> n = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;梅西&#x27;</span>,<span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;32&#x27;</span>,&#125;c.func.call2(n, <span class="hljs-string">&#x27;t1&#x27;</span>, <span class="hljs-string">&#x27;t2&#x27;</span>); <span class="hljs-comment">// 梅西:32-t1-t2</span>c.func(<span class="hljs-string">&#x27;t3&#x27;</span>, <span class="hljs-string">&#x27;t4&#x27;</span>); <span class="hljs-comment">// c罗:34-t3-t4</span><span class="hljs-comment">// 测试用例 --------end</span><span class="hljs-comment">// apply 与 call 区别就是传参的不同</span><span class="hljs-comment">// apply</span><span class="hljs-built_in">Function</span>.prototype.apply2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, rest</span>) </span>&#123;<span class="hljs-keyword">if</span> (!thisArg) &#123;<span class="hljs-comment">// context 为null 或者是 undefined</span>thisArg = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-built_in">global</span> : <span class="hljs-built_in">window</span>;&#125;<span class="hljs-keyword">let</span> result; <span class="hljs-comment">// 函数执行结果</span>thisArg.func = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">if</span> (!rest) &#123;result = thisArg.func();&#125; <span class="hljs-keyword">else</span> &#123;result = thisArg.func(...rest);&#125;<span class="hljs-keyword">delete</span> thisArg.func;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">// 测试用例 --------start</span><span class="hljs-comment">// test1</span><span class="hljs-keyword">const</span> c = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;c罗&#x27;</span>,<span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;34&#x27;</span>,<span class="hljs-attr">func</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27;-&#x27;</span> + arg1 + <span class="hljs-string">&#x27;-&#x27;</span> + arg2);&#125;&#125;<span class="hljs-keyword">const</span> n = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;梅西&#x27;</span>,<span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;32&#x27;</span>,&#125;c.func.apply(n, [<span class="hljs-string">&#x27;t1&#x27;</span>, <span class="hljs-string">&#x27;t2&#x27;</span>]); <span class="hljs-comment">// 梅西:32-t1-t2</span>c.func(<span class="hljs-string">&#x27;t3&#x27;</span>, <span class="hljs-string">&#x27;t4&#x27;</span>); <span class="hljs-comment">// c罗:34-t3-t4</span><span class="hljs-comment">// 测试用例 --------end</span></code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// bind:</span><span class="hljs-built_in">Function</span>.prototype.bind2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>) </span>&#123;<span class="hljs-comment">// 若没问参数类型则从这开始写</span><span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">const</span> args = [...arguments].slice(<span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> resFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> resFn ?<span class="hljs-built_in">this</span> : content, args.concat(...arguments) );&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tmp</span>(<span class="hljs-params"></span>) </span>&#123;&#125;tmp.prototype = <span class="hljs-built_in">this</span>.prototype;resFn.prototype = <span class="hljs-keyword">new</span> tmp();<span class="hljs-keyword">return</span> resFn;&#125;<span class="hljs-comment">// 测试用例 --------start</span><span class="hljs-comment">// test 1</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;  <span class="hljs-keyword">return</span> a + b + c;&#125;<span class="hljs-keyword">var</span> _fn = fn.bind2(<span class="hljs-literal">null</span>, <span class="hljs-number">10</span>);<span class="hljs-built_in">console</span>.log(_fn(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// 60</span><span class="hljs-comment">// test2</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;  <span class="hljs-built_in">this</span>.name = name;  <span class="hljs-built_in">this</span>.age = age;&#125;<span class="hljs-keyword">const</span> _Person = Person.bind(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;beike&#x27;</span>);<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> _Person(<span class="hljs-number">30</span>);<span class="hljs-built_in">console</span>.log(p1); <span class="hljs-comment">// Person &#123;name: &quot;hanzichi&quot;, age: 30&#125;</span><span class="hljs-comment">// test4</span><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;梅西&#x27;</span>;<span class="hljs-keyword">var</span> age = <span class="hljs-number">33</span>;<span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;坎特&#x27;</span>,<span class="hljs-attr">age</span>: <span class="hljs-built_in">this</span>.age,<span class="hljs-attr">myFun</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>,to</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;name:&#x27;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;, Age:&#x27;</span> + <span class="hljs-built_in">this</span>.age)&#125;&#125;<span class="hljs-keyword">var</span> db = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;德布劳内&#x27;</span>,<span class="hljs-attr">age</span>: <span class="hljs-number">29</span>&#125;<span class="hljs-keyword">var</span> rm = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;里克尔梅&#x27;</span>,<span class="hljs-attr">age</span>: <span class="hljs-number">42</span>&#125;obj.myFun(); <span class="hljs-comment">// name:坎特, Age:33</span>obj.myFun.apply2(rm); <span class="hljs-comment">// name:里克尔梅, Age:42</span>obj.myFun.call2(db); <span class="hljs-comment">// name:德布劳内, Age:29</span>obj.myFun.bind2(db)(); <span class="hljs-comment">// name:德布劳内, Age:29</span><span class="hljs-comment">// 测试用例 --------end</span></code></pre><h3 id="6-防抖-节流"><a href="#6-防抖-节流" class="headerlink" title="6 防抖/节流"></a>6 防抖/节流</h3><p>考点：闭包、防抖、节流</p><p>统计按钮一秒点击次数</p><pre><code class="hljs javaScript">button.onclick = debounce(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;点击一次&#x27;</span>);&#125;,<span class="hljs-number">1000</span>);<span class="hljs-comment">// 统计一秒点击次数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, time</span>) </span>&#123;<span class="hljs-keyword">let</span> number = <span class="hljs-number">0</span> , timer  = <span class="hljs-literal">null</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>) </span>&#123; fn.apply(<span class="hljs-built_in">this</span>, arg)number++<span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;点击&#x27;</span>+ number + <span class="hljs-string">&#x27;次&#x27;</span> )number = <span class="hljs-number">0</span>timer = <span class="hljs-literal">null</span>&#125;, time)&#125;&#125;<span class="hljs-comment">//- 防抖意clk延迟时间。</span><span class="hljs-comment">// 防抖</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, time = <span class="hljs-number">500</span></span>) </span>&#123;<span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 创建一个标记用来存放定时器的返回值</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">clearTimeout</span>(timeout);<span class="hljs-comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 然后又创建一个新的 setTimeout</span><span class="hljs-comment">// 这样就能保证输入字符后的interval </span><span class="hljs-comment">// 间隔内如果还有字符输入的话，就不会执行 fn 函数 </span>fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)&#125;, time) &#125; &#125;<span class="hljs-comment">// - 节流: 高频事件触发，但在 n 秒内只会执行一次(第一次)，所以节流会稀释函数的执行频率。</span><span class="hljs-comment">// 节流</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, time = <span class="hljs-number">500</span></span>) </span>&#123; <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span> <span class="hljs-comment">//</span><span class="hljs-comment">// 通过闭包保存一个标记</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span><span class="hljs-comment">// 在函数开头判断标记是否为 true，不为 true 则 return</span>canRun = <span class="hljs-literal">false</span> <span class="hljs-comment">// 立即设置为 false</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<span class="hljs-comment">// 最后在 setTimeout 执行完毕后再把标记设置为 true(关键)</span><span class="hljs-comment">// 表示可以执行下一次循环了。</span><span class="hljs-comment">// 当定时器没有执行的时候标记永远是 false，在开头被return</span>canRun = <span class="hljs-literal">true</span>&#125;, time)&#125;&#125;</code></pre><p>防抖的应用场景:</p><ul><li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li><li>表单验证</li><li>按钮提交事件。</li><li>浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。</li></ul><p>节流的应用场景</p><ul><li>按钮点击事件</li><li>拖拽事件</li><li>onScoll</li><li>计算鼠标移动的距离(mousemove)</li></ul><h3 id="7-JSONP"><a href="#7-JSONP" class="headerlink" title="7 JSONP"></a>7 JSONP</h3><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> jsonp = <span class="hljs-function">(<span class="hljs-params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> generateUrl = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">let</span> dataSrc = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<span class="hljs-keyword">if</span> (params.hasOwnProperty(key)) &#123;dataSrc += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span>&#125;&#125;dataSrc += <span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callbackName&#125;</span>`</span><span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataSrc&#125;</span>`</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> scriptEle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)scriptEle.src = generateUrl();<span class="hljs-built_in">document</span>.body.appendChild(scriptEle)<span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;resolve(data)<span class="hljs-built_in">document</span>.removeChild(scriptEle)&#125;&#125;)&#125;</code></pre><h3 id="8-sum-2-3-sum-2-3"><a href="#8-sum-2-3-sum-2-3" class="headerlink" title="8 sum(2,3) === sum(2)(3)"></a>8 sum(2,3) === sum(2)(3)</h3><pre><code class="hljs javaScript"><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));   <span class="hljs-comment">// Outputs 5</span><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>));  <span class="hljs-comment">// Outputs 5</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> fir = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;re&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sec</span>) </span>&#123;<span class="hljs-keyword">return</span> fir + sec;&#125;&#125;&#125;</code></pre><h3 id="9-图片懒加载"><a href="#9-图片懒加载" class="headerlink" title="9 图片懒加载"></a>9 图片懒加载</h3><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> imgList = [...document.querySelectorAll(<span class="hljs-string">&#x27;img&#x27;</span>)]<span class="hljs-keyword">let</span> length = imgList.length<span class="hljs-comment">// 修正错误，需要加上自执行</span><span class="hljs-keyword">const</span> imgLazyLoad = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">let</span> deleteIndexList = [];imgList.forEach(<span class="hljs-function">(<span class="hljs-params">img, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> rect = img.getBoundingClientRect()<span class="hljs-keyword">if</span> (rect.top &lt; <span class="hljs-built_in">window</span>.innerHeight) &#123;img.src = img.dataset.src;deleteIndexList.push(index);count++;<span class="hljs-keyword">if</span> (count === length) &#123;<span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, imgLazyLoad);&#125;&#125;&#125;)imgList = imgList.filter(<span class="hljs-function">(<span class="hljs-params">img, index</span>) =&gt;</span> !deleteIndexList.includes(index));   &#125;&#125;)()<span class="hljs-comment">// 这里最好加上防抖处理</span><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, imgLazyLoad)</code></pre><h3 id="10-闭包-作用域链"><a href="#10-闭包-作用域链" class="headerlink" title="10 闭包/作用域链"></a>10 闭包/作用域链</h3><p>JavaScript代码的整个执行过程，分为两个阶段，代码<strong>编译阶段</strong>与代码<strong>执行阶段</strong>。</p><ul><li>编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。</li><li>执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</li></ul><img src="https://i.loli.net/2021/06/07/SYyLVzKbrEBIo2e.png" ><p>执行上下文的生命周期：</p><img src="https://i.loli.net/2021/06/07/L4pMAozZuyDtwv7.png" ><p>作用域:<br>ES5 中只存在两种作用域：<strong>全局作用域</strong>和<strong>函数作用域</strong>。<br>在 JavaScript 中，我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域<br>以及嵌套子作用域中根据标识符名称进行变量（变量名或者函数名）查找</p><p>作用域链:<br>当访问一个变量，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，<br>如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止.<br>作用域链 —— 就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 使用闭包实现每隔一秒打印 1,2,3,4</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">1000</span> * i)&#125;)(i)&#125;</code></pre><h2 id="二-字符串"><a href="#二-字符串" class="headerlink" title="二 字符串"></a>二 字符串</h2><p>1 判断是不是回文字符串<br>2 JSON.stringify<br>3 解析 URL 参数为对象<br>4 字符串模板<br>5 转驼峰<br>6 找到出现次数最多的字符和个数<br>7 切花字符串大小写<br>8 去掉字符串中的空格</p><h3 id="1-判断一个字符串是不是回文字符串"><a href="#1-判断一个字符串是不是回文字符串" class="headerlink" title="1 判断一个字符串是不是回文字符串"></a>1 判断一个字符串是不是回文字符串</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPalindrome</span>(<span class="hljs-params">str</span>) </span>&#123;    str = str.replace(<span class="hljs-regexp">/\W/g</span>, <span class="hljs-string">&#x27;&#x27;</span>).toLowerCase();    <span class="hljs-keyword">return</span> (str == str.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));&#125;</code></pre><h3 id="2-JSON-stringify"><a href="#2-JSON-stringify" class="headerlink" title="2 JSON.stringify"></a>2 JSON.stringify</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonStringify</span>(<span class="hljs-params">obj</span>) </span>&#123;<span class="hljs-keyword">let</span> type = <span class="hljs-keyword">typeof</span> obj;<span class="hljs-keyword">if</span> (type !== <span class="hljs-string">&quot;object&quot;</span> || type === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/string|undefined|function/</span>.test(type)) &#123;obj = <span class="hljs-string">&#x27;&quot;&#x27;</span> + obj + <span class="hljs-string">&#x27;&quot;&#x27;</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(obj);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">let</span> json = [];<span class="hljs-keyword">let</span> arr = (obj &amp;&amp; obj.constructor === <span class="hljs-built_in">Array</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-keyword">let</span> v = obj[k];<span class="hljs-keyword">let</span> type = <span class="hljs-keyword">typeof</span> v;<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/string|undefined|function/</span>.test(type)) &#123;v = <span class="hljs-string">&#x27;&quot;&#x27;</span> + v + <span class="hljs-string">&#x27;&quot;&#x27;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&quot;object&quot;</span>) &#123;v = jsonStringify(v);&#125;json.push((arr ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&#x27;&quot;&#x27;</span> + k + <span class="hljs-string">&#x27;&quot;:&#x27;</span>) + <span class="hljs-built_in">String</span>(v));&#125;<span class="hljs-keyword">return</span> (arr ? <span class="hljs-string">&quot;[&quot;</span> : <span class="hljs-string">&quot;&#123;&quot;</span>) + <span class="hljs-built_in">String</span>(json) + (arr ? <span class="hljs-string">&quot;]&quot;</span> : <span class="hljs-string">&quot;&#125;&quot;</span>)&#125;&#125;<span class="hljs-comment">// var json = &#x27;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#x27;;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonEval</span>(<span class="hljs-params">json</span>) </span>&#123;<span class="hljs-comment">// obj 就是 json 反序列化之后得到的对象</span><span class="hljs-keyword">var</span> rx_one = <span class="hljs-regexp">/^[\],:&#123;&#125;\s]*$/</span>;<span class="hljs-keyword">var</span> rx_two = <span class="hljs-regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;<span class="hljs-keyword">var</span> rx_three = <span class="hljs-regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;<span class="hljs-keyword">var</span> rx_four = <span class="hljs-regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;<span class="hljs-keyword">if</span> (rx_one.test(json.replace(rx_two, <span class="hljs-string">&quot;@&quot;</span>).replace(rx_three, <span class="hljs-string">&quot;]&quot;</span>).replace(rx_four, <span class="hljs-string">&quot;&quot;</span>))) &#123;<span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;(&quot;</span> +json + <span class="hljs-string">&quot;)&quot;</span>);&#125;<span class="hljs-comment">// 或者直接 return eval(&quot;(&quot; +json + &quot;)&quot;);</span><span class="hljs-comment">// 但是会造成XSS攻击</span>&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonParse</span>(<span class="hljs-params">opt</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;(&#x27;</span> + opt + <span class="hljs-string">&#x27;)&#x27;</span>);&#125;<span class="hljs-comment">// 它会执行JS代码，有XSS漏洞。</span><span class="hljs-comment">// 如果你只想记这个方法，就得对参数json做校验</span><span class="hljs-keyword">var</span> rx_one = <span class="hljs-regexp">/^[],:&#123;&#125;s]*$/</span>;<span class="hljs-keyword">var</span> rx_two = <span class="hljs-regexp">/(?:[&quot;/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;<span class="hljs-keyword">var</span> rx_three = <span class="hljs-regexp">/&quot;[^&quot;nr]*&quot;|true|false|null|-?d+(?:.d*)?(?:[eE][+-]?d+)?/g</span>;<span class="hljs-keyword">var</span> rx_four = <span class="hljs-regexp">/(?:^|:|,)(?:s*[)+/g;</span><span class="hljs-regexp">if (</span><span class="hljs-regexp">    rx_one.test(</span><span class="hljs-regexp">        json</span><span class="hljs-regexp"> .replace(rx_two, &quot;@&quot;)</span><span class="hljs-regexp"> .replace(rx_three, &quot;]&quot;)</span><span class="hljs-regexp"> .replace(rx_four, &quot;&quot;)</span><span class="hljs-regexp"> )</span><span class="hljs-regexp">) &#123;</span><span class="hljs-regexp"> var obj = eval(&quot;(&quot; +json + &quot;)&quot;);</span><span class="hljs-regexp">&#125;</span></code></pre><h3 id="3-解析-URL-参数为对象"><a href="#3-解析-URL-参数为对象" class="headerlink" title="3 解析 URL 参数为对象"></a>3 解析 URL 参数为对象</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseParam</span>(<span class="hljs-params">url</span>) </span>&#123;<span class="hljs-comment">// 将 ? 后面的字符串取出来</span><span class="hljs-keyword">const</span> paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.exec(url)[<span class="hljs-number">1</span>];<span class="hljs-comment">// 将字符串以 &amp; 分割后存到数组中</span><span class="hljs-keyword">const</span> paramsArr = paramsStr.split(<span class="hljs-string">&#x27;&amp;&#x27;</span>);<span class="hljs-keyword">let</span> paramsObj = &#123;&#125;;<span class="hljs-comment">// 将 params 存到对象中</span>paramsArr.forEach(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.test(param)) &#123; <span class="hljs-comment">// 处理有 value 的参数</span> <span class="hljs-comment">// 分割 key 和 value</span><span class="hljs-keyword">let</span> [key, val] = param.split(<span class="hljs-string">&#x27;=&#x27;</span>);val = <span class="hljs-built_in">decodeURIComponent</span>(val); <span class="hljs-comment">// 解码</span><span class="hljs-comment">// 判断是否转为数字</span>val = <span class="hljs-regexp">/^\d+$/</span>.test(val) ? <span class="hljs-built_in">parseFloat</span>(val) : val; <span class="hljs-comment">// 如果对象有 key，则添加一个值</span><span class="hljs-keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123;paramsObj[key] = [].concat(paramsObj[key], val);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果对象没有这个 key，创建 key 并设置值</span>paramsObj[key] = val;&#125;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 处理没有 value 的参数</span>paramsObj[param] = <span class="hljs-literal">true</span>;&#125;&#125;)<span class="hljs-keyword">return</span> paramsObj;&#125;parseParam(<span class="hljs-string">&#x27;www.baidu.com?name=Ronaldo&amp;age=45&amp;contry&#x27;</span>)<span class="hljs-comment">// &#123;</span><span class="hljs-comment">// age: 45</span><span class="hljs-comment">// contry: true</span><span class="hljs-comment">// name: &quot;Ronaldo&quot;</span><span class="hljs-comment">// &#125;</span><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;parseParam(url)<span class="hljs-comment">/* 结果</span><span class="hljs-comment">&#123; user: &#x27;anonymous&#x27;,</span><span class="hljs-comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><span class="hljs-comment">  city: &#x27;北京&#x27;, // 中文需解码</span><span class="hljs-comment">  enabled: true, // 未指定值得 key 约定为 true</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span></code></pre><h3 id="4-字符串模板"><a href="#4-字符串模板" class="headerlink" title="4 字符串模板"></a>4 字符串模板</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">template, data</span>) </span>&#123;<span class="hljs-comment">// 模板字符串正则</span><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>;<span class="hljs-comment">// 判断模板里是否有模板字符串</span><span class="hljs-keyword">if</span> (reg.test(template)) &#123;<span class="hljs-comment">// 查找当前模板里第一个模板字符串的字段</span><span class="hljs-keyword">const</span> name = reg.exec(template)[<span class="hljs-number">1</span>];<span class="hljs-comment">// 将第一个模板字符串渲染</span>template = template.replace(reg, data[name]); <span class="hljs-comment">// 递归的渲染并返回渲染后的结构</span><span class="hljs-keyword">return</span> render(template, data); &#125;<span class="hljs-keyword">return</span> template; <span class="hljs-comment">// 如果模板没有模板字符串直接返回</span>&#125;<span class="hljs-comment">// test</span><span class="hljs-keyword">let</span> template = <span class="hljs-string">&#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;</span>;<span class="hljs-keyword">let</span> person = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;布兰&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>&#125;render(template, person); <span class="hljs-comment">// 我是布兰，年龄12，性别undefined</span></code></pre><h3 id="5-转驼峰"><a href="#5-转驼峰" class="headerlink" title="5 转驼峰"></a>5 转驼峰</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 解法一 正则 replace</span><span class="hljs-comment">// 1-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">var</span> resStr = str.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-params">match</span> =&gt;</span> <span class="hljs-string">&quot;_&quot;</span> + match.toLowerCase());<span class="hljs-comment">//如果首字母是大写，执行replace时会多一个_ ,这里需要去掉</span>  <span class="hljs-keyword">if</span>(resStr.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;_&#x27;</span>) &#123; <span class="hljs-comment">// resStr.startsWith(&#x27;_&#x27;)</span>  resStr = resStr.slice(<span class="hljs-number">1</span>);  &#125;<span class="hljs-keyword">return</span> resStr;&#125;;<span class="hljs-comment">// test:</span>toLowerLine(<span class="hljs-string">&quot;TestToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span>toLowerLine(<span class="hljs-string">&quot;testToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-comment">// 1-2.下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([^_])(?:_+([^_]))/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>&#123;<span class="hljs-comment">// match=t_b, $1=t, $2=b</span><span class="hljs-comment">// match=e_c, $1=e, $2=c</span><span class="hljs-keyword">return</span> $<span class="hljs-number">1</span> + $<span class="hljs-number">2.</span>toUpperCase();  &#125;);&#125;<span class="hljs-comment">// test</span>toCamel(<span class="hljs-string">&#x27;test_be_camel&#x27;</span>) <span class="hljs-comment">// testBeCamel</span><span class="hljs-comment">// 解法二: reduce</span><span class="hljs-comment">// 2-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(cur))&#123;cur = cur.toLowerCase();<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? pre + cur :  pre + <span class="hljs-string">&#x27;_&#x27;</span> + cur&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> pre + cur;&#125;&#125;, <span class="hljs-string">&#x27;&#x27;</span>)&#125;<span class="hljs-comment">// test</span>toLowerLine(<span class="hljs-string">&#x27;TestToLowerLine&#x27;</span>); <span class="hljs-comment">// test_to_lower_line</span><span class="hljs-comment">// 2-2.下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (pre.endsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) &#123;<span class="hljs-keyword">return</span> pre.substring(<span class="hljs-number">0</span>, pre.length - <span class="hljs-number">1</span>) + cur.toUpperCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> pre + cur;&#125;&#125;)&#125;<span class="hljs-comment">// test</span>toCamel(<span class="hljs-string">&#x27;test_to_camel&#x27;</span>); <span class="hljs-comment">// testToCamel</span><span class="hljs-comment">// 解法三: Array.map()</span><span class="hljs-comment">// 3-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-comment">// return [].map.call(arr, doLowerLine).join(&#x27;&#x27;);</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.map.call(arr, <span class="hljs-function">(<span class="hljs-params">val, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(val))&#123;<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? val.toLowerCase() : <span class="hljs-string">&#x27;_&#x27;</span> + val.toLowerCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> val;&#125;&#125;).join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;</code></pre><h3 id="6-找到出现次数最多的字符和个数"><a href="#6-找到出现次数最多的字符和个数" class="headerlink" title="6 找到出现次数最多的字符和个数"></a>6 找到出现次数最多的字符和个数</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMore</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-comment">// str = &quot;abcabcabcbbccccc&quot;</span><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> char = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">// 使其按照一定的次序排列</span>str = str.split(<span class="hljs-string">&#x27;&#x27;</span>).sort().join(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-comment">// str = &quot;aaabbbbbcccccccc&quot;</span><span class="hljs-comment">// 定义正则表达式</span><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/(\w)\1+/g</span>;str.replace(re,<span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">0</span>,$<span class="hljs-number">1</span></span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(num &lt; $<span class="hljs-number">0.</span>length)&#123;num = $<span class="hljs-number">0.</span>length;char = $<span class="hljs-number">1</span>;        &#125;&#125;);<span class="hljs-keyword">return</span> &#123;num,char,&#125;&#125;</code></pre><h3 id="7-切花字符串大小写"><a href="#7-切花字符串大小写" class="headerlink" title="7 切花字符串大小写"></a>7 切花字符串大小写</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caseConvert</span>(<span class="hljs-params">str</span>)</span>&#123;   <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([a-z]*)([A-Z]*)/g</span>, <span class="hljs-function">(<span class="hljs-params">m, s1, s2</span>)=&gt;</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;s1.toUpperCase()&#125;</span><span class="hljs-subst">$&#123;s2.toLowerCase()&#125;</span>`</span>   &#125;)&#125;caseConvert(<span class="hljs-string">&#x27;AsA33322A2aa&#x27;</span>) <span class="hljs-comment">//aSa33322a2AA</span></code></pre><h3 id="8-去掉字符串中的空格"><a href="#8-去掉字符串中的空格" class="headerlink" title="8 去掉字符串中的空格"></a>8 去掉字符串中的空格</h3><pre><code class="hljs javaScript"> <span class="hljs-keyword">const</span> POSITION = <span class="hljs-built_in">Object</span>.freeze(&#123;  <span class="hljs-attr">left</span>: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 左</span>  <span class="hljs-attr">right</span>: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 右</span>  <span class="hljs-attr">both</span>: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 左右</span>  <span class="hljs-attr">center</span>: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 中间</span>  <span class="hljs-attr">all</span>: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 全部</span>&#125;) <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trim</span>(<span class="hljs-params">str, position = POSITION.both</span>) </span>&#123;<span class="hljs-keyword">if</span> (!!POSITION[position]) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;unexpected position value&#x27;</span>)<span class="hljs-keyword">switch</span>(position) &#123;<span class="hljs-keyword">case</span>(POSITION.left):str = str.replace(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span>(POSITION.right):str = str.replace(<span class="hljs-regexp">/\s+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span>(POSITION.both):str = str.replace(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-regexp">/\s+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span>(POSITION.center):<span class="hljs-keyword">while</span> (str.match(<span class="hljs-regexp">/\w\s+\w/</span>)) &#123;str = str.replace(<span class="hljs-regexp">/(\w)(\s+)(\w)/</span>, <span class="hljs-string">`$1$3`</span>)&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span>(POSITION.all):str = str.replace(<span class="hljs-regexp">/\s/g</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>: &#125;<span class="hljs-keyword">return</span> str;&#125;<span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;  s t  r  &#x27;</span><span class="hljs-keyword">const</span> result = trim(str)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`|<span class="hljs-subst">$&#123;result&#125;</span>|`</span>) <span class="hljs-comment">//  |s t  r| </span></code></pre><h2 id="三-Object"><a href="#三-Object" class="headerlink" title="三 Object"></a>三 Object</h2><p>1 Symbol（for…in/of）<br>2 继承<br>3 双向绑定<br>4 发布订阅模式<br>5 观察者模式<br>6 Object.assign<br>7 EventEmitter</p><h3 id="1-Symbol（for…in-of）"><a href="#1-Symbol（for…in-of）" class="headerlink" title="1 Symbol（for…in/of）"></a>1 Symbol（for…in/of）</h3><p>Symbol: 可以用来表示一个独一无二的变量防止命名冲突.</p><p>Symbol作用：</p><ol><li>还可以利用 symbol 不会被常规的方法（除了 <code>Object.getOwnPropertySymbols</code> 外）遍历到，所以可以用来模拟私有变量。</li><li>用来提供遍历接口，布置了 <code>symbol.iterator</code> 的对象才可以使用 <code>for···of</code> 循环，可以统一处理数据结构。<br>调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</li></ol><p><code>Symbol.for()</code> 可以在全局访问 symbol</p><ul><li>for……in : 遍历 key,</li><li>for……of : 遍历 value,</li></ul><p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性。或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。<br>Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。</p><p>因为object 没有 Symbol.iterator 属性，所以不能被 for…of 遍历。</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> text = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<span class="hljs-attr">c</span>:<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> text)&#123;<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 报错：Uncaught TypeError: text is not iterable</span>&#125;</code></pre><p>所以，object想要被 for…of遍历 ，必须在原来的基础上加上 Symbol.iterator 接口属性。</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> text = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,&#125;;<span class="hljs-comment">// 给对象加上 iterator 接口,使之能被 for…of 遍历</span>text[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">const</span> _this = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">index</span>: -<span class="hljs-number">1</span>,<span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Object</span>.keys(_this);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.index &lt; arr.length)&#123;<span class="hljs-built_in">this</span>.index++;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: _this[arr[<span class="hljs-built_in">this</span>.index]],<span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>,&#125;&#125;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> text)&#123;<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 1 2 3 undefined</span>&#125;</code></pre><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2 继承"></a>2 继承</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 原型链继承</span><span class="hljs-comment">// 缺点：</span><span class="hljs-comment">// 问题1：原型中包含的引用类型属性将被所有实例共享；</span><span class="hljs-comment">// 问题2：子类在实例化的时候不能给父类构造函数传参；</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]&#125;Animal.prototype.getColor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.colors&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"></span>) </span>&#123;&#125;Dog.prototype =  <span class="hljs-keyword">new</span> Animal()<span class="hljs-keyword">let</span> dog1 = <span class="hljs-keyword">new</span> Dog()dog1.colors.push(<span class="hljs-string">&#x27;brown&#x27;</span>)<span class="hljs-keyword">let</span> dog2 = <span class="hljs-keyword">new</span> Dog()<span class="hljs-built_in">console</span>.log(dog2.colors)  <span class="hljs-comment">// [&#x27;black&#x27;, &#x27;white&#x27;, &#x27;brown&#x27;]</span><span class="hljs-comment">// 2 借用构造函数实现继承</span><span class="hljs-comment">// 借用构造函数实现继承解决了原型链继承的 2 个问题:</span><span class="hljs-comment">// 引用类型共享问题以及传参问题。</span><span class="hljs-comment">// 但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name<span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name</span>) </span>&#123;Animal.call(<span class="hljs-built_in">this</span>, name)&#125;Dog.prototype =  <span class="hljs-keyword">new</span> Animal()<span class="hljs-comment">// 3 组合继承</span><span class="hljs-comment">// 组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。</span><span class="hljs-comment">// 基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。</span><span class="hljs-comment">// 这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name<span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]&#125;Animal.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name, age</span>) </span>&#123;Animal.call(<span class="hljs-built_in">this</span>, name)<span class="hljs-built_in">this</span>.age = age&#125;Dog.prototype = <span class="hljs-keyword">new</span> Animal()Dog.prototype.constructor = Dog<span class="hljs-keyword">let</span> dog1 = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;奶昔&#x27;</span>, <span class="hljs-number">2</span>)dog1.colors.push(<span class="hljs-string">&#x27;brown&#x27;</span>)<span class="hljs-keyword">let</span> dog2 = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;哈赤&#x27;</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">console</span>.log(dog2) <span class="hljs-comment">// &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125;</span><span class="hljs-comment">// 4 寄生式组合继承</span><span class="hljs-comment">// 组合继承已经相对完善了，但还是存在问题:</span><span class="hljs-comment">// 它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。</span><span class="hljs-comment">// 所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name<span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]&#125;Animal.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name, age</span>) </span>&#123;Animal.call(<span class="hljs-built_in">this</span>, name)<span class="hljs-built_in">this</span>.age = age&#125;Dog.prototype =  <span class="hljs-built_in">Object</span>.create(Animal.prototype)Dog.prototype.constructor = Dog<span class="hljs-keyword">let</span> dog1 = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;奶昔&#x27;</span>, <span class="hljs-number">2</span>)dog1.colors.push(<span class="hljs-string">&#x27;brown&#x27;</span>)<span class="hljs-keyword">let</span> dog2 = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;哈赤&#x27;</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">console</span>.log(dog2) <span class="hljs-comment">// &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125;</span></code></pre><h3 id="3-双向绑定"><a href="#3-双向绑定" class="headerlink" title="3 双向绑定"></a>3 双向绑定</h3><pre><code class="hljs javaScript">&lt;body&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;model&quot;</span> /&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;modelText&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> user = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aaaa&#x27;</span>&#125;;<span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#model&quot;</span>);<span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#modelText&quot;</span>);input.value = user.name;text.textContent = user.name;<span class="hljs-comment">// 数据到视图 model =&gt; view</span><span class="hljs-built_in">Object</span>.defineProperty(user, <span class="hljs-string">&quot;name&quot;</span>, &#123;<span class="hljs-attr">get</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;获取user&#x27;</span>)&#125;,<span class="hljs-attr">set</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;修改user&#x27;</span>)input.value = val;text.textContent = val;&#125;&#125;)<span class="hljs-comment">// 视图到数据 view =&gt; model (可以监听 input 和 keyup)</span>input.addEventListener(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;user.name = input.value;&#125;)<span class="hljs-comment">// 输入框发生的事件流程依次为</span><span class="hljs-comment">// focus -&gt; keydown -&gt; input -&gt; keyup -&gt; change -&gt; blur</span>&#125;</code></pre><blockquote><p><a href="https://blog.csdn.net/weixin_39516865/article/details/111388183">手写bind_手写JavaScript几个方法</a><br><a href="https://github.com/YvetteLau/Blog/issues/35">github-blog</a></p></blockquote><h3 id="4-发布订阅模式"><a href="#4-发布订阅模式" class="headerlink" title="4 发布订阅模式"></a>4 发布订阅模式</h3><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-built_in">this</span>.cache = &#123;&#125;;    &#125;    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">name, fn</span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cache[name]) &#123;            <span class="hljs-built_in">this</span>.cache[name].push(fn);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">this</span>.cache[name] = [fn];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">name, fn</span>)</span> &#123;        <span class="hljs-keyword">let</span> tasks = <span class="hljs-built_in">this</span>.cache[name];        <span class="hljs-keyword">if</span> (tasks) &#123;            <span class="hljs-keyword">const</span> index = tasks.findIndex(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f === fn || f.callback === fn)            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;                tasks.splice(index, <span class="hljs-number">1</span>)            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">name, once = <span class="hljs-literal">false</span>, ...args</span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cache[name]) &#123;            <span class="hljs-comment">// 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span>            <span class="hljs-keyword">let</span> tasks = <span class="hljs-built_in">this</span>.cache[name].slice()            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fn <span class="hljs-keyword">of</span> tasks) &#123;               fn(...args)            &#125;            <span class="hljs-keyword">if</span> (once) &#123;               <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.cache[name]            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// 测试</span><span class="hljs-keyword">let</span> eventBus = <span class="hljs-keyword">new</span> EventEmitter()<span class="hljs-keyword">let</span> fn1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, age</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;age&#125;</span>`</span>)&#125;<span class="hljs-keyword">let</span> fn2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, age</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`hello, <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;age&#125;</span>`</span>)&#125;eventBus.on(<span class="hljs-string">&#x27;aaa&#x27;</span>, fn1)eventBus.on(<span class="hljs-string">&#x27;aaa&#x27;</span>, fn2)eventBus.emit(<span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;布兰&#x27;</span>, <span class="hljs-number">12</span>)<span class="hljs-comment">// &#x27;布兰 12&#x27;</span><span class="hljs-comment">// &#x27;hello, 布兰 12&#x27;</span></code></pre><h3 id="5-观察者模式"><a href="#5-观察者模式" class="headerlink" title="5 观察者模式"></a>5 观察者模式</h3><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span></span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name = name<span class="hljs-built_in">this</span>.observers = []<span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;XXXX&#x27;</span>&#125;<span class="hljs-comment">// 被观察者要提供一个接受观察者的方法</span><span class="hljs-function"><span class="hljs-title">attach</span>(<span class="hljs-params">observer</span>)</span>&#123;<span class="hljs-built_in">this</span>.observers.push(observer)&#125;<span class="hljs-comment">// 改变被观察着的状态</span><span class="hljs-function"><span class="hljs-title">setState</span>(<span class="hljs-params">newState</span>)</span>&#123;<span class="hljs-built_in">this</span>.state = newState<span class="hljs-built_in">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">o</span>=&gt;</span>&#123;o.update(newState)&#125;)&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span></span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name = name&#125;<span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">newState</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>say:<span class="hljs-subst">$&#123;newState&#125;</span>`</span>)&#125;&#125;<span class="hljs-comment">// 被观察者 灯</span><span class="hljs-keyword">let</span> sub = <span class="hljs-keyword">new</span> Subject(<span class="hljs-string">&#x27;灯&#x27;</span>)<span class="hljs-keyword">let</span> mm = <span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;小明&#x27;</span>)<span class="hljs-keyword">let</span> jj = <span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;小健&#x27;</span>) <span class="hljs-comment">// 订阅 观察者</span>sub.attach(mm)sub.attach(jj) sub.setState(<span class="hljs-string">&#x27;灯亮了来电了&#x27;</span>)</code></pre><h3 id="6-Object-assign"><a href="#6-Object-assign" class="headerlink" title="6 Object.assign"></a>6 Object.assign</h3><pre><code class="hljs javaScript"><span class="hljs-built_in">Object</span>.assign2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, ...source</span>) </span>&#123;<span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Cannot convert undefined or null to object&#x27;</span>)&#125;<span class="hljs-keyword">let</span> ret = <span class="hljs-built_in">Object</span>(target);source.forEach(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;ret[key] = obj[key]&#125;&#125;&#125;&#125;)<span class="hljs-keyword">return</span> ret;&#125;</code></pre><h3 id="7-EventEmitter"><a href="#7-EventEmitter" class="headerlink" title="7 EventEmitter"></a>7 EventEmitter</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 发布订阅模式</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// 事件对象，存放订阅的名字和事件  如:  &#123; click: [ handle1, handle2 ]  &#125;</span><span class="hljs-built_in">this</span>.events = &#123;&#125;;&#125;<span class="hljs-comment">// 订阅事件的方法</span><span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventName, callback</span>)</span> &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.events[eventName]) &#123;<span class="hljs-comment">// 一个名字可以订阅多个事件函数</span><span class="hljs-built_in">this</span>.events[eventName] = [callback];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 存在则push到指定数组的尾部保存</span><span class="hljs-built_in">this</span>.events[eventName].push(callback);&#125;&#125;<span class="hljs-comment">// 触发事件的方法</span><span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">eventName, ...rest</span>)</span> &#123;<span class="hljs-comment">// 遍历执行所有订阅的事件</span><span class="hljs-built_in">this</span>.events[eventName] &amp;&amp;<span class="hljs-built_in">this</span>.events[eventName].forEach(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, rest));&#125;<span class="hljs-comment">// 移除订阅事件</span><span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">eventName, callback</span>)</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.events[eventName]) &#123;<span class="hljs-built_in">this</span>.events[eventName] = <span class="hljs-built_in">this</span>.events[eventName].filter(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f != callback);&#125;&#125;<span class="hljs-comment">// 只执行一次订阅的事件，然后移除</span><span class="hljs-function"><span class="hljs-title">once</span>(<span class="hljs-params">eventName, callback</span>)</span> &#123;<span class="hljs-comment">// 绑定的时fn, 执行的时候会触发fn函数</span><span class="hljs-keyword">const</span> fn = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> &#123;callback.apply(<span class="hljs-built_in">this</span>, rest) <span class="hljs-comment">// fn函数中调用原有的callback</span><span class="hljs-built_in">this</span>.remove(eventName, fn) <span class="hljs-comment">// 删除fn, 再次执行的时候之后执行一次</span>&#125;<span class="hljs-built_in">this</span>.on(eventName, fn)&#125;&#125;<span class="hljs-comment">// test1</span><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> EventEmitter()<span class="hljs-keyword">const</span> handle = <span class="hljs-function">(<span class="hljs-params">...pyload</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(pyload)event.on(<span class="hljs-string">&#x27;click&#x27;</span>, handle)event.emit(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>)event.remove(<span class="hljs-string">&#x27;click&#x27;</span>, handle)event.once(<span class="hljs-string">&#x27;dbclick&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;click&#x27;</span>)&#125;)event.emit(<span class="hljs-string">&#x27;dbclick&#x27;</span>, <span class="hljs-number">100</span>);<span class="hljs-comment">// test 2</span><span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> EventEmitter();event.on(<span class="hljs-string">&#x27;say&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(str);&#125;);event.once(<span class="hljs-string">&#x27;say&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是once:&#x27;</span> + str)&#125;)event.emit(<span class="hljs-string">&#x27;say&#x27;</span>,<span class="hljs-string">&#x27;visa&#x27;</span>);event.emit(<span class="hljs-string">&#x27;say&#x27;</span>,<span class="hljs-string">&#x27;visa222&#x27;</span>);event.emit(<span class="hljs-string">&#x27;say&#x27;</span>,<span class="hljs-string">&#x27;visa333&#x27;</span>);</code></pre><h2 id="四-Promise"><a href="#四-Promise" class="headerlink" title="四 Promise"></a>四 Promise</h2><p>1 手写promise<br>2 实现promise串行<br>3 实现Promise并发调度<br>4 JavaScript并发控制<br>5 手写generator<br>6 用 setTimeout 模拟 setInterval</p><h3 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1 Promise"></a>1 Promise</h3><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> STATUS = &#123;<span class="hljs-attr">PENDING</span>: <span class="hljs-string">&#x27;pending&#x27;</span>,<span class="hljs-attr">FULFILLED</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>,<span class="hljs-attr">REJECTED</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">executor</span>)</span> &#123;<span class="hljs-built_in">this</span>._status = STATUS.PENDING; <span class="hljs-comment">// Promise初始状态</span><span class="hljs-built_in">this</span>._value = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// then回调的值</span><span class="hljs-built_in">this</span>._resolveQueue = []; <span class="hljs-comment">// resolve时触发的成功队列</span><span class="hljs-built_in">this</span>._rejectQueue = []; <span class="hljs-comment">// reject时触发的失败队列</span><span class="hljs-comment">// 使用箭头函数固定this（resolve函数在executor中触发，不然找不到this）</span><span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-keyword">const</span> run = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// Promise/A+ 规范规定的Promise状态只能从pending触发，变成fulfilled</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status === STATUS.PENDING) &#123;<span class="hljs-built_in">this</span>._status = STATUS.FULFILLED; <span class="hljs-comment">// 更改状态</span><span class="hljs-built_in">this</span>._value = value; <span class="hljs-comment">// 储存当前值，用于then回调</span><span class="hljs-comment">// 执行resolve回调</span><span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._resolveQueue.length) &#123;<span class="hljs-keyword">const</span> callback = <span class="hljs-built_in">this</span>._resolveQueue.shift();callback(value);&#125;&#125;&#125;<span class="hljs-comment">// 把resolve执行回调的操作封装成一个函数,放进setTimeout里</span><span class="hljs-comment">// 以实现promise异步调用的特性（规范上是微任务，这里是宏任务）</span><span class="hljs-built_in">setTimeout</span>(run);&#125;<span class="hljs-comment">// 同 resolve</span><span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-keyword">const</span> run = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status === STATUS.PENDING) &#123;<span class="hljs-built_in">this</span>._status = STATUS.REJECTED;<span class="hljs-built_in">this</span>._value = value;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._rejectQueue.length) &#123;<span class="hljs-keyword">const</span> callback = <span class="hljs-built_in">this</span>._rejectQueue.shift();callback(value);&#125;&#125;&#125;<span class="hljs-built_in">setTimeout</span>(run);&#125;<span class="hljs-comment">// new Promise()时立即执行executor,并传入resolve和reject</span>executor(resolve, reject);&#125; <span class="hljs-comment">// then方法,接收一个成功的回调和一个失败的回调</span><span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;<span class="hljs-comment">// 根据规范，如果then的参数不是function，则忽略它, 让值继续往下传递，链式调用继续往下执行</span><span class="hljs-keyword">typeof</span> onFulfilled !== <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value : <span class="hljs-literal">null</span>;<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected = <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> error : <span class="hljs-literal">null</span>;<span class="hljs-comment">// then 返回一个新的promise</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> resolveFn = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">const</span> res = onFulfilled(value);<span class="hljs-comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span>res <span class="hljs-keyword">instanceof</span> MyPromise ? res.then(resolve, reject) : resolve(res);&#125; <span class="hljs-keyword">catch</span> (error) &#123;reject(error);&#125;&#125;<span class="hljs-keyword">const</span> rejectFn = <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">const</span> res = onRejected(error);res <span class="hljs-keyword">instanceof</span> MyPromise ? res.then(resolve, reject) : resolve(res);&#125; <span class="hljs-keyword">catch</span> (error) &#123;reject(error);&#125;&#125;<span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>._status) &#123;<span class="hljs-keyword">case</span> STATUS.PENDING:<span class="hljs-built_in">this</span>._resolveQueue.push(resolveFn);<span class="hljs-built_in">this</span>._rejectQueue.push(rejectFn);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> STATUS.FULFILLED:resolveFn(<span class="hljs-built_in">this</span>._value);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> STATUS.REJECTED:rejectFn(<span class="hljs-built_in">this</span>._value);<span class="hljs-keyword">break</span>;&#125;&#125;)&#125; <span class="hljs-keyword">catch</span>(rejectFn) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">undefined</span>, rejectFn);&#125; <span class="hljs-function"><span class="hljs-title">finally</span>(<span class="hljs-params">callback</span>)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> value), <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;MyPromise.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> error);  &#125;)&#125; <span class="hljs-comment">// 静态resolve方法</span><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<span class="hljs-keyword">return</span> value <span class="hljs-keyword">instanceof</span> MyPromise ? value : <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(value));&#125; <span class="hljs-comment">// 静态reject方法</span><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">error</span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(error));&#125; <span class="hljs-comment">// 静态all方法</span><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promiseArr</span>)</span> &#123;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> result = [];<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!promiseArr.length) &#123;<span class="hljs-keyword">return</span> resolve(result);&#125;promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> &#123;MyPromise.resolve(p).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;count++;result[i] = value;<span class="hljs-keyword">if</span> (count === promiseArr.length) &#123;resolve(result);&#125;&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;reject(error);&#125;)&#125;)&#125;)&#125; <span class="hljs-comment">// 静态race方法</span><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params">promiseArr</span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;MyPromise.resolve(p).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;resolve(value);&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;reject(error);&#125;)&#125;)&#125;)&#125;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">iterator</span>) </span>&#123;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> iterator)&#123;<span class="hljs-comment">// 先转化为Promise对象</span><span class="hljs-built_in">Promise</span>.resolve(iterator[i]).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;res[i] = data;<span class="hljs-keyword">if</span>(++count === iterator.length)&#123;resolve(res);&#125;&#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;reject(e);&#125;)&#125;&#125;)&#125;<span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">iterators</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!iterators || iterators.length === <span class="hljs-number">0</span>) &#123;resolve([]);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器，用于判断所有任务是否执行完成</span><span class="hljs-keyword">let</span> result = []; <span class="hljs-comment">// 结果数组</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; iterators.length; i++) &#123;<span class="hljs-comment">// 考虑到iterators[i]可能是普通对象，则统一包装为Promise对象</span><span class="hljs-built_in">Promise</span>.resolve(iterators[i]).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;result[i] = data; <span class="hljs-comment">// 按顺序保存对应的结果</span><span class="hljs-comment">// 当所有任务都执行完成后，再统一返回结果</span><span class="hljs-keyword">if</span> (++count === iterators.length) &#123;resolve(result);&#125;&#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;reject(err); <span class="hljs-comment">// 任何一个Promise对象执行失败，则调用reject()方法</span><span class="hljs-keyword">return</span>;&#125;);&#125;&#125;&#125;);&#125;;<span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">iterators</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> iterators) &#123;<span class="hljs-built_in">Promise</span>.resolve(p).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;resolve(res)&#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;reject(e)&#125;)&#125;&#125;)&#125;<span class="hljs-comment">// 1 空数组或者所有 Promise 都是 rejected</span><span class="hljs-comment">// 则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；</span><span class="hljs-comment">// 2 只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；</span><span class="hljs-comment">// 3 其他情况都会返回一个 pending 的新实例</span><span class="hljs-built_in">Promise</span>.any = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (promiseArr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>         promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> &#123;            <span class="hljs-built_in">Promise</span>.resolve(p).then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;                resolve(val)                            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                index++                <span class="hljs-keyword">if</span> (index === promiseArr.length) &#123;                  reject(<span class="hljs-keyword">new</span> AggregateError(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>))                &#125;            &#125;)        &#125;)    &#125;)&#125;<span class="hljs-comment">// 1 所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise</span><span class="hljs-comment">//   且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象；</span><span class="hljs-comment">// 2 如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例；</span><span class="hljs-built_in">Promise</span>.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;<span class="hljs-keyword">let</span> result = []<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> &#123;<span class="hljs-built_in">Promise</span>.resolve(p).then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;result.push(&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>,<span class="hljs-attr">value</span>: val&#125;)<span class="hljs-keyword">if</span> (result.length === promiseArr.length) &#123;resolve(result) &#125;&#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;result.push(&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>,<span class="hljs-attr">reason</span>: err&#125;)<span class="hljs-keyword">if</span> (result.length === promiseArr.length) &#123;resolve(result) &#125;&#125;)&#125;)  &#125;)   &#125;<span class="hljs-comment">// promise 串行</span><span class="hljs-comment">// create Promise</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPromise</span>(<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;time in&#x27;</span> + time)            resolve();        &#125;, time * <span class="hljs-number">1000</span>)    &#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iteratorPromise</span>(<span class="hljs-params">arr</span>) </span>&#123;arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, next, index, carr</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> pre.then(next)&#125;, <span class="hljs-built_in">Promise</span>.resolve())&#125;<span class="hljs-keyword">var</span> arr = [createPromise(<span class="hljs-number">1</span>), createPromise(<span class="hljs-number">3</span>), createPromise(<span class="hljs-number">2</span>), createPromise(<span class="hljs-number">4</span>)]iteratorPromise(arr);</code></pre><h3 id="2-实现一个串行promise"><a href="#2-实现一个串行promise" class="headerlink" title="2 实现一个串行promise"></a>2 实现一个串行promise</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPromise</span>(<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;time in&#x27;</span> + time)            resolve();        &#125;, time * <span class="hljs-number">1000</span>)    &#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iteratorPromise</span>(<span class="hljs-params">arr</span>) </span>&#123;arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, next, index, carr</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> pre.then(next)&#125;, <span class="hljs-built_in">Promise</span>.resolve())&#125;<span class="hljs-keyword">var</span> arr = [createPromise(<span class="hljs-number">1</span>), createPromise(<span class="hljs-number">3</span>), createPromise(<span class="hljs-number">2</span>), createPromise(<span class="hljs-number">4</span>)]iteratorPromise(arr);</code></pre><h3 id="3-promise-并发调度"><a href="#3-promise-并发调度" class="headerlink" title="3 promise 并发调度"></a>3 promise 并发调度</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 实现一个并发请求的函数</span><span class="hljs-keyword">var</span> jsonArr = [<span class="hljs-string">&#x27;api1.json&#x27;</span>, <span class="hljs-string">&#x27;api2.json&#x27;</span>, <span class="hljs-string">&#x27;api3.json&#x27;</span>, <span class="hljs-string">&#x27;api4.json&#x27;</span>, <span class="hljs-string">&#x27;api5.json&#x27;</span>, <span class="hljs-string">&#x27;api6.json&#x27;</span>]fetchAll(jsonArr, <span class="hljs-number">2</span>).then(<span class="hljs-function">(<span class="hljs-params">[res1, res2, res3, res4, res5, res6]</span>) =&gt;</span> &#123;&#125;)<span class="hljs-comment">// 其中 jsonArr 为包含需要请求接口名的数组，limit 为最大并发请求数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAll</span>(<span class="hljs-params">jsonArr, limit</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<span class="hljs-comment">// 结果</span><span class="hljs-keyword">let</span> resList = [];<span class="hljs-comment">// 当前正在执行的并发任务队列</span><span class="hljs-keyword">const</span> currPList = [];<span class="hljs-keyword">let</span> i = jsonArr.length - <span class="hljs-number">1</span>;<span class="hljs-comment">// 调度任务队列</span><span class="hljs-keyword">const</span> fetcher = <span class="hljs-keyword">async</span> () =&gt; &#123;<span class="hljs-keyword">while</span>(jsonArr.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">let</span> j = i = i - <span class="hljs-number">1</span>;resList[j] = <span class="hljs-keyword">await</span> fetch(jsonArr.shift());&#125;&#125;<span class="hljs-comment">// 线程池</span><span class="hljs-keyword">while</span>(limit) &#123;--limit;<span class="hljs-comment">// 控制当前并发调度队列只有2个</span>currPList.push(fetcher());&#125;<span class="hljs-comment">// 让2个并发队列同时执行</span><span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(currPList);resolve(resList);&#125;);&#125;</code></pre><h3 id="4-JavaScript-并发调度"><a href="#4-JavaScript-并发调度" class="headerlink" title="4 JavaScript 并发调度"></a>4 JavaScript 并发调度</h3><p>该函数接收 3 个参数：</p><ul><li>poolLimit（数字类型）：表示限制的并发数；</li><li>array（数组类型）：表示任务数组；</li><li>iteratorFn（函数类型）：表示迭代函数，用于实现对每个任务项进行处理，该函数会返回一个 Promise 对象或异步函数。</li></ul><pre><code class="hljs javaScript"><span class="hljs-comment">// ES6 版本实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPool</span>(<span class="hljs-params">poolLimit, array, iteratorFn</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> ret = []; <span class="hljs-comment">// 存储所有的异步任务</span><span class="hljs-keyword">const</span> executing = []; <span class="hljs-comment">// 存储正在执行的异步任务</span><span class="hljs-keyword">const</span> enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (i === array.length) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();&#125;<span class="hljs-keyword">const</span> item = array[i++]; <span class="hljs-comment">// 获取新的任务项</span><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> iteratorFn(item, array));ret.push(p);<span class="hljs-keyword">let</span> r = <span class="hljs-built_in">Promise</span>.resolve();<span class="hljs-comment">// 当poolLimit值小于或等于总任务个数时，进行并发控制</span><span class="hljs-keyword">if</span> (poolLimit &lt;= array.length) &#123;<span class="hljs-comment">// 当任务完成后，从正在执行的任务数组中移除已完成的任务</span><span class="hljs-keyword">const</span> e = p.then(<span class="hljs-function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="hljs-number">1</span>));executing.push(e);<span class="hljs-keyword">if</span> (executing.length &gt;= poolLimit) &#123;r = <span class="hljs-built_in">Promise</span>.race(executing); &#125;&#125;<span class="hljs-comment">// 正在执行任务列表 中较快的任务执行完成之后，才会从array数组中获取新的待办任务</span><span class="hljs-keyword">return</span> r.then(<span class="hljs-function">() =&gt;</span> enqueue());&#125;;<span class="hljs-keyword">return</span> enqueue().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.all(ret));&#125;<span class="hljs-comment">// ES7 版本实现</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPool</span>(<span class="hljs-params">poolLimit, array, iteratorFn</span>) </span>&#123;<span class="hljs-keyword">const</span> ret = []; <span class="hljs-comment">// 存储所有的异步任务</span><span class="hljs-keyword">const</span> executing = []; <span class="hljs-comment">// 存储正在执行的异步任务</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) &#123;<span class="hljs-comment">// 调用iteratorFn函数创建异步任务</span><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> iteratorFn(item, array));ret.push(p); <span class="hljs-comment">// 保存新的异步任务</span><span class="hljs-comment">// 当poolLimit值小于或等于总任务个数时，进行并发控制</span><span class="hljs-keyword">if</span> (poolLimit &lt;= array.length) &#123;<span class="hljs-comment">// 当任务完成后，从正在执行的任务数组中移除已完成的任务</span><span class="hljs-keyword">const</span> e = p.then(<span class="hljs-function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="hljs-number">1</span>));executing.push(e); <span class="hljs-comment">// 保存正在执行的异步任务</span><span class="hljs-keyword">if</span> (executing.length &gt;= poolLimit) &#123;<span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.race(executing); <span class="hljs-comment">// 等待较快的任务执行完成</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(ret);&#125;</code></pre><h3 id="5-简易版generator"><a href="#5-简易版generator" class="headerlink" title="5 简易版generator"></a>5 简易版generator</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myGenerator</span>(<span class="hljs-params">list</span>) </span>&#123;<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> len = list.length;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> done = index &gt;= len;<span class="hljs-keyword">var</span> value = !done ? list[index++] : <span class="hljs-literal">undefined</span>; <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">done</span>: done,<span class="hljs-attr">value</span>: value&#125;&#125;&#125;&#125;<span class="hljs-keyword">var</span> gen = myGenerator([<span class="hljs-string">&#x27;大罗&#x27;</span>, <span class="hljs-string">&#x27;小罗&#x27;</span>, <span class="hljs-string">&#x27;C罗&#x27;</span>]);gen.next(); <span class="hljs-comment">// &#123;done: false, value: &quot;大罗&quot;&#125;</span>gen.next(); <span class="hljs-comment">// &#123;done: false, value: &quot;小罗&quot;&#125;</span>gen.next(); <span class="hljs-comment">// &#123;done: false, value: &quot;C罗&quot;&#125;</span>gen.next(); <span class="hljs-comment">// &#123;done: true, value: undefined&#125;</span></code></pre><h3 id="6-用-setTimeout-模拟-setInterval"><a href="#6-用-setTimeout-模拟-setInterval" class="headerlink" title="6 用 setTimeout 模拟 setInterval"></a>6 用 setTimeout 模拟 setInterval</h3><p>题目：用 setTimeout 函数 模拟 setInterval</p><p>前置条件：</p><ol><li>假设 setTimeout 里执行的目标函数返回的是一个 Promise</li><li>假设 interval 的值为 3000, 单位为 ms</li></ol><p>要求：</p><ol><li>不能使用 setInterval 函数</li><li>调用 mockInterval 函数时，确保能够立即执行一次目标函数，无需等待 3000ms</li><li>当 Promise 执行的时间小于 3000ms 时，需要确保过了 3000ms 之后才能执行下一次 callback</li><li>当 Promise 执行的时间超出 3000ms 时，需要等待 Promise 执行完成，才能走回想下一次 callBack </li></ol><pre><code class="hljs javaScript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mockInterval</span>(<span class="hljs-params">callBack, time=<span class="hljs-number">3000</span></span>) </span>&#123;<span class="hljs-comment">// 为了防止传入的 callBack 是一个异步函数</span><span class="hljs-keyword">await</span> callBack();setIntervalFn(callBack, time);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setIntervalFn</span>(<span class="hljs-params">callBack, time</span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">resolve</span>)</span>&#123;<span class="hljs-comment">// 为了防止传入的 callBack 是一个异步函数</span><span class="hljs-keyword">await</span> callBack();setIntervalFn(callBack, time);&#125;)&#125;, time)&#125;<span class="hljs-comment">// test</span>mockInterval(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;call Back fn&#x27;</span>);&#125;, <span class="hljs-number">3000</span>)</code></pre><h2 id="五-函数-数组"><a href="#五-函数-数组" class="headerlink" title="五 函数/数组"></a>五 函数/数组</h2><p>1 函数柯里化<br>2 偏函数<br>3 compose 函数<br>4 LRU 函数<br>5 loadsh -&gt; get<br>6 sleep函数<br>7 数组随机打乱<br>8 数组扁平化<br>9 Array.prototype.fill<br>10 Array.prototype.map<br>11 Array.prototype.reduce<br>12 Array.prototype.forEach<br>13 Array.prototype.filter<br>14 Array.prototype.some<br>15 两数相加<br>16 两数相减<br>17 两数相乘<br>18 两数相除<br>19 Math.pow()</p><h3 id="1-函数柯里化"><a href="#1-函数柯里化" class="headerlink" title="1 函数柯里化"></a>1 函数柯里化</h3><p>函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b + c&#125;add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<span class="hljs-keyword">let</span> addCurry = curry(add)addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<span class="hljs-comment">// 现在就是要实现 curry 这个函数</span><span class="hljs-comment">// 使函数从一次调用传入多个参数变成多次调用每次传一个参数。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-keyword">let</span> judge = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (args.length == fn.length) <span class="hljs-keyword">return</span> fn(...args)<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> judge(...args, ...arg)&#125;<span class="hljs-keyword">return</span> judge&#125;<span class="hljs-comment">// 函数柯里化</span><span class="hljs-keyword">const</span> curry = <span class="hljs-function">(<span class="hljs-params">fn, ...args</span>) =&gt;</span>args.length &lt; fn.length<span class="hljs-comment">//参数长度不足时，重新柯里化该函数，等待接受新参数</span>? <span class="hljs-function">(<span class="hljs-params">...<span class="hljs-built_in">arguments</span></span>) =&gt;</span> curry(fn, ...args, ...arguments)<span class="hljs-comment">//参数长度满足时，执行函数</span>: fn(...args);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumFn</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;<span class="hljs-keyword">return</span> a + b + c;&#125;<span class="hljs-keyword">var</span> sum = curry(sumFn);<span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>));<span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">5</span>));<span class="hljs-comment">//10</span></code></pre><h3 id="2-偏函数"><a href="#2-偏函数" class="headerlink" title="2 偏函数"></a>2 偏函数</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 偏函数就是将一个 n 参的函数转换成固定 x 参的函数</span><span class="hljs-comment">// 剩余参数（n - x）将在下次调用全部传入</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b + c&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partial</span>(<span class="hljs-params">fn, ...args</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> fn(...args, ...arg)&#125;&#125;<span class="hljs-keyword">let</span> partialAdd = partial(add, <span class="hljs-number">1</span>)partialAdd(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre><h3 id="3-手写-compose-函数"><a href="#3-手写-compose-函数" class="headerlink" title="3 手写 compose 函数"></a>3 手写 compose 函数</h3><p>compose就是执行一系列的任务（函数），比如有以下任务队列，</p><p><code>let tasks = [step1, step2, step3, step4]</code><br>每一个step都是一个步骤，按照步骤一步一步的执行到结尾，这就是一个compose<br>compose在函数式编程中是一个很重要的工具函数，在这里实现的compose有三点说明</p><p>1 第一个函数是多元的（接受多个参数），后面的函数都是单元的（接受一个参数）<br>2 执行顺序的自右向左的<br>3 所有函数的执行都是同步的（异步的后面文章会讲到）</p><p>例如<br>let init = (…args) =&gt; args.reduce((ele1, ele2) =&gt; ele1 + ele2, 0)<br>let step2 = (val) =&gt; val + 2<br>let step3 = (val) =&gt; val + 3<br>let step4 = (val) =&gt; val + 4</p><p>pipe 函数与 compose函数的共同点是都返回“组合函数”，区别则是执行的顺序不同，前者是从左向右执行，后者则是从右向左执行。 实现 pipe函数非常简单，只需要对 compose 函数的包裹顺序进行调整一下即可。</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 解法一 面向过程</span><span class="hljs-keyword">const</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-keyword">let</span> length = args.length<span class="hljs-keyword">let</span> count = length - <span class="hljs-number">1</span><span class="hljs-keyword">let</span> result<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span> (<span class="hljs-params">...arg1</span>) </span>&#123;result = args[count].apply(<span class="hljs-built_in">this</span>, arg1)<span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;count = length - <span class="hljs-number">1</span><span class="hljs-keyword">return</span> result&#125;count--<span class="hljs-keyword">return</span> f1.call(<span class="hljs-literal">null</span>, result)&#125;&#125;<span class="hljs-comment">// 解法二</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...funcs</span>) </span>&#123;<span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> arg;&#125;<span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">return</span> funcs.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> a(b(...args)));&#125;<span class="hljs-keyword">const</span> compose = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> args.reduceRight(<span class="hljs-function">(<span class="hljs-params">res, cb</span>) =&gt;</span> cb(res), x);<span class="hljs-keyword">const</span> pipe = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">res, cb</span>) =&gt;</span> cb(res), x)<span class="hljs-comment">// 解法三 promise</span><span class="hljs-keyword">const</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-keyword">let</span> init = args.pop()<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>) </span>&#123;<span class="hljs-keyword">return</span> args.reverse().reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sequence, func</span>) </span>&#123;<span class="hljs-keyword">return</span> sequence.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<span class="hljs-keyword">return</span> func.call(<span class="hljs-literal">null</span>, result)&#125;)&#125;, <span class="hljs-built_in">Promise</span>.resolve(init.apply(<span class="hljs-literal">null</span>, arg)))&#125;&#125;<span class="hljs-comment">// 解法三 Generator</span><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">iterateSteps</span>(<span class="hljs-params">steps</span>) </span>&#123;<span class="hljs-keyword">let</span> n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; steps.length; i++) &#123;<span class="hljs-keyword">if</span> (n) &#123;n = <span class="hljs-keyword">yield</span> steps[i].call(<span class="hljs-literal">null</span>, n)&#125; <span class="hljs-keyword">else</span> &#123;n = <span class="hljs-keyword">yield</span>&#125;&#125;&#125;<span class="hljs-keyword">const</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...steps</span>) </span>&#123;<span class="hljs-keyword">let</span> g = iterateSteps(steps)<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-keyword">let</span> val = steps.pop().apply(<span class="hljs-literal">null</span>, args)<span class="hljs-comment">// 这里是第一个值</span><span class="hljs-built_in">console</span>.log(val)<span class="hljs-comment">// 因为无法传参数 所以无所谓执行 就是空耗一个yield</span>g.next()<span class="hljs-keyword">return</span> steps.reverse.reduce(<span class="hljs-function">(<span class="hljs-params">val, val1</span>) =&gt;</span> g.next(val).value, val)  &#125;&#125;<span class="hljs-comment">// 解法四</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> fns = [].slice.call(<span class="hljs-built_in">arguments</span>)<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialArg</span>) </span>&#123;<span class="hljs-keyword">var</span> res = initialArg<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = fns.length - <span class="hljs-number">1</span>; i &gt; -<span class="hljs-number">1</span>; i--) &#123;res = fns[i](res);&#125;<span class="hljs-keyword">return</span> res&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pipe</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fns = [].slice.call(<span class="hljs-built_in">arguments</span>)    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialAgr</span>) </span>&#123;        <span class="hljs-keyword">var</span> res = initialAgr        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; fns.length; i++) &#123;            res = fns[i](res)        &#125;        <span class="hljs-keyword">return</span> res    &#125;&#125;<span class="hljs-keyword">var</span> greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hi:&#x27;</span> + name &#125;<span class="hljs-keyword">var</span> exclaim = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">statement</span>) </span>&#123; <span class="hljs-keyword">return</span> statement.toUpperCase() + <span class="hljs-string">&#x27;!&#x27;</span> &#125;<span class="hljs-keyword">var</span> transform = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123; <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/[dD]/</span>, <span class="hljs-string">&#x27;DDDDD&#x27;</span>) &#125;<span class="hljs-keyword">var</span> welcome1 = compose(greet, exclaim, transform)<span class="hljs-keyword">var</span> welcome2 = pipe(greet, exclaim, transform)<span class="hljs-built_in">console</span>.log(welcome1(<span class="hljs-string">&#x27;dot&#x27;</span>))<span class="hljs-comment">//hi:DDDDDOT!</span><span class="hljs-built_in">console</span>.log(welcome2(<span class="hljs-string">&#x27;dolb&#x27;</span>))<span class="hljs-comment">//HI:DDDDDOLB!</span></code></pre><h3 id="4-手写-LRU-函数"><a href="#4-手写-LRU-函数" class="headerlink" title="4 手写 LRU 函数"></a>4 手写 LRU 函数</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><p>1 LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>2 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>3 void put(int key, int value) 如果关键字已经存在，则变更其数据值；<br>    如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，<br>    它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><pre><code class="hljs text">输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">capacity</span></span></span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">capacity</span>)</span> &#123;<span class="hljs-built_in">this</span>.capacity = capacity<span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();&#125;<span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key</span>)</span> &#123;<span class="hljs-keyword">let</span> val = <span class="hljs-built_in">this</span>.map.get(key);<span class="hljs-keyword">if</span> (val === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-built_in">this</span>.map.delete(key); <span class="hljs-comment">// 因为被用过一次，原有位置删除</span><span class="hljs-built_in">this</span>.map.set(key, val); <span class="hljs-comment">// 放入最下面表示最新使用</span><span class="hljs-keyword">return</span> val;&#125;<span class="hljs-function"><span class="hljs-title">put</span>(<span class="hljs-params">key, val</span>)</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.map.has(key)) <span class="hljs-built_in">this</span>.map.delete(key); <span class="hljs-comment">// 如果有，删除</span><span class="hljs-built_in">this</span>.map.set(key, val); <span class="hljs-comment">// 放到最下面表示最新使用</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.map.size &gt; <span class="hljs-built_in">this</span>.capacity) &#123;<span class="hljs-comment">// 这里有个知识点</span><span class="hljs-comment">// map的entries方法，还有keys方法(可以看mdn))，会返回一个迭代器</span><span class="hljs-comment">// 迭代器调用next也是顺序返回，所以返回第一个的值就是最老的，找到并删除即可</span><span class="hljs-built_in">this</span>.map.delete(<span class="hljs-built_in">this</span>.map.entries().next().value[<span class="hljs-number">0</span>])&#125;&#125;&#125;</code></pre><h3 id="5-loadsh-gt-get"><a href="#5-loadsh-gt-get" class="headerlink" title="5 loadsh -&gt; get"></a>5 loadsh -&gt; get</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 题目描述</span><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">selector</span>: &#123; <span class="hljs-attr">to</span>: &#123; <span class="hljs-attr">toutiao</span>: <span class="hljs-string">&#x27;FE coder&#x27;</span> &#125; &#125;,<span class="hljs-attr">target</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;byted&#x27;</span> &#125;] &#125;;<span class="hljs-comment">// 运行代码</span><span class="hljs-keyword">var</span> res = getValsByKeys(obj, <span class="hljs-string">&#x27;selector.to.toutiao&#x27;</span>, <span class="hljs-string">&#x27;selector.feishu.toutiao&#x27;</span>, <span class="hljs-string">&#x27;target[0]&#x27;</span>, <span class="hljs-string">&#x27;target[2].name&#x27;</span>, <span class="hljs-string">&#x27;select.to.douyin&#x27;</span>)<span class="hljs-built_in">console</span>.log(res);<span class="hljs-comment">//  输出结果</span><span class="hljs-comment">// [&#x27;FE coder&#x27;, &#x27;&#x27;,  1, &#x27;byted&#x27;, &#x27;&#x27;]</span><span class="hljs-comment">// 解答：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValsByKeys</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;arguments error&#x27;</span>);&#125;<span class="hljs-keyword">const</span> [obj, ...args] = [...arguments];<span class="hljs-keyword">const</span> res = [];args.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;key = key.replaceAll(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>).replaceAll(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);res.push(getValByKey(obj, key));&#125;);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValByKey</span>(<span class="hljs-params">obj, key</span>) </span>&#123;<span class="hljs-keyword">const</span> arr = key.split(<span class="hljs-string">&#x27;.&#x27;</span>);<span class="hljs-keyword">if</span> (arr.length &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> obj[arr[<span class="hljs-number">0</span>]] ? getValByKey(obj[arr[<span class="hljs-number">0</span>]], arr.slice(<span class="hljs-number">1</span>).join(<span class="hljs-string">&#x27;.&#x27;</span>)) : <span class="hljs-string">&#x27;&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> obj[key] ? obj[key] : <span class="hljs-string">&#x27;&#x27;</span>;&#125;&#125;</code></pre><h3 id="6-sleep函数"><a href="#6-sleep函数" class="headerlink" title="6 sleep函数"></a>6 sleep函数</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">delay</span>) </span>&#123;<span class="hljs-keyword">var</span> start = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime();<span class="hljs-keyword">while</span> ((<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime() - start &lt; delay) &#123;<span class="hljs-keyword">continue</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;111&#x27;</span>);  sleep(<span class="hljs-number">2000</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;222&#x27;</span>);&#125;test()</code></pre><h3 id="7-数组随机打乱"><a href="#7-数组随机打乱" class="headerlink" title="7 数组随机打乱"></a>7 数组随机打乱</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randArr</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;type error&#x27;</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<span class="hljs-keyword">const</span> randIndex = <span class="hljs-built_in">Math</span>.floor(arr.length * <span class="hljs-built_in">Math</span>.random());<span class="hljs-keyword">if</span> (i !== randIndex) &#123;[arr[i], arr[randIndex]] = [arr[randIndex], arr[i]];&#125;&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre><h3 id="8-数组扁平化"><a href="#8-数组扁平化" class="headerlink" title="8 数组扁平化"></a>8 数组扁平化</h3><p>ES6 为数组实例新增了 flat 方法 用于将数组扁平化。<br><code>var newArray = arr.flat(Infinity)</code></p><pre><code class="hljs javaScript"><span class="hljs-comment">// 手动实现 一个 flat函数：</span><span class="hljs-comment">// 方式一: ES6 递归 —— reduce</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatArray</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, val</span>) =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(val) ? acc.concat(flatArray(val)) : acc.concat(val), [])&#125;<span class="hljs-comment">// 方式二: 利用栈(stack) </span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatArray</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">const</span> stack = [...arr];<span class="hljs-keyword">const</span> newArr = [];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(item)) &#123;stack.push(...item);&#125; <span class="hljs-keyword">else</span> &#123;newArr.unshift(item);&#125;&#125;<span class="hljs-keyword">return</span> newArr;&#125;<span class="hljs-comment">// 方法三: ES5 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatArray</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">var</span> result = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arr[i])) &#123;result = result.concat(flatArray(arr[i]))<span class="hljs-comment">// result = [...result, ...flatArray(arr[i])];</span>&#125; <span class="hljs-keyword">else</span> &#123;result.push(arr[i])&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;</code></pre><h3 id="9-Array-fill"><a href="#9-Array-fill" class="headerlink" title="9 Array.fill"></a>9 Array.fill</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// arr.fill(value [,start [,end]])</span><span class="hljs-built_in">Array</span>.prototype.myFill = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, start = <span class="hljs-number">0</span>, end = <span class="hljs-built_in">this</span>.length</span>)</span>&#123;<span class="hljs-keyword">if</span> (start &lt; end) &#123;<span class="hljs-built_in">this</span>[start] = val;<span class="hljs-built_in">this</span>.myFill(val, start + <span class="hljs-number">1</span>, end)&#125;&#125;<span class="hljs-built_in">Array</span>.prototype.myFill2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, start = <span class="hljs-number">0</span>, end = <span class="hljs-built_in">this</span>.length</span>) </span>&#123;<span class="hljs-keyword">while</span> (start &lt; end) &#123;<span class="hljs-built_in">this</span>[start] = val;start++;&#125;&#125;</code></pre><h3 id="10-Array-map"><a href="#10-Array-map" class="headerlink" title="10 Array.map"></a>10 Array.map</h3><p>核心要点:<br>1.回调函数的参数有哪些，返回值如何处理。<br>2.不修改原来的数组。</p><pre><code class="hljs javaScript"><span class="hljs-comment">/*</span><span class="hljs-comment">var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123;</span><span class="hljs-comment">Return element for new_array </span><span class="hljs-comment">&#125;[, thisArg])</span><span class="hljs-comment">callback - 生成新数组元素的函数，使用三个参数 currentValue, index(可选), array(可选)</span><span class="hljs-comment">thisArg - 执行 callback 函数时值被用作this</span><span class="hljs-comment">*/</span><span class="hljs-built_in">Array</span>.prototype.MyMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, thisArg</span>)</span>&#123;<span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//由于是ES5所以就不用...展开符了</span><span class="hljs-keyword">var</span> mappedArr = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++ )&#123;mappedArr.push(fn.call(thisArg, arr[i], i, <span class="hljs-built_in">this</span>));&#125;<span class="hljs-keyword">return</span> mappedArr;&#125;</code></pre><h3 id="11-Array-reduce"><a href="#11-Array-reduce" class="headerlink" title="11 Array.reduce"></a>11 Array.reduce</h3><p>核心要点:<br>1、初始值不传怎么处理<br>2、回调函数的参数有哪些，返回值如何处理。</p><pre><code class="hljs javaScript"><span class="hljs-comment">// arr.reduce(callback(accumulator, currentValue [,index [,array]])  [,initialValue])</span><span class="hljs-comment">// 简单版本</span><span class="hljs-built_in">Array</span>.prototype.myReduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, initialValue</span>) </span>&#123;<span class="hljs-comment">// 判断调用对象是否为数组</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">this</span>) !== <span class="hljs-string">&#x27;[object Array]&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;not a array&#x27;</span>);&#125;<span class="hljs-comment">// 判断传入的第一个参数是否为函数</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;fn&#125;</span> is not a function`</span>);&#125;<span class="hljs-comment">// 判断调用数组是否为空数组</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (initialValue) &#123;<span class="hljs-keyword">return</span> initialValue;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;empty array&#x27;</span>);&#125;&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">this</span>);<span class="hljs-keyword">const</span> startIndex = initialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> res = initialValue ? initialValue : arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = startIndex; i &lt; arr.length; i++) &#123;res = fn.call(<span class="hljs-literal">null</span>, res, arr[i], i, <span class="hljs-built_in">this</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-built_in">Array</span>.prototype.myReduceRight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, initialValue</span>) </span>&#123;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">this</span>);<span class="hljs-keyword">let</span> startIndex = initialValue ? arr.length - <span class="hljs-number">1</span> : arr.length - <span class="hljs-number">2</span>;<span class="hljs-keyword">let</span> res = initialValue ? initialValue : arr[arr.length - <span class="hljs-number">1</span>];<span class="hljs-keyword">while</span>(startIndex &gt; -<span class="hljs-number">1</span>) &#123;res = fn.call(<span class="hljs-literal">null</span>, res, arr[startIndex], startIndex, <span class="hljs-built_in">this</span>);startIndex--;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 完美版本</span><span class="hljs-comment">// 思路</span><span class="hljs-comment">// 1 常规判断 这里我们主要要判断的是调用数组、传入参数</span><span class="hljs-comment">// 2 初始化各个变量，为第一次执行函数做准备</span><span class="hljs-comment">// 这里我们需要准备的变量有需要传入回调函数的4个参数</span><span class="hljs-comment">// callback的4个参数: accumulator, currentValue, currentIndex, sourceArray</span><span class="hljs-comment">// accumulator: 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue</span><span class="hljs-comment">// currentValue: 数组中正在处理的元素</span><span class="hljs-comment">//currentIndex(可选): 数组中正在处理的当前元素的索引.如果提供了initialValue，则起始索引号为0，否则从索引1起始</span><span class="hljs-comment">//sourceArray(可选): 调用reduce()的数组</span><span class="hljs-comment">//initialValue(可选): 作为第一次调用 callback函数时的第一个参数的值.如果没有提供初始值，则将使用数组中的第一个元素.在没有初始值的空数组上调用 reduce 将报错</span><span class="hljs-comment">// 3 开始循环 同时记得更新几个参数和返回结果</span><span class="hljs-comment">// 4 返回结果</span><span class="hljs-built_in">Array</span>.prototype.myreduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, initialValue</span>) </span>&#123;<span class="hljs-comment">// 判断调用对象是否为数组</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">this</span>) !== <span class="hljs-string">&#x27;[object Array]&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;not a array&#x27;</span>);&#125;<span class="hljs-comment">// 判断调用数组是否为空数组</span><span class="hljs-keyword">const</span> sourceArray = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">if</span> (sourceArray.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;empty array&#x27;</span>);&#125;<span class="hljs-comment">// 判断传入的第一个参数是否为函数</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;fn&#125;</span> is not a function`</span>);&#125;<span class="hljs-comment">// 第二步 回调函数参数初始化</span><span class="hljs-keyword">let</span> accumulator;<span class="hljs-keyword">let</span> currentValue;<span class="hljs-keyword">let</span> currentIndex;<span class="hljs-keyword">if</span> (initialValue) &#123;accumulator = initialValue;currentIndex = <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> &#123;accumulator = arr[<span class="hljs-number">0</span>];currentIndex = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 第三步 开始循环</span><span class="hljs-keyword">while</span> (currentIndex &lt; sourceArray.length) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(sourceArray, currentIndex)) &#123;currentValue = sourceArray[currentIndex];accumulator = fn(accumulator, currentValue, currentIndex, sourceArray);&#125;currentIndex++;&#125;<span class="hljs-comment">// 第四步 返回结果</span><span class="hljs-keyword">return</span> accumulator;&#125;<span class="hljs-comment">// test</span><span class="hljs-keyword">const</span> rReduce = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, , <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">3</span>)<span class="hljs-keyword">const</span> mReduce = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, , <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].myreduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(rReduce); <span class="hljs-comment">// 31nullundefined34</span><span class="hljs-built_in">console</span>.log(mReduce); <span class="hljs-comment">// 31nullundefined34</span></code></pre><h3 id="12-Array-forEach"><a href="#12-Array-forEach" class="headerlink" title="12 Array.forEach"></a>12 Array.forEach</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// arr.forEach(callback(currentValue [,index [,array]])  [,thisArg])</span><span class="hljs-built_in">Array</span>.prototype.forEach2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;this is null or not defined&#x27;</span>)&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&#x27; is not a function&#x27;</span>)&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// this 就是当前的数组</span><span class="hljs-keyword">const</span> len = arr.length &gt;&gt;&gt; <span class="hljs-number">0</span>  <span class="hljs-comment">// 后面有解释(非number 转成 number 类型)</span><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> (index &lt; len) &#123;<span class="hljs-keyword">if</span> (index <span class="hljs-keyword">in</span> arr) &#123;callback.call(thisArg, arr[index], index, arr);&#125;index++;&#125;&#125;<span class="hljs-comment">// O.length &gt;&gt;&gt; 0 是什么操作？就是无符号右移 0 位</span><span class="hljs-comment">/// 就是为了保证转换后的值为正整数。其实底层做了 2 层转换</span><span class="hljs-comment">// 第一是非 number 转成 number 类型</span><span class="hljs-comment">// 第二是将 number 转成 Uint32 类型。</span><span class="hljs-comment">// &gt;&gt;&gt; 1 : 无符号右移 1 位，意思是 除二取整</span></code></pre><h3 id="13-Array-filter"><a href="#13-Array-filter" class="headerlink" title="13 Array.filter"></a>13 Array.filter</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// var newArray = arr.filter(callback(element [,index [,array]])  [,thisArg])</span><span class="hljs-built_in">Array</span>.prototype.filter2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;this is null or not defined&#x27;</span>)&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&#x27; is not a function&#x27;</span>)&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>)<span class="hljs-keyword">const</span> len = arr.length &gt;&gt;&gt; <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">while</span> (index &lt; len) &#123;<span class="hljs-keyword">if</span> (index <span class="hljs-keyword">in</span> arr) &#123;<span class="hljs-keyword">if</span> (callback.call(thisArg, arr[index], index, arr)) &#123;res.push(arr[index])                &#125;&#125;index++;&#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="14-Array-some"><a href="#14-Array-some" class="headerlink" title="14 Array.some"></a>14 Array.some</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// arr.some(callback(element [,index [,array]]) [,thisArg])</span><span class="hljs-built_in">Array</span>.prototype.some2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;this is null or not defined&#x27;</span>)&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&#x27; is not a function&#x27;</span>)&#125;<span class="hljs-keyword">const</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>)<span class="hljs-keyword">const</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span><span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> (k &lt; len) &#123;<span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) &#123;<span class="hljs-keyword">if</span> (callback.call(thisArg, O[k], k, O)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;&#125;k++;&#125;   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h3 id="15-两数相加"><a href="#15-两数相加" class="headerlink" title="15 两数相加"></a>15 两数相加</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 考虑 正负数的情况</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preciseAdd</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;arguments is error&#x27;</span>);&#125;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> s1 = str1.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">let</span> s2 = str2.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">if</span> ((str1.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; !str2.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>)) || (!str1.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; str2.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>))) &#123;<span class="hljs-comment">// 一正一负</span><span class="hljs-keyword">const</span> str1LessZero = str1.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">// 表示前面数字是负数，后面是正数</span><span class="hljs-keyword">if</span> (str1LessZero) &#123;s1.shift();&#125; <span class="hljs-keyword">else</span> &#123;s2.shift();&#125;<span class="hljs-comment">// 判断两个数字大小</span><span class="hljs-keyword">let</span> s1LagerS2 = s1.length &gt; s2.length;<span class="hljs-keyword">if</span> (s1.length === s2.length) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; s1.length; i++) &#123;<span class="hljs-keyword">if</span>(s1[i] === s2[i]) <span class="hljs-keyword">continue</span>;s1LagerS2 = s1[i] &gt; s2[i];<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">// 如果 s1 比 s2 小，则互换</span><span class="hljs-keyword">if</span> (!s1LagerS2) &#123;<span class="hljs-comment">// s1 = [s2, s2 = s1][0] // 快速互换</span><span class="hljs-keyword">const</span> tem = [...s1];s1 = [...s2];s2 = [...tem];&#125;<span class="hljs-keyword">while</span>(s1.length) &#123;<span class="hljs-keyword">const</span> val = ~~s1.pop() - ~~s2.pop();<span class="hljs-keyword">if</span> (val &gt;= <span class="hljs-number">0</span>) &#123;res = val + res;&#125; <span class="hljs-keyword">else</span> &#123;res = val + <span class="hljs-number">10</span> + res;<span class="hljs-comment">// 不够减，需要把前一个值减一</span>s1[s1.length - <span class="hljs-number">1</span>]--;&#125;&#125;res = res.replace(<span class="hljs-regexp">/^0*/g</span>, <span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// 去掉前面的无效0</span><span class="hljs-comment">// (前正后负，前比后小) || (前负后正，前比后大)</span>res = (str1LessZero &amp;&amp; s1LagerS2) || (!str1LessZero &amp;&amp; !s1LagerS2) ? <span class="hljs-string">&#x27;-&#x27;</span> + res : res;<span class="hljs-comment">// 如果 两数相等，则 res = &#x27;&#x27;或者 res = &#x27;-&#x27;</span><span class="hljs-keyword">if</span>(res === <span class="hljs-string">&#x27;-&#x27;</span> || !res) &#123;res = <span class="hljs-string">&#x27;0&#x27;</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 两正数 或者 两负数</span><span class="hljs-comment">// 两个负数</span><span class="hljs-keyword">const</span> twoF = str1.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; str2.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>);<span class="hljs-keyword">if</span> (twoF) &#123;s1.shift();s2.shift();&#125;<span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (s1.length || s2.length || carry) &#123;<span class="hljs-keyword">const</span> val = ~~s1.pop() + ~~s2.pop() + carry;res = val % <span class="hljs-number">10</span> + res;carry = <span class="hljs-built_in">Math</span>.floor(val / <span class="hljs-number">10</span>);&#125;res = twoF ? <span class="hljs-string">&#x27;-&#x27;</span> + res : res;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 简易版 只考虑正数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preciseAdd</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;arguments is error&#x27;</span>);&#125;<span class="hljs-keyword">const</span> arr1 = str1.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">const</span> arr2 = str2.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(arr1.length || arr2.length || carry) &#123;<span class="hljs-keyword">const</span> val = ~~arr1.pop() + ~~arr2.pop() + carry;res = val % <span class="hljs-number">10</span> + res;carry = <span class="hljs-built_in">Math</span>.floor(val / <span class="hljs-number">10</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="16-两数相减"><a href="#16-两数相减" class="headerlink" title="16 两数相减"></a>16 两数相减</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minus</span>(<span class="hljs-params">a, b</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> arr1 = a.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">let</span> arr2 = b.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-comment">// 判断 a 和 b 的大小</span><span class="hljs-keyword">let</span> aLagerB = arr1.length &gt; arr2.length;<span class="hljs-keyword">if</span> (arr1.length === arr2.length) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<span class="hljs-keyword">if</span>(arr1[i] === arr2[i]) &#123;<span class="hljs-keyword">continue</span>;&#125;aLagerB = arr1[i] &gt; arr2[i];<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">// 如果 a 比 b 小，则互换位置</span><span class="hljs-keyword">if</span> (!aLagerB) &#123;<span class="hljs-comment">// arr1 = [arr2, arr2 = arr1][0]</span><span class="hljs-keyword">const</span> tem = arr1;arr1 = arr2;arr2 = tem;&#125;<span class="hljs-keyword">while</span> (arr1.length) &#123;<span class="hljs-keyword">const</span> val = ~~arr1.pop() - ~~arr2.pop();<span class="hljs-keyword">if</span> (val &gt;= <span class="hljs-number">0</span>) &#123;res = val + res;&#125; <span class="hljs-keyword">else</span> &#123;res = val + <span class="hljs-number">10</span> + res;arr1[arr1.length - <span class="hljs-number">1</span>]--;&#125;&#125;res = res.replace(<span class="hljs-regexp">/^0*/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);res = !aLagerB ? <span class="hljs-string">&#x27;-&#x27;</span>  + res : res;<span class="hljs-comment">// 如果出现两数相等，则 res = &#x27;-&#x27;</span>res = res === <span class="hljs-string">&#x27;-&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : res;<span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="17-两数相乘"><a href="#17-两数相乘" class="headerlink" title="17 两数相乘"></a>17 两数相乘</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 普通乘法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cheng</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> s1 = ~~str1;<span class="hljs-keyword">const</span> s2 = ~~str2;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s2; i++) &#123;res += s1;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 大数相乘 a b 都是字符串</span><span class="hljs-keyword">var</span> multiply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<span class="hljs-keyword">if</span> (num1 === <span class="hljs-string">&#x27;0&#x27;</span> || num2 === <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(num1.length + num2.length).fill(<span class="hljs-number">0</span>);<span class="hljs-comment">// 得到乘积的数组</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num1.length; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; num2.length; j++) &#123;arr[i + j + <span class="hljs-number">1</span>] += ~~num1[i] * ~~num2[j];&#125;&#125;<span class="hljs-comment">// 处理进位</span><span class="hljs-keyword">let</span> i = arr.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">const</span> carry = <span class="hljs-built_in">Math</span>.trunc(arr[i] / <span class="hljs-number">10</span>);<span class="hljs-keyword">if</span> (carry) &#123;arr[i - <span class="hljs-number">1</span>] += carry;&#125;arr[i] = arr[i] % <span class="hljs-number">10</span>;i--;&#125;<span class="hljs-comment">// 去掉前面多余的0</span><span class="hljs-keyword">while</span>(arr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;arr.shift();&#125;<span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;;</code></pre><h3 id="18-两数相除"><a href="#18-两数相除" class="headerlink" title="18 两数相除"></a>18 两数相除</h3><p>给定两个整数，被除数 dividend和除数divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>返回被除数 dividend 除以除数divisor 得到的商。</p><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> divide = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dividend, divisor</span>) </span>&#123;<span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> flag = (dividend &gt; <span class="hljs-number">0</span> &amp;&amp; divisor &gt; <span class="hljs-number">0</span>) || (dividend &lt; <span class="hljs-number">0</span> &amp;&amp; divisor &lt; <span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> mul = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Math</span>.abs(dividend);<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Math</span>.abs(divisor);<span class="hljs-keyword">let</span> s3 = s2;<span class="hljs-keyword">while</span> (s1 &gt;= s3) &#123;<span class="hljs-keyword">if</span> (s1 &gt; (s3 + s3)) &#123;s3 += s3;mul += mul;&#125;s1 -= s3;result += mul;&#125;<span class="hljs-keyword">while</span> (s1 &gt;= s2) &#123;s1 -= s2;result += <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (flag &amp;&amp; result &gt; (<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) - <span class="hljs-number">1</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!flag &amp;&amp; result &lt; -<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>)) &#123;<span class="hljs-keyword">return</span> -<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>);&#125;<span class="hljs-keyword">return</span> !flag ? -result : result;&#125;;</code></pre><h3 id="19-Math-pow"><a href="#19-Math-pow" class="headerlink" title="19 Math.pow()"></a>19 Math.pow()</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 解法一: 迭代</span><span class="hljs-comment">// res 变量的值由 奇次or偶次幂 决定，如果是奇次幂，res 值为 num，反之，为1</span><span class="hljs-comment">// res 最后乘上累乘后的 num，返回</span><span class="hljs-keyword">var</span> myPow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num, power</span>) </span>&#123;<span class="hljs-keyword">if</span> (power &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / num * myPow(<span class="hljs-number">1</span> / num, -(power + <span class="hljs-number">1</span>));<span class="hljs-keyword">if</span> (power === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (power === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> num;<span class="hljs-comment">// 以上分别为power小于0 等于0 等于1 的情况</span><span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span><span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// power大于1</span><span class="hljs-keyword">if</span> (power % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;res = res * num;power--;&#125;num = num * num;power = power / <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">return</span> res * num;&#125;;<span class="hljs-comment">// 解法二: 递归</span><span class="hljs-comment">// 递归版似乎更好理解一些，奇次幂的话，幂次-1，转成偶次幂</span><span class="hljs-comment">// 只需要写好偶次幂下的调用就好：myPow(num * num, power / 2)</span><span class="hljs-keyword">var</span> myPow = <span class="hljs-function">(<span class="hljs-params">num, power</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (power &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (num * myPow(num, -(power + <span class="hljs-number">1</span>)));<span class="hljs-keyword">if</span> (power === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (power === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> num;<span class="hljs-keyword">return</span> power % <span class="hljs-number">2</span> === <span class="hljs-number">1</span> ?num * myPow(num, power - <span class="hljs-number">1</span>) :myPow(num * num, power / <span class="hljs-number">2</span>);&#125;</code></pre><h2 id="六-开放题"><a href="#六-开放题" class="headerlink" title="六 开放题"></a>六 开放题</h2><p>1 实现一个简单路由<br>2 手写时钟<br>3 手写红绿灯</p><h3 id="1-实现一个简单路由"><a href="#1-实现一个简单路由" class="headerlink" title="1 实现一个简单路由"></a>1 实现一个简单路由</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// hash路由</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span></span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">// 路由存储对象</span><span class="hljs-built_in">this</span>.routes = &#123;&#125;;<span class="hljs-comment">// 当前hash</span><span class="hljs-built_in">this</span>.currentHash = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">// 绑定this，避免监听时this指向改变</span><span class="hljs-built_in">this</span>.freshRoute = <span class="hljs-built_in">this</span>.freshRoute.bind(<span class="hljs-built_in">this</span>);<span class="hljs-comment">// 监听</span><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-built_in">this</span>.freshRoute, <span class="hljs-literal">false</span>);<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-built_in">this</span>.freshRoute, <span class="hljs-literal">false</span>);&#125;<span class="hljs-comment">// 存储</span>storeRoute (path, cb) &#123;<span class="hljs-built_in">this</span>.routes[path] = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;&#125;<span class="hljs-comment">// 更新</span>freshRoute () &#123;<span class="hljs-built_in">this</span>.currentHash = location.hash.slice(<span class="hljs-number">1</span>) || <span class="hljs-string">&#x27;/&#x27;</span>;<span class="hljs-built_in">this</span>.routes[<span class="hljs-built_in">this</span>.currentHash]();&#125;&#125;</code></pre><h3 id="2-手写时钟"><a href="#2-手写时钟" class="headerlink" title="2 手写时钟"></a>2 手写时钟</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><span class="css">*&#123;</span><span class="css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.warp</span>&#123;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">230px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">230px</span>;</span><span class="css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span> auto;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.clock</span>&#123;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">115px</span>;</span><span class="css"><span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid <span class="hljs-number">#ccc</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;</span><span class="css"><span class="hljs-attribute">position</span>: relative;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.number</span> <span class="hljs-selector-tag">div</span>&#123;</span><span class="css"><span class="hljs-attribute">position</span>: absolute;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="css"><span class="hljs-attribute">left</span>: <span class="hljs-number">90px</span>;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.number</span> <span class="hljs-selector-tag">span</span>&#123;</span><span class="css"><span class="hljs-attribute">display</span>: block;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;</span><span class="css"><span class="hljs-attribute">text-align</span>: center;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.pointer</span>&#123;</span><span class="css"><span class="hljs-attribute">position</span>: absolute;</span><span class="css"><span class="hljs-attribute">bottom</span>: <span class="hljs-number">90px</span>;</span><span class="css"><span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">50%</span> <span class="hljs-number">90%</span>;</span><span class="css">-webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">50%</span> <span class="hljs-number">90%</span>;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.houre</span>&#123;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">4px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;</span><span class="css"><span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#000</span>;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.minute</span>&#123;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">2px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;</span><span class="css"><span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#777</span>;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.second</span>&#123;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">1px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">90px</span>;</span><span class="css"><span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#ff0000</span>;</span><span class="css">&#125;</span><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">var</span> domNumber = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;number&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domDiv = domNumber.getElementsByTagName(<span class="hljs-string">&quot;div&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domSpan = domNumber.getElementsByTagName(<span class="hljs-string">&quot;span&quot;</span>);</span><span class="javascript"></span><span class="javascript"><span class="hljs-comment">// 布局 =&gt; 让数字旋转到相应的位置并调整方向</span></span><span class="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; domDiv.length; i++)&#123;</span><span class="javascript">domDiv[i].style.WebkitTransform=<span class="hljs-string">&quot;rotate(&quot;</span> + (i + <span class="hljs-number">1</span>) * <span class="hljs-number">30</span> + <span class="hljs-string">&quot;deg)&quot;</span>;</span><span class="javascript">&#125;</span><span class="javascript"></span><span class="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; domSpan.length; j++)&#123;</span><span class="javascript">domSpan[j].style.WebkitTransform=<span class="hljs-string">&quot;rotate(&quot;</span>+ (j + <span class="hljs-number">1</span>) * -<span class="hljs-number">30</span> + <span class="hljs-string">&quot;deg)&quot;</span>;</span><span class="javascript">&#125;</span><span class="javascript"></span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clockRun</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> domHour = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;houre&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domMinute = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;minute&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domSecond = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;second&quot;</span>);</span><span class="javascript"></span><span class="javascript"><span class="hljs-keyword">var</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><span class="javascript"><span class="hljs-keyword">var</span> nowHour = nowTime.getHours();</span><span class="javascript"><span class="hljs-keyword">var</span> nowMinute = nowTime.getMinutes();</span><span class="javascript"><span class="hljs-keyword">var</span> nowSecond = nowTime.getSeconds();</span><span class="javascript"></span><span class="javascript"><span class="hljs-comment">// 计算指针的角度，其中最重要的是在不满一小时或不满一分钟时，时针或分针应该转多少度</span></span><span class="javascript"><span class="hljs-keyword">var</span> houreDeg = (nowMinute/<span class="hljs-number">60</span>) * <span class="hljs-number">30</span>; <span class="hljs-comment">// 每小时是30度(1h = 60min, 1h =&gt;  360°/12h = 30 °/h)</span></span><span class="javascript"><span class="hljs-keyword">var</span> minuteDeg = (nowSecond/<span class="hljs-number">60</span>) * <span class="hljs-number">6</span>; <span class="hljs-comment">// 每分钟是6度(1min = 60sec, 1min =&gt; 360°/60min = 6 °/h)</span></span><span class="javascript"></span><span class="javascript">domHour.style.WebkitTransform = <span class="hljs-string">&quot;rotate(&quot;</span> + (nowHour * <span class="hljs-number">30</span> + houreDeg) + <span class="hljs-string">&quot;deg)&quot;</span>;</span><span class="javascript">domMinute.style.WebkitTransform = <span class="hljs-string">&quot;rotate(&quot;</span> + (nowMinute * <span class="hljs-number">6</span> + minuteDeg) + <span class="hljs-string">&quot;deg)&quot;</span>;</span><span class="javascript">domSecond.style.WebkitTransform = <span class="hljs-string">&quot;rotate(&quot;</span> + (nowSecond * <span class="hljs-number">6</span>) + <span class="hljs-string">&quot;deg)&quot;</span>;</span><span class="javascript">&#125;</span><span class="javascript">clockRun();</span><span class="javascript"><span class="hljs-built_in">setInterval</span>(clockRun, <span class="hljs-number">1000</span>);</span><span class="javascript">&#125;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;warp&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clock&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;number&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>12<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;houre&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pointer houre&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;minute&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pointer minute&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;second&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pointer second&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="3-手写红绿灯"><a href="#3-手写红绿灯" class="headerlink" title="3 手写红绿灯"></a>3 手写红绿灯</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><span class="css"><span class="hljs-selector-class">.light-content</span> &#123;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><span class="css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#666</span>;</span><span class="css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#f7f7f7</span>;</span><span class="css"><span class="hljs-attribute">display</span>: flex;</span><span class="css"><span class="hljs-attribute">justify-content</span>: space-around;</span><span class="css"><span class="hljs-attribute">align-items</span>: center;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-id">#red-light</span>, <span class="hljs-selector-id">#yellow-light</span>, <span class="hljs-selector-id">#green-light</span> &#123;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>;</span><span class="css"><span class="hljs-attribute">display</span>: flex;</span><span class="css"><span class="hljs-attribute">align-items</span>: center;</span><span class="css"><span class="hljs-attribute">justify-content</span>: center;</span><span class="css"><span class="hljs-attribute">font-size</span>: <span class="hljs-number">35px</span>;</span><span class="css">&#125;</span><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">let</span> red = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;red-light&#x27;</span>);</span><span class="javascript"><span class="hljs-keyword">let</span> yellow= <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;yellow-light&#x27;</span>);</span><span class="javascript"><span class="hljs-keyword">let</span> green = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;green-light&#x27;</span>);</span><span class="javascript"></span><span class="javascript"><span class="hljs-keyword">let</span> colorsChange = <span class="hljs-function">(<span class="hljs-params">color, duration</span>) =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">if</span>(color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 设置灯的颜色变化</span></span><span class="javascript">red.style.background = color;</span><span class="javascript">green.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript">yellow.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 设置倒计时</span></span><span class="javascript">green.innerText = <span class="hljs-number">0</span>;</span><span class="javascript">yellow.innerText = <span class="hljs-number">0</span>;</span><span class="javascript"><span class="hljs-keyword">let</span> timeOut = duration;</span><span class="javascript">red.innerText = timeOut / <span class="hljs-number">1000</span>;</span><span class="javascript"><span class="hljs-keyword">let</span> times = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">red.innerText = (timeOut - <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>;</span><span class="javascript">timeOut -= <span class="hljs-number">1000</span>;</span><span class="javascript"><span class="hljs-keyword">if</span> (timeOut === <span class="hljs-number">0</span>) &#123;</span><span class="javascript"><span class="hljs-built_in">clearInterval</span>(times);</span><span class="javascript">&#125;</span><span class="javascript">&#125;, <span class="hljs-number">1000</span>);</span><span class="javascript">&#125;</span><span class="javascript"><span class="hljs-keyword">if</span>(color === <span class="hljs-string">&#x27;yellow&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 设置灯的颜色变化</span></span><span class="javascript">yellow.style.background = color;</span><span class="javascript">green.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript">red.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 设置倒计时</span></span><span class="javascript">red.innerText = <span class="hljs-number">0</span>;</span><span class="javascript">green.innerText = <span class="hljs-number">0</span>;</span><span class="javascript"><span class="hljs-keyword">let</span> timeOut = duration;</span><span class="javascript">yellow.innerText = timeOut / <span class="hljs-number">1000</span>;</span><span class="javascript"><span class="hljs-keyword">let</span> times = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">yellow.innerText = (timeOut - <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>;</span><span class="javascript">timeOut -= <span class="hljs-number">1000</span>;</span><span class="javascript"><span class="hljs-keyword">if</span> (timeOut === <span class="hljs-number">0</span>) &#123;</span><span class="javascript"><span class="hljs-built_in">clearInterval</span>(times);</span><span class="javascript">&#125;</span><span class="javascript">&#125;, <span class="hljs-number">1000</span>);</span><span class="javascript">&#125;</span><span class="javascript"><span class="hljs-keyword">if</span>(color === <span class="hljs-string">&#x27;green&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 设置灯的颜色变化</span></span><span class="javascript">green.style.background = color;</span><span class="javascript">red.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript">yellow.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 设置倒计时</span></span><span class="javascript">yellow.innerText = <span class="hljs-number">0</span>;</span><span class="javascript">red.innerText = <span class="hljs-number">0</span>;</span><span class="javascript"><span class="hljs-keyword">let</span> timeOut = duration;</span><span class="javascript">green.innerText = timeOut / <span class="hljs-number">1000</span>;</span><span class="javascript"><span class="hljs-keyword">let</span> times = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">green.innerText = (timeOut - <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>;</span><span class="javascript">timeOut -= <span class="hljs-number">1000</span>;</span><span class="javascript"><span class="hljs-keyword">if</span> (timeOut === <span class="hljs-number">0</span>) &#123;</span><span class="javascript"><span class="hljs-built_in">clearInterval</span>(times);</span><span class="javascript">&#125;</span><span class="javascript">&#125;, <span class="hljs-number">1000</span>);</span><span class="javascript">&#125;</span><span class="javascript">&#125;;</span><span class="javascript"></span><span class="javascript"><span class="hljs-keyword">let</span> setColor = <span class="hljs-function">(<span class="hljs-params">color, duration</span>) =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res,rej</span>) =&gt;</span> &#123;</span><span class="javascript">colorsChange(color, duration);</span><span class="javascript"><span class="hljs-built_in">setTimeout</span>(res, duration);</span><span class="javascript">&#125;)</span><span class="javascript">&#125;</span><span class="javascript"></span><span class="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setLight</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript"><span class="hljs-keyword">await</span> setColor(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">7000</span>);</span><span class="javascript"><span class="hljs-keyword">await</span> setColor(<span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-number">3000</span>);</span><span class="javascript"><span class="hljs-keyword">await</span> setColor(<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-number">5000</span>);</span><span class="javascript"><span class="hljs-keyword">await</span> setLight();</span><span class="javascript">&#125;</span><span class="javascript">setLight();</span><span class="javascript">&#125;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;light-content&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red-light&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;yellow-light&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;green-light&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-JS&quot;&gt;&lt;a href=&quot;#一-JS&quot; class=&quot;headerlink&quot; title=&quot;一 JS&quot;&gt;&lt;/a&gt;一 JS&lt;/h2&gt;&lt;p&gt;1 手写 new Object.create&lt;br&gt;2 获取JS类型&lt;br&gt;3 instanceOf&lt;br&gt;4 深拷贝&lt;br</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="手写" scheme="http://example.com/tags/%E6%89%8B%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>算法汇总</title>
    <link href="http://example.com/2021/06/28/interview/%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2021/06/28/interview/%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2021-06-28T12:05:03.000Z</published>
    <updated>2021-06-28T12:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-排序和二分搜索"><a href="#一-排序和二分搜索" class="headerlink" title="一 排序和二分搜索"></a>一 排序和二分搜索</h2><p>1冒泡排序 - 2选择排序 - 3插入排序(3-2 希尔排序) - 4归并排序 - 5快速排序 - 6二分搜索<br>7x的平方根 - 8猜数字大小</p><table><thead><tr><th>排序类型</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th><th>思路</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>比较所有相邻元素，如果第一个比第二个大，则交换它们</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td><td>找到最小值，与第一位互换</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</td></tr><tr><td>归并排序</td><td>O(n logn)</td><td>O(n logn)</td><td>O(n logn)</td><td>O(n)</td><td>稳定</td><td>从中间一分为二，排序后再合并</td></tr><tr><td>快速排序</td><td>O(n logn)</td><td>O(n logn)</td><td>O(n²)</td><td>O(n logn)</td><td>不稳定</td><td>选择一个基准，比基准大的放在左边数组，小的放在右边数组，依次递归，再合并</td></tr></tbody></table><p>Array.prototype.srot:<br>Chrome 长度 <code>&lt;= 10</code> 的数组使用的是<strong>插入排序</strong>(稳定排序算法) ，<code>&gt;10</code> 的数组使用的是<strong>快速排序</strong>。快速排序是不稳定的排序算法<br> Firefox 用的 <strong>归并排序</strong></p><p> 冒泡排序：稳定，</p><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 1 冒泡排序-稳定-平均 O(n^2) [时间: O(n)&lt;O(n^2) 空间: O(1)]</span><span class="hljs-comment">// (1) 比较所有相邻元素，如果第一个比第二个大，则交换它们</span><span class="hljs-comment">// (2) 一轮下来，可以保证最后一个数是最大的</span><span class="hljs-comment">// (3) 执行 n-1 轮，就可以完成排序</span><span class="hljs-built_in">Array</span>.prototype.bubbleSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span> - j; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[i] &gt; <span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>]) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];<span class="hljs-built_in">this</span>[i] = <span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>];<span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>] = tem;&#125;&#125;&#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 2 选择排序-不稳定-时间: O(n^2) 空间: O(1)</span><span class="hljs-comment">// 选出最小值后需要交换位置,位置一变就会变得不稳定</span><span class="hljs-comment">// (1) 找到数组中的最小值，选中它并将其放置到第一位，</span><span class="hljs-comment">// (2) 接着找到第二小的值，选中它并将其放置到第二位</span><span class="hljs-comment">// (3) 以此类推，执行 n-1 轮</span><span class="hljs-built_in">Array</span>.prototype.selectSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>; i++ ) &#123;<span class="hljs-keyword">let</span> indexMin = i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[j] &lt; <span class="hljs-built_in">this</span>[indexMin]) &#123;indexMin = j;&#125;&#125;<span class="hljs-keyword">if</span> (indexMin !== i) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];<span class="hljs-built_in">this</span>[i] = <span class="hljs-built_in">this</span>[indexMin];<span class="hljs-built_in">this</span>[indexMin] = tem;&#125;&#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 3 插入排序 稳定 平均 O(n^2)[时间: O(n)&lt;O(n^2) 空间: O(1)]</span><span class="hljs-comment">// 原理是通过构建有序序列，对于未排序数据，在已排序序列中 从后向前 扫描，找到相应位置并插入。</span><span class="hljs-comment">// (1) 从第二个数开始往前比</span><span class="hljs-comment">// (2) 如果前面的数字比它大 就往后排</span><span class="hljs-comment">// (3) 以此类推 进行到最后一个数字</span><span class="hljs-built_in">Array</span>.prototype.insertSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];<span class="hljs-keyword">let</span> j = i;<span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[j - <span class="hljs-number">1</span>] &gt; tem) &#123;<span class="hljs-built_in">this</span>[j] = <span class="hljs-built_in">this</span>[j - <span class="hljs-number">1</span>];j--;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">this</span>[j] = tem;&#125;&#125;<span class="hljs-comment">// 3-2 希尔排序 / 缩小增量排序</span><span class="hljs-comment">// 是 插入排序 的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</span><span class="hljs-comment">// (1)选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</span><span class="hljs-comment">// (2)按增量序列个数k，对序列进行k 趟排序；</span><span class="hljs-comment">// (3)每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><span class="hljs-comment">//仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">var</span> len = arr.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>); k &gt; <span class="hljs-number">0</span>; k = <span class="hljs-built_in">Math</span>.floor(k / <span class="hljs-number">2</span>)) &#123;        <span class="hljs-comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = k; i &lt; len; i++) &#123;            varj = i;            <span class="hljs-keyword">var</span> current = arr[i];            <span class="hljs-keyword">while</span>(j - k &gt;= <span class="hljs-number">0</span> &amp;&amp; current &lt; arr[j - k]) &#123;                 arr[j] = arr[j - k];                 j = j - k;            &#125;            arr[j] = current;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 4 归并排序 稳定 时间:O(n logn) 空间:O(n)</span><span class="hljs-comment">// 分而治之</span><span class="hljs-comment">//（1）把长度为n的输入序列分成两个长度为n/2的子序列</span><span class="hljs-comment">// (2) 对这两个子序列分别采用归并排序</span><span class="hljs-comment">// (3) 将两个排序好的子序列合并成一个最终的排序序列</span><span class="hljs-built_in">Array</span>.prototype.mergeSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 除二取整: arr.length &gt;&gt;&gt; 1</span><span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<span class="hljs-keyword">const</span> left = arr.slice(<span class="hljs-number">0</span>, mid);<span class="hljs-keyword">const</span> right = arr.slice(mid, arr.length);<span class="hljs-keyword">const</span> orderLeft = rec(left);<span class="hljs-keyword">const</span> orderRight = rec(right);<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span>(orderLeft.length || orderRight.length) &#123;<span class="hljs-keyword">if</span> (orderLeft.length &amp;&amp; orderRight.length) &#123;res.push(orderLeft[<span class="hljs-number">0</span>] &lt; orderRight[<span class="hljs-number">0</span>] ?orderLeft.shift() : orderRight.shift());&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orderLeft.length) &#123;res.push(orderLeft.shift());&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orderRight.length) &#123;res.push(orderRight.shift());&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">const</span> res = rec(<span class="hljs-built_in">this</span>);res.forEach(<span class="hljs-function">(<span class="hljs-params">n, i</span>) =&gt;</span> <span class="hljs-built_in">this</span>[i] = n);&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 5 快速排序 不稳定 平均: O(n logn)</span><span class="hljs-comment">// 时间:O(n logn) &lt; O(n²) 空间:O(n logn)</span><span class="hljs-comment">// 排序过程中位置会发生变化,位置一变就会变得不稳定</span><span class="hljs-comment">// 分而治之：将选择一个基准，比基准大的放在左边数组，小的放在右边数组，依次递归，再合并</span><span class="hljs-built_in">Array</span>.prototype.quickSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span>(arr.length &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">const</span> left = [];<span class="hljs-keyword">const</span> right = [];<span class="hljs-keyword">const</span> mid = arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<span class="hljs-keyword">if</span> (arr[i] &lt; mid) &#123;left.push(arr[i]);&#125; <span class="hljs-keyword">else</span> &#123;right.push(arr[i])&#125;&#125;<span class="hljs-keyword">return</span> [...rec(left), mid, ...rec(right)];&#125;;<span class="hljs-keyword">const</span> res = rec(<span class="hljs-built_in">this</span>);res.forEach(<span class="hljs-function">(<span class="hljs-params">n, i</span>) =&gt;</span> <span class="hljs-built_in">this</span>[i] = n);&#125;</code></pre><h3 id="6-二分搜索"><a href="#6-二分搜索" class="headerlink" title="6 二分搜索"></a>6 二分搜索</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 6 二分搜索 O(logN)</span><span class="hljs-built_in">Array</span>.prototype.binarySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> high = <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(low &lt;= high) &#123;<span class="hljs-comment">// 除二取整: (high + low) &gt;&gt;&gt; 1</span><span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((high + low) / <span class="hljs-number">2</span>);<span class="hljs-keyword">const</span> element = <span class="hljs-built_in">this</span>[mid];<span class="hljs-keyword">if</span> (element &lt; item) &#123;low = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element &gt; item) &#123;high = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> mid;&#125;&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 7 x 的平方根</span><span class="hljs-keyword">var</span> mySqrt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;<span class="hljs-comment">// 时间复杂度: O(log N)</span>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">let</span> low = <span class="hljs-number">1</span>; <span class="hljs-comment">// 除二取整</span>    <span class="hljs-keyword">let</span> higt = x &gt;&gt;&gt; <span class="hljs-number">1</span>;     <span class="hljs-keyword">while</span>(low + <span class="hljs-number">1</span> &lt; higt) &#123;        <span class="hljs-comment">// Math.floor((low + higt) / 2);</span>        <span class="hljs-keyword">const</span> mid = (low + higt) &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">const</span> s = x / mid;        <span class="hljs-keyword">if</span> (s === mid) &#123;            <span class="hljs-keyword">return</span> mid;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; mid) &#123;            low = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            higt = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> x / higt &gt;= higt ? higt : low;&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 8 猜数字大小 二分搜索 时间 O(logN) 空间 O(1)</span><span class="hljs-keyword">var</span> guessNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> low = <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> high = n;    <span class="hljs-keyword">while</span>(high &gt;= low) &#123; <span class="hljs-comment">// 除以二并取整</span> <span class="hljs-comment">// Math.floor((low + high) / 2);</span>        <span class="hljs-keyword">const</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">const</span> res = guess(mid);        <span class="hljs-keyword">if</span> (res === -<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 比mid 小,搜索 0 - mid 范围</span>            high = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 比mid 大,搜索 mid - n 范围</span>            low = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> mid;        &#125;    &#125;&#125;;<span class="hljs-comment">// 解法二</span><span class="hljs-comment">// 猜数字大小,分而治之 ,时间O(logN),空间O(logN)</span><span class="hljs-keyword">var</span> guessNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">const</span> rec = <span class="hljs-function">(<span class="hljs-params">low, high</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (low &gt; high) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// 除二取整</span><span class="hljs-keyword">const</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> res = guess(mid);<span class="hljs-keyword">if</span> (res === <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 猜对了</span><span class="hljs-keyword">return</span> mid;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//比mid大</span><span class="hljs-keyword">return</span> rec(mid + <span class="hljs-number">1</span>, high);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//比mid小</span><span class="hljs-keyword">return</span> rec(low, mid - <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">return</span> rec(<span class="hljs-number">1</span>, n);&#125;;</code></pre><h2 id="二-树"><a href="#二-树" class="headerlink" title="二 树"></a>二 树</h2><p>1 树深度优先/广度优先<br>2 二叉树深度优先/广度优先 - 二叉树<br>3 先序/4中序/5后序<br>6 二叉树的最大深度<br>7 二叉树的最小深度<br>8 二叉树的层序遍历<br>9 二叉树的锯齿形层序遍历<br>10 相同的树<br>11 翻转二叉树<br>12 二叉树的层序遍历II （自底向上）<br>13 二叉树中第二小的节点<br>14 把二叉搜索树转换为累加树 (从二叉搜索树到更大和树)<br>15 二叉搜索树中的搜索 （从 二叉搜索树找到 给定值 的子树）<br>16 N叉树的最大深度<br>17 N叉树的前序遍历<br>18 N叉树的后序遍历<br>19 递增顺序查找树 （按中序遍历 重新排列树，使树中最左边的结点现在是树的根）<br>20 二叉树所有路径<br>21 另一个树的子树 ( 树s 中是否包含和 树t)<br>22 从前序与中序遍历序列构造二叉树<br>23 从中序与后序遍历序列构造二叉树<br>24 平衡二叉树 —— 判断是不是平衡二叉树<br>25 有序链表转换平衡二叉树<br>26 路径总和 Ⅰ II</p><h3 id="1-树-深度优先"><a href="#1-树-深度优先" class="headerlink" title="1 树 - 深度优先"></a>1 树 - 深度优先</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 1 树 - 深度优先</span><span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-comment">// 访问节点数据</span><span class="hljs-built_in">console</span>.log(root.val);<span class="hljs-comment">// 递归 访问子节点</span>root.children.forEach(dfs);&#125;dfs(tree);<span class="hljs-comment">// 树 - 广度优先</span><span class="hljs-keyword">const</span> bfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-comment">// 先把各节点入队</span><span class="hljs-keyword">const</span> q = [root];<span class="hljs-keyword">while</span>(q.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 出队</span><span class="hljs-keyword">const</span> n = q.shift();<span class="hljs-comment">// 访问节点数据</span><span class="hljs-built_in">console</span>.log(n.val);<span class="hljs-keyword">if</span> (n.children) &#123;n.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;q.push(child);&#125;)&#125;&#125;&#125;bfs(tree);</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 2 二叉树 - 深度/广度优先遍历</span><span class="hljs-comment">// 深度1 - 打印结果</span><span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 访问节点数据</span><span class="hljs-built_in">console</span>.log(root.val);dfs(root.left);dfs(root.right)&#125;<span class="hljs-comment">// 深度2 - 递归版 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs2</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tree</span>) </span>&#123;<span class="hljs-comment">// console.log(tree.val);</span>res.push(tree.val);<span class="hljs-keyword">if</span> (tree.left) rec(tree.left);<span class="hljs-keyword">if</span> (tree.right) rec(tree.right);&#125;rec(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 深度3 - 非递归版 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs3</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);<span class="hljs-keyword">if</span> (item.right) &#123;stack.push(item.right);&#125;<span class="hljs-keyword">if</span> (item.left) &#123;stack.push(item.left);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 广度 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fbs</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.shift();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);<span class="hljs-keyword">if</span> (item.left) &#123;stack.push(item.left);&#125;<span class="hljs-keyword">if</span> (item.right) &#123;stack.push(item.right);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 3先序遍历: 根 -&gt; 左 -&gt; 右</span><span class="hljs-comment">// 递归版1 - 打印结果</span><span class="hljs-keyword">const</span> preorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">console</span>.log(root.val);preorder(root.left);preorder(root.right);&#125;<span class="hljs-comment">// 递归版2 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preorder2</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);<span class="hljs-keyword">if</span> (item.right) &#123;stack.push(item.right);&#125;<span class="hljs-keyword">if</span> (item.left) &#123;stack.push(item.left);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 3先序遍历: 根 -&gt; 左 -&gt; 右</span><span class="hljs-comment">// 非递归版</span><span class="hljs-keyword">const</span> preorder2 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);<span class="hljs-keyword">if</span> (item.right) &#123;stack.push(item.right);&#125;<span class="hljs-keyword">if</span> (item.left) &#123;stack.push(item.left);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 4中序遍历: 左 -&gt; 根 -&gt; 右</span><span class="hljs-comment">// 中序 - 递归版1 -  打印结果</span><span class="hljs-keyword">const</span> inorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (root.left) inorder(root.left);<span class="hljs-built_in">console</span>.log(root.val);<span class="hljs-keyword">if</span> (root.right) inorder(root.right);&#125;<span class="hljs-comment">// 中序 - 递归版2 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inorder2</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tr</span>) </span>&#123;<span class="hljs-keyword">if</span> (tr.left) rec(tr.left);<span class="hljs-comment">// console.log(tr.val);</span>res.push(tr.val);<span class="hljs-keyword">if</span> (tr.right) rec(tr.right);&#125;rec(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 4中序遍历: 左 -&gt; 根 -&gt; 右</span><span class="hljs-comment">// 中序 -&gt; 非递归版</span><span class="hljs-keyword">const</span> inorder3 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> stack = [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">let</span> p = root;<span class="hljs-keyword">while</span> (stack.length || p) &#123;<span class="hljs-keyword">while</span>(p) &#123;stack.push(p);p = p.left;&#125;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);p = item.right;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 5后序遍历: 左 -&gt; 右 &gt; 根</span><span class="hljs-comment">// 后序遍历 -&gt; 递归版1 -  打印结果</span><span class="hljs-keyword">const</span> postorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span>;&#125;postorder(root.left);postorder(root.right);<span class="hljs-comment">// 访问当前节点</span><span class="hljs-built_in">console</span>.log(root.val);&#125;<span class="hljs-comment">// 后序遍历 -&gt; 递归版2 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postorder2</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tr</span>) </span>&#123;<span class="hljs-keyword">if</span> (tr.left) rec(tr.left);<span class="hljs-keyword">if</span> (tr.right) rec(tr.right);<span class="hljs-comment">// console.log(tr.val);</span>res.push(tr.val);&#125;rec(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 后序遍历 -&gt; 非递归版 - 收集并返回结果</span><span class="hljs-keyword">const</span> postorder3 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> outputStack = [];<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();outputStack.push(item);<span class="hljs-keyword">if</span> (item.left) stack.push(item.left);<span class="hljs-keyword">if</span> (item.right) stack.push(item.right);&#125; <span class="hljs-keyword">while</span>(outputStack.length) &#123;<span class="hljs-keyword">const</span> item = outputStack.pop();<span class="hljs-comment">// 访问当前节点</span><span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="6-二叉树的最大深度"><a href="#6-二叉树的最大深度" class="headerlink" title="6 二叉树的最大深度"></a>6 二叉树的最大深度</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 6 题: 二叉树的最大深度 104</span><span class="hljs-comment">// 给定一个二叉树，找出其最大深度。</span><span class="hljs-comment">// 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><span class="hljs-comment">// 说明: 叶子节点是指没有子节点的节点。</span><span class="hljs-comment">// 示例：</span><span class="hljs-comment">// 给定二叉树 [3,9,20,null,null,15,7]，</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 返回它的最大深度 3 。</span><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> dpt = <span class="hljs-function">(<span class="hljs-params">root, l</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;res = <span class="hljs-built_in">Math</span>.max(res, l)&#125;<span class="hljs-keyword">if</span> (root.left) dpt(root.left, l + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (root.right) dpt(root.right, l + <span class="hljs-number">1</span>);&#125;dpt(root, <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 7 题: 二叉树的最小深度 111</span><span class="hljs-comment">// 给定一个二叉树，找出其最小深度。</span><span class="hljs-comment">// 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span><span class="hljs-comment">// 说明：叶子节点是指没有子节点的节点。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 输入：root = [3,9,20,null,null,15,7]</span><span class="hljs-comment">// 输出：2</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：root = [2,null,3,null,4,null,5,null,6]</span><span class="hljs-comment">// 输出：5</span><span class="hljs-comment">// 解法一 深度遍历法</span><span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;   <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-literal">Infinity</span>;<span class="hljs-keyword">const</span> dpt = <span class="hljs-function">(<span class="hljs-params">root, l</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;res = <span class="hljs-built_in">Math</span>.min(res, l);&#125;<span class="hljs-keyword">if</span> (root.left) dpt(root.left, l + <span class="hljs-number">1</span>); <span class="hljs-keyword">if</span> (root.right) dpt(root.right, l + <span class="hljs-number">1</span>); &#125;dpt(root, <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二 广度优先遍历</span><span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> stack = [[root, <span class="hljs-number">1</span>]];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">const</span> [n, l] = stack.shift();<span class="hljs-keyword">if</span> (!n.left &amp;&amp; !n.right) &#123;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-keyword">if</span> (n.left) stack.push([n.left, l + <span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span> (n.right) stack.push([n.right, l + <span class="hljs-number">1</span>]);&#125;&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 8 二叉树的层序遍历 102</span><span class="hljs-comment">// 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</span><span class="hljs-comment">// 示例：</span><span class="hljs-comment">// 二叉树：[3,9,20,null,null,15,7],</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 返回其层序遍历结果：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [3],</span><span class="hljs-comment">//   [9,20],</span><span class="hljs-comment">//   [15,7]</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 广度优先遍历 【推荐 二颗星】</span><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">var</span> stack = [[root, <span class="hljs-number">0</span>]];<span class="hljs-keyword">var</span> res = [];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">var</span> [n, level] = stack.shift();<span class="hljs-keyword">if</span> (!res[level]) &#123;res.push([n.val]);&#125; <span class="hljs-keyword">else</span> &#123;res[level].push(n.val);&#125;<span class="hljs-keyword">if</span> (n.left) stack.push([n.left, level + <span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span> (n.right) stack.push([n.right, level + <span class="hljs-number">1</span>]); &#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 广度优先遍历-每次清空当前层级数据【推荐 三星】</span><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span>(stack.length) &#123;res.push([]);<span class="hljs-keyword">let</span> len = stack.length;<span class="hljs-keyword">while</span>(len--) &#123;<span class="hljs-keyword">const</span> n = stack.shift();res[res.length - <span class="hljs-number">1</span>].push(n.val);<span class="hljs-keyword">if</span> (n.left) stack.push(n.left);<span class="hljs-keyword">if</span> (n.right) stack.push(n.right);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 递归写法</span><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> res = []<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root, depth</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (!res[depth]) &#123;res[depth] = []&#125;traversal(root.left, depth + <span class="hljs-number">1</span>)res[depth].push(root.val)traversal(root.right, depth + <span class="hljs-number">1</span>)&#125;&#125;traversal(root, <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 9 二叉树的锯齿形层序遍历 103</span><span class="hljs-comment">// 给定一个二叉树，返回其节点值的锯齿形层序遍历</span><span class="hljs-comment">//（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</span><span class="hljs-comment">// 例如：</span><span class="hljs-comment">// 给定二叉树 [3,9,20,null,null,15,7],</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 返回锯齿形层序遍历如下：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [3],</span><span class="hljs-comment">//   [20,9],</span><span class="hljs-comment">//   [15,7]</span><span class="hljs-comment">// ]</span><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;        <span class="hljs-keyword">let</span> len = stack.length;        res.push([]);        <span class="hljs-keyword">while</span>(len--) &#123;    <span class="hljs-keyword">const</span> n = stack.shift();            res[res.length - <span class="hljs-number">1</span>].push(n.val);            <span class="hljs-keyword">if</span> (n.left) stack.push(n.left);            <span class="hljs-keyword">if</span> (n.right) stack.push(n.right);        &#125;&#125;res.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? item : item.reverse());<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 10 相同的树 100</span><span class="hljs-comment">// 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span><span class="hljs-comment">// 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：p = [1,2,3], q = [1,2,3]</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：p = [1,2], q = [1,null,2]</span><span class="hljs-comment">// 输出：false</span><span class="hljs-keyword">var</span> isSameTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, q</span>) </span>&#123;<span class="hljs-keyword">if</span>(!p &amp;&amp; !q) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span>(p &amp;&amp; q &amp;&amp; p.val === q.val &amp;&amp;isSameTree(p.left, q.left) &amp;&amp;isSameTree(p.right, q.right)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre><h3 id="11-翻转二叉树"><a href="#11-翻转二叉树" class="headerlink" title="11 翻转二叉树"></a>11 翻转二叉树</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 11 翻转二叉树 226</span><span class="hljs-comment">// 翻转一棵二叉树。</span><span class="hljs-comment">// 示例：</span><span class="hljs-comment">// 输入：</span><span class="hljs-comment">//      4</span><span class="hljs-comment">//    /   \</span><span class="hljs-comment">//   2     7</span><span class="hljs-comment">//  / \   / \</span><span class="hljs-comment">// 1   3 6   9</span><span class="hljs-comment">// 输出：</span><span class="hljs-comment">//      4</span><span class="hljs-comment">//    /   \</span><span class="hljs-comment">//   7     2</span><span class="hljs-comment">//  / \   / \</span><span class="hljs-comment">// 9   6 3   1</span><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-comment">// 时间复杂度: O(N)</span><span class="hljs-comment">// 空间复杂度: O(h)  h是树的高度 </span><span class="hljs-keyword">if</span>(!root) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">val</span>: root.val,<span class="hljs-attr">left</span>: invertTree(root.right),<span class="hljs-attr">right</span>: invertTree(root.left),&#125;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 12 二叉树的层序遍历 II 107</span><span class="hljs-comment">// 自底向上</span><span class="hljs-comment">// 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</span><span class="hljs-comment">// 例如：</span><span class="hljs-comment">// 给定二叉树 [3,9,20,null,null,15,7],</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 返回其自底向上的层序遍历为：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [15,7],</span><span class="hljs-comment">//   [9,20],</span><span class="hljs-comment">//   [3]</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 解法一 递归写法</span><span class="hljs-keyword">var</span> levelOrderBottom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> res = []<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root, depth</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (!res[depth]) &#123;res[depth] = []&#125;traversal(root.left, depth + <span class="hljs-number">1</span>)res[depth].push(root.val)traversal(root.right, depth + <span class="hljs-number">1</span>)&#125;&#125;traversal(root, <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res.reverse()&#125;<span class="hljs-comment">// 解法二 广度优先 非递归</span><span class="hljs-keyword">var</span> levelOrderBottom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span>(stack.length) &#123;res.push([]);<span class="hljs-keyword">let</span> len = stack.length;<span class="hljs-keyword">while</span>(len--) &#123;<span class="hljs-keyword">const</span> n = stack.shift();res[res.length - <span class="hljs-number">1</span>].push(n.val);<span class="hljs-keyword">if</span> (n.left) stack.push(n.left);<span class="hljs-keyword">if</span> (n.right) stack.push(n.right);&#125;&#125;    <span class="hljs-keyword">return</span> res.reverse();&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 13 二叉树中第二小的节点 671</span><span class="hljs-comment">// 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0</span><span class="hljs-comment">// 如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</span><span class="hljs-comment">// 更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</span><span class="hljs-comment">// 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">//      2</span><span class="hljs-comment">//    /   \</span><span class="hljs-comment">//   2     5</span><span class="hljs-comment">//        / \</span><span class="hljs-comment">//       5   7</span><span class="hljs-comment">// 输入：root = [2,2,5,null,null,5,7]</span><span class="hljs-comment">// 输出：5</span><span class="hljs-comment">// 解释：最小的值是 2 ，第二小的值是 5 。</span><span class="hljs-keyword">var</span> findSecondMinimumValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;  <span class="hljs-keyword">let</span> arr = [];  (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;      traversal(root.left)      arr.push(root.val)      traversal(root.right)    &#125;  &#125;)(root)  <span class="hljs-keyword">let</span> _arr = [...new <span class="hljs-built_in">Set</span>(arr)].sort()  <span class="hljs-keyword">return</span> _arr[<span class="hljs-number">1</span>] ? _arr[<span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 14 把二叉搜索树转换为累加树 1038</span><span class="hljs-comment">// 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree）</span><span class="hljs-comment">// 使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</span><span class="hljs-comment">// 提醒一下，二叉搜索树满足下列约束条件：</span><span class="hljs-comment">//  - 节点的左子树仅包含键 小于 节点键的节点。</span><span class="hljs-comment">//  - 节点的右子树仅包含键 大于 节点键的节点。</span><span class="hljs-comment">//  - 左右子树也必须是二叉搜索树。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><span class="hljs-comment">// 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：root = [0,null,1]</span><span class="hljs-comment">// 输出：[1,null,1]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：root = [1,0,2]</span><span class="hljs-comment">// 输出：[3,3,2]</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：root = [3,2,4,1]</span><span class="hljs-comment">// 输出：[7,9,4,10]</span><span class="hljs-keyword">var</span> bstToGst = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;traversal(root.right);root.val += sum;sum = root.val;traversal(root.left);&#125;&#125;traversal(root);<span class="hljs-keyword">return</span> root;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 15 二叉搜索树中的搜索 700</span><span class="hljs-comment">// 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点</span><span class="hljs-comment">// 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</span><span class="hljs-comment">// 例如，</span><span class="hljs-comment">// 给定二叉搜索树:</span><span class="hljs-comment">//         4</span><span class="hljs-comment">//        / \</span><span class="hljs-comment">//       2   7</span><span class="hljs-comment">//      / \</span><span class="hljs-comment">//     1   3</span><span class="hljs-comment">// 和值: 2</span><span class="hljs-comment">// 你应该返回如下子树:</span><span class="hljs-comment">//       2     </span><span class="hljs-comment">//      / \   </span><span class="hljs-comment">//     1   3</span><span class="hljs-comment">// 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</span><span class="hljs-keyword">var</span> searchBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, val</span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (root.val === val) &#123;<span class="hljs-keyword">return</span> root;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; val) &#123;<span class="hljs-keyword">return</span> traversal(root.right);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> traversal(root.left);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> root;&#125;  &#125;  <span class="hljs-keyword">return</span> traversal(root);&#125;</code></pre><h3 id="16-N叉树的最大深度"><a href="#16-N叉树的最大深度" class="headerlink" title="16 N叉树的最大深度"></a>16 N叉树的最大深度</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 16 N叉树的最大深度 559</span><span class="hljs-comment">// 给定一个 N 叉树，找到其最大深度。</span><span class="hljs-comment">// 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</span><span class="hljs-comment">// N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：root = [1,null,3,2,4,null,5,6]</span><span class="hljs-comment">// 输出：3</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><span class="hljs-comment">// 输出：5</span><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">let</span> depth = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root, curDepth</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (curDepth &gt; depth) &#123;depth = curDepth;&#125;root.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> traversal(child, curDepth + <span class="hljs-number">1</span>));&#125;&#125;traversal(root, <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> depth;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 17 N叉树的前序遍历 589</span><span class="hljs-comment">// 给定一个 N 叉树，返回其节点值的 前序遍历 。</span><span class="hljs-comment">// N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</span><span class="hljs-comment">// 进阶：</span><span class="hljs-comment">// 递归法很简单，你可以使用迭代法完成此题吗?</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：root = [1,null,3,2,4,null,5,6]</span><span class="hljs-comment">// 输出：[1,3,5,6,2,4]</span><span class="hljs-comment">// 解法一：递归</span><span class="hljs-keyword">var</span> preorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;res.push(root.val);root.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> traversal(child));&#125;&#125;traversal(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 解法二： 迭代</span><span class="hljs-keyword">var</span> preorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> array = [];<span class="hljs-keyword">let</span> stack = [root];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">let</span> len = stack.length;<span class="hljs-keyword">let</span> node = stack.shift(); <span class="hljs-comment">// 弹出栈中第一个，先进先出</span>array.push(node.val);<span class="hljs-keyword">if</span> (node.children.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 这里有别于层序遍历，用 node.children 连接 queue</span><span class="hljs-comment">// 而不是 queue.concat(node.children)这样就实现了前序遍历的效果</span>stack = node.children.concat(stack);&#125;&#125;<span class="hljs-keyword">return</span> array;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 18 N叉树的后序遍历 590</span><span class="hljs-comment">// 给定一个 N 叉树，返回其节点值的 后序遍历 。</span><span class="hljs-comment">// N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</span><span class="hljs-comment">// 进阶：</span><span class="hljs-comment">// 递归法很简单，你可以使用迭代法完成此题吗?</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：root = [1,null,3,2,4,null,5,6]</span><span class="hljs-comment">// 输出：[5,6,3,2,4,1]</span><span class="hljs-comment">// 解法一：递归</span><span class="hljs-keyword">var</span> postorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;root.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<span class="hljs-built_in">arguments</span>.callee(child);&#125;)res.push(root.val);&#125;&#125;traversal(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 解法二：迭代</span><span class="hljs-keyword">var</span> postorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> stack = [root];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">let</span> node = stack.pop(); <span class="hljs-comment">// 弹出最后面的一个元素</span><span class="hljs-keyword">if</span> (node.children.length &gt; <span class="hljs-number">0</span>) &#123;stack = stack.concat(node.children);&#125;res.unshift(node.val); <span class="hljs-comment">// 节点先进后出，数值压栈存储</span>&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 19 递增顺序查找树 897</span><span class="hljs-comment">// 给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根</span><span class="hljs-comment">// 并且每个结点没有左子结点，只有一个右子结点。</span><span class="hljs-comment">// 示例 ：</span><span class="hljs-comment">// 输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]</span><span class="hljs-comment">//        5</span><span class="hljs-comment">//       / \</span><span class="hljs-comment">//     3    6</span><span class="hljs-comment">//    / \    \</span><span class="hljs-comment">//   2   4    8</span><span class="hljs-comment">//  /        / \ </span><span class="hljs-comment">// 1        7   9</span><span class="hljs-comment">// 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><span class="hljs-comment">//  1</span><span class="hljs-comment">//   \</span><span class="hljs-comment">//    2</span><span class="hljs-comment">//     \</span><span class="hljs-comment">//      3</span><span class="hljs-comment">//       \</span><span class="hljs-comment">//        4</span><span class="hljs-comment">//         \</span><span class="hljs-comment">//          5</span><span class="hljs-comment">//           \</span><span class="hljs-comment">//            6</span><span class="hljs-comment">//             \</span><span class="hljs-comment">//              7</span><span class="hljs-comment">//               \</span><span class="hljs-comment">//                8</span><span class="hljs-comment">//                 \</span><span class="hljs-comment">//                  9  </span><span class="hljs-keyword">var</span> increasingBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">const</span> arr = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;traversal(root.left);arr.push(root.val);traversal(root.right);&#125;&#125;traversal(root);<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> TreeNode(arr[<span class="hljs-number">0</span>]);<span class="hljs-keyword">let</span> currentNode = res;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;currentNode.left = <span class="hljs-literal">null</span>;currentNode.right = <span class="hljs-keyword">new</span> TreeNode(arr[i + <span class="hljs-number">1</span>]);currentNode = currentNode.right;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 20 二叉树的所有路径 257</span><span class="hljs-comment">// 给定一个二叉树，返回所有从根节点到叶子节点的路径。</span><span class="hljs-comment">// 说明: 叶子节点是指没有子节点的节点。</span><span class="hljs-comment">// 例如：</span><span class="hljs-comment">// 输入:</span><span class="hljs-comment">//    1</span><span class="hljs-comment">//  /   \</span><span class="hljs-comment">// 2     3</span><span class="hljs-comment">//  \</span><span class="hljs-comment">//   5</span><span class="hljs-comment">// 输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><span class="hljs-comment">// 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span><span class="hljs-keyword">var</span> binaryTreePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root, str = <span class="hljs-string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (root.left) dfs(root.left, str + root.val + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);<span class="hljs-keyword">if</span> (root.right) dfs(root.right, str + root.val + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) res.push(str + root.val);<span class="hljs-keyword">return</span>; &#125;dfs(root);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="21-另一个树的子树"><a href="#21-另一个树的子树" class="headerlink" title="21 另一个树的子树"></a>21 另一个树的子树</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 21 另一个树的子树 257</span><span class="hljs-comment">// 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树</span><span class="hljs-comment">// s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 给定的树 s:</span><span class="hljs-comment">//      3</span><span class="hljs-comment">//     / \</span><span class="hljs-comment">//    4   5</span><span class="hljs-comment">//   / \</span><span class="hljs-comment">//  1   2</span><span class="hljs-comment">// 给定的树 t：</span><span class="hljs-comment">//    4 </span><span class="hljs-comment">//   / \</span><span class="hljs-comment">//  1   2</span><span class="hljs-comment">// 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 给定的树 s：</span><span class="hljs-comment">//      3</span><span class="hljs-comment">//     / \</span><span class="hljs-comment">//    4   5</span><span class="hljs-comment">//   / \</span><span class="hljs-comment">//  1   2</span><span class="hljs-comment">//     /</span><span class="hljs-comment">//    0</span><span class="hljs-comment">// 给定的树 t：</span><span class="hljs-comment">//    4</span><span class="hljs-comment">//   / \</span><span class="hljs-comment">//  1   2</span><span class="hljs-comment">// 返回 false</span><span class="hljs-keyword">var</span> isSubtree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<span class="hljs-keyword">if</span> (!s) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">if</span> (isSameTree(s, t)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t); <span class="hljs-comment">// 有一个true就true</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSameTree</span>(<span class="hljs-params">s, t</span>) </span>&#123; <span class="hljs-comment">// 100题</span><span class="hljs-keyword">if</span> (!s &amp;&amp; !t) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-keyword">if</span> (!s || !t ) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> s.val == t.val &amp;&amp; isSameTree(s.left, t.left) &amp;&amp; isSameTree(s.right, t.right);&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 22 从前序与中序遍历序列构造二叉树 105</span><span class="hljs-comment">// 根据一棵树的前序遍历与中序遍历构造二叉树。</span><span class="hljs-comment">// 注意:</span><span class="hljs-comment">// 你可以假设树中没有重复的元素。</span><span class="hljs-comment">// 例如，给出</span><span class="hljs-comment">// 前序遍历 preorder = [3,9,20,15,7]</span><span class="hljs-comment">// 中序遍历 inorder = [9,3,15,20,7]</span><span class="hljs-comment">// 返回如下的二叉树：</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-keyword">var</span> buildTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, inorder</span>) </span>&#123;<span class="hljs-keyword">if</span>(!inorder.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> rootVal = preorder[<span class="hljs-number">0</span>];<span class="hljs-keyword">const</span> rootIndex = inorder.indexOf(rootVal);<span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> TreeNode(rootVal);root.left = buildTree(preorder.slice(<span class="hljs-number">1</span>, rootIndex + <span class="hljs-number">1</span>),inorder.slice(<span class="hljs-number">0</span>, rootIndex));root.right = buildTree(preorder.slice(rootIndex + <span class="hljs-number">1</span>),inorder.slice(rootIndex + <span class="hljs-number">1</span>));<span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 解法二</span><span class="hljs-comment">// let build = (inorder) =&gt; &#123;</span><span class="hljs-comment">// if(!inorder || !inorder.length) return null;</span><span class="hljs-comment">// const rootVal = preorder.shift();</span><span class="hljs-comment">// const rootIndex = inorder.indexOf(rootVal);</span><span class="hljs-comment">// let root = new TreeNode(rootVal);</span><span class="hljs-comment">// root.left = build(inorder.slice(0, rootIndex));</span><span class="hljs-comment">// root.right = build(inorder.slice(rootIndex + 1));</span><span class="hljs-comment">// return root</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return build(inorder)</span>&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 23 从中序与后序遍历序列构造二叉树 106</span><span class="hljs-comment">// 根据一棵树的前序遍历与中序遍历构造二叉树。</span><span class="hljs-comment">// 注意:</span><span class="hljs-comment">// 你可以假设树中没有重复的元素。</span><span class="hljs-comment">// 例如，给出</span><span class="hljs-comment">// 前序遍历 preorder = [3,9,20,15,7]</span><span class="hljs-comment">// 中序遍历 inorder = [9,3,15,20,7]</span><span class="hljs-comment">// 返回如下的二叉树：</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-keyword">var</span> buildTree = <span class="hljs-function">(<span class="hljs-params">inorder, postorder</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(!inorder.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> rootVal = postorder.pop();<span class="hljs-keyword">const</span> rootIndex = inorder.indexOf(rootVal);<span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> TreeNode(rootVal);root.left = buildTree(inorder.slice(<span class="hljs-number">0</span>, rootIndex), postorder.slice(<span class="hljs-number">0</span>, rootIndex));root.right = buildTree(inorder.slice(rootIndex + <span class="hljs-number">1</span>), postorder.slice(rootIndex));<span class="hljs-keyword">return</span> root;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 24 平衡二叉树 110</span><span class="hljs-comment">// 给定一个二叉树，判断它是否是高度平衡的二叉树。</span><span class="hljs-comment">// 本题中，一棵高度平衡二叉树定义为：</span><span class="hljs-comment">// 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：root = [3,9,20,null,null,15,7]</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：root = [1,2,2,3,3,null,null,4,4]</span><span class="hljs-comment">// 输出：false</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：root = []</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 解法一</span><span class="hljs-keyword">var</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(!root || root.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">const</span> maxLeft = getMaxLevel(root.left);    <span class="hljs-keyword">const</span> maxRight = getMaxLevel(root.right);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(maxLeft - maxRight) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMaxLevel</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> max = <span class="hljs-number">1</span>;    <span class="hljs-keyword">const</span> dp = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, l</span>) </span>&#123;        <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right)  max = <span class="hljs-built_in">Math</span>.max(max, l);        <span class="hljs-keyword">if</span> (root.left) dp(root.left, l + <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (root.right) dp(root.right, l + <span class="hljs-number">1</span>);    &#125;    dp(root, <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> max;&#125;<span class="hljs-comment">// 解法二</span><span class="hljs-keyword">const</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-comment">// 获取当前节点高度的递归函数</span>    <span class="hljs-keyword">const</span> getH = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 返回左右节点的最大高度+1,（+1:根节点）</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(getH(root.left), getH(root.right)) + <span class="hljs-number">1</span>;    &#125;;    <span class="hljs-comment">// 能递归到达这里，这个子树肯定是平衡二叉树</span>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 平衡二叉树的条件：</span>    <span class="hljs-keyword">return</span> (        <span class="hljs-comment">// 1. 根节点的左右节点高度差不超过1</span>        <span class="hljs-built_in">Math</span>.abs(getH(root.left) - getH(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp;        <span class="hljs-comment">// 2. 左子树是平衡二叉树</span>        isBalanced(root.left) &amp;&amp;        <span class="hljs-comment">// 3. 右子树是平衡二叉树</span>        isBalanced(root.right)    );&#125;;<span class="hljs-comment">// 解法三</span><span class="hljs-keyword">var</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">return</span> balanced(root) !== -<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">var</span> balanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">const</span> left = balanced(node.left)    <span class="hljs-keyword">const</span> right = balanced(node.right)    <span class="hljs-keyword">if</span> (left === -<span class="hljs-number">1</span> || right === -<span class="hljs-number">1</span> || <span class="hljs-built_in">Math</span>.abs(left - right) &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 25 有序链表转换平衡二叉树 109</span><span class="hljs-comment">// 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span><span class="hljs-comment">// 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 给定的有序链表： [-10, -3, 0, 5, 9],</span><span class="hljs-comment">// 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><span class="hljs-comment">//       0</span><span class="hljs-comment">//      / \</span><span class="hljs-comment">//    -3   9</span><span class="hljs-comment">//    /   /</span><span class="hljs-comment">//  -10  5</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> sortedListToBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTree</span>(<span class="hljs-params">head, end</span>) </span>&#123;<span class="hljs-keyword">if</span> (head === end) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><span class="hljs-keyword">let</span> p1 = head; <span class="hljs-comment">// 慢指针，中间节点</span><span class="hljs-keyword">let</span> p2 = head; <span class="hljs-comment">// 快指针，结束节点</span><span class="hljs-keyword">while</span>(p2 !== end) &#123;p2 = p2.next;<span class="hljs-keyword">if</span> (p2 !== end) &#123;p1 = p1.next;p2 = p2.next;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(p1.val, getTree(head, p1), getTree(p1.next, end))&#125;<span class="hljs-keyword">return</span> getTree(head, <span class="hljs-literal">null</span>)&#125;;</code></pre><h3 id="26-路径总和"><a href="#26-路径总和" class="headerlink" title="26 路径总和"></a>26 路径总和</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 26-1 路径总和 Ⅰ 112</span><span class="hljs-comment">// 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</span><span class="hljs-comment">// 实例</span><span class="hljs-comment">// 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><span class="hljs-comment">// 输出：true</span><span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, sum</span>) </span>&#123;<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-literal">false</span>;<span class="hljs-keyword">const</span> dpt = <span class="hljs-function">(<span class="hljs-params">root, s</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right &amp;&amp; s === sum) &#123;res = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (root.left) &#123;dpt(root.left, s + root.left.val)&#125;<span class="hljs-keyword">if</span> (root.right) &#123;dpt(root.right, s + root.right.val)&#125;&#125;dpt(root, root.val);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 26-2 路径总和 ⅠⅠ 113</span><span class="hljs-comment">// 给你二叉树的根节点 root 和一个整数目标和 targetSum</span><span class="hljs-comment">// 找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</span><span class="hljs-comment">// 实例1：</span><span class="hljs-comment">// 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><span class="hljs-comment">// 输出：[[5,4,11,2],[5,8,4,5]]</span><span class="hljs-keyword">var</span> pathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, targetSum</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> dp = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, arr</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;<span class="hljs-keyword">const</span> sum = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + cur);<span class="hljs-keyword">if</span> (sum == targetSum) &#123;res.push(arr);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (root.left) dp(root.left, [...arr, root.left.val]);<span class="hljs-keyword">if</span> (root.right) dp(root.right, [...arr, root.right.val]);&#125;dp(root, [root.val]);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 27  填充每个节点的下一个右侧节点指针 116</span><span class="hljs-comment">// 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。</span><span class="hljs-comment">// 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><span class="hljs-comment">// 初始状态下，所有 next 指针都被设置为 NULL。</span><span class="hljs-comment">// 实例1：</span><span class="hljs-comment">// 输入：root = [1,2,3,4,5,6,7]</span><span class="hljs-comment">// 输出：[1,#,2,3,#,4,5,6,7,#]</span><span class="hljs-comment">// 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#x27;#&#x27; 标志着每一层的结束。</span><span class="hljs-comment">// 进阶：</span><span class="hljs-comment">// 1. 你只能使用常量级额外空间。</span><span class="hljs-comment">// 2. 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-comment">// 解法一: 广度遍历</span><span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">let</span> len = stack.length;<span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<span class="hljs-keyword">while</span>(len) &#123;<span class="hljs-keyword">const</span> item = stack.shift();<span class="hljs-keyword">if</span> (item &amp;&amp; item.left) stack.push(item.left);<span class="hljs-keyword">if</span> (item &amp;&amp; item.right) stack.push(item.right);<span class="hljs-keyword">if</span> (pre) pre.next = item;pre = item;len--;&#125;&#125;<span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 解法二: 递归 </span><span class="hljs-comment">// 解法二更符合题目中进阶的要求</span><span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (root.left) root.left.next = root.right;<span class="hljs-keyword">if</span> (root.right &amp;&amp; root.next) root.right.next = root.next.left;connect(root.left);connect(root.right);<span class="hljs-keyword">return</span> root;&#125;;</code></pre><h2 id="三-数组"><a href="#三-数组" class="headerlink" title="三 数组"></a>三 数组</h2><p>1 全排列 ——（给定一个 没有重复 nums，返回其所有可能的全排列）<br>2 全排列II ——（给定一个 可能重复 的数组 nums ，返回所有不重复的全排列）<br>3 子集 ——（给你一个整数数组 nums，返回所有子集数组）<br>4 子集II ——（给定一个可能重复数组 nums，返回所有子集数组）<br>5 组合总和 ——（从无重复数组 nums 中找到和 为target 的所有子数组）<br>6 组合总和II ——（从可能重复数组 nums 中找到和 为target 的所有子数组）<br>7 组合 ——（给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合）<br>8 优美的排列<br>9 优美的排列II<br>10 电话号码的字母组合 —— (从一个仅包含数字2-9的字符串，返回所有它能表示的字母组合)<br>11 括号生成 —— (数字 n 代表生成括号的对数，找到所有 有效的 括号组合)<br>12 盛最多水的容器 ——（从数组中找到 盛最多水的 两个值）<br>13 三数之和 ——（三数之和为0）<br>14 删除有序数组中的重复项<br>15 加一<br>16 移动零 —— （把数组 nums 的所有 0 移动到数组的末尾）<br>17 最小栈 —— （设计一个栈，支持push/pop/top/操作，以及检索到最小元素的栈）<br>18 跳跃游戏 —— （nums元素代表可以跳跃的最大长度，判断是否能够到达最后一个下标）<br>19 跳跃游戏 II —— （nums元素代表可以跳跃的最大长度，判断是否能够到达最后一个下标）<br>20 最大子序和 —— （从数组中找到最大和的连续子数组的和）<br>21 最接近的三数之和 —— （找出 nums 中的三个整数的和与 target 最接近）<br>22 四数之和<br>23 字母异位词分组 —— 字符串数组，将包含相同字母项组合在一起<br>24 最长连续递增序列 —— 找到数组中找到 最长且 连续递增 的子序列<br>25 最长递增子序列 —— 找到其中最长严格递增子序列的长度<br>26 寻找两个正序数组的中位数 - 找到两个正序数组的中位数<br>27 和为K的子数组 —— 找到数组中和为 k 的连续的子数组的个数<br>28 两数之和 II - 输入有序数组 —— 升序的有序数组中找到和为target的目标<br>29 合并区间 —— 合并二维数组中区间重复的项<br>30 插入区间 —— 将一个区间数组 插入 到另一个 二维区间数组中<br>31 搜索旋转排序数组 —— 从已排序的数组中找到 指定的值<br>32 在排序数组中查找元素的第一个和最后一个位置<br>33 下一个排列 —— 找到数组的下一个更大的值<br>34 旋转图像<br>35 螺旋矩阵 —— 把二维数组(m * n) 按照 顺时针螺旋顺序 旋转</p><h3 id="1-全排列"><a href="#1-全排列" class="headerlink" title="1 全排列"></a>1 全排列</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 全排列 46</span><span class="hljs-comment">// 给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: [1,2,3]</span><span class="hljs-comment">// 输出:</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [1,2,3],</span><span class="hljs-comment">//   [1,3,2],</span><span class="hljs-comment">//   [2,1,3],</span><span class="hljs-comment">//   [2,3,1],</span><span class="hljs-comment">//   [3,1,2],</span><span class="hljs-comment">//   [3,2,1]</span><span class="hljs-comment">// ]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 时间复杂度：O(!n) ; !n = 1 x 2 x 3 x ... x (n-1) x n</span><span class="hljs-comment">// 空间复杂度：O(n)</span><span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> backtrck = <span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (path.length === nums.length) &#123;res.push(path);<span class="hljs-keyword">return</span>;&#125;nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (path.includes(n)) <span class="hljs-keyword">return</span>;backtrck(path.concat(n));&#125;)&#125;backtrck([]);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 2 全排列II 47</span><span class="hljs-comment">// 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,1,2]</span><span class="hljs-comment">// 输出：</span><span class="hljs-comment">// [[1,1,2],</span><span class="hljs-comment">//  [1,2,1],</span><span class="hljs-comment">//  [2,1,1]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [1,2,3]</span><span class="hljs-comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><span class="hljs-keyword">var</span> permuteUnique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">const</span> len = nums.length;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> used = [];nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">deepStack</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (deepStack.length === len) &#123;res.push(deepStack.slice())<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-comment">// 当前选项与上一项相同、且上一项存在、且没有被使用过，则忽略</span><span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] === nums[i] &amp;&amp; i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 使用过便不再使用</span>deepStack.push(nums[i])used[i] = <span class="hljs-literal">true</span>backtrack(deepStack)deepStack.pop()used[i] = <span class="hljs-literal">false</span>&#125;&#125;backtrack([])<span class="hljs-keyword">return</span> res&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3 子集 78</span><span class="hljs-comment">// 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</span><span class="hljs-comment">// 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,2,3]</span><span class="hljs-comment">// 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><span class="hljs-comment">// 解法一： 回溯</span><span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-comment">// 时间复杂度：O(2^n) 因为每个元素都有两种可能（存在或不存在）</span>    <span class="hljs-comment">// 空间复杂度：O(n)</span><span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, len, startIndex</span>) </span>&#123;<span class="hljs-keyword">if</span> (arr.length === len) &#123;res.push(arr);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = startIndex; index &lt; nums.length; index++) &#123;backtrack([...arr, nums[index]], len, index + <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (i &lt;= nums.length) &#123;backtrack([], i, <span class="hljs-number">0</span>);i++;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二 迭代 动态规划</span><span class="hljs-comment">// 重复将新的元素加入到上一个结果集中的每个子集当中去</span><span class="hljs-comment">// 形成n个新的子集，再全部加入到结果集中去</span><span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [[]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<span class="hljs-keyword">let</span> len = res.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)&#123;<span class="hljs-keyword">let</span> sub = res[j].slice();sub.push(nums[i]);res.push(sub);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法三 递归</span><span class="hljs-keyword">const</span> subsets = <span class="hljs-function">(<span class="hljs-params">nums</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">index, list</span>) =&gt;</span> &#123;res.push(list.slice());     <span class="hljs-comment">// 调用子递归前，加入解集</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; nums.length; i++) &#123; <span class="hljs-comment">// 枚举出所有可选的数</span>list.push(nums[i]);       <span class="hljs-comment">// 选这个数</span>dfs(i + <span class="hljs-number">1</span>, list);         <span class="hljs-comment">// 基于选这个数，继续递归，传入的是i+1，不是index+1</span>list.pop();               <span class="hljs-comment">// 撤销选这个数</span>&#125;&#125;;dfs(<span class="hljs-number">0</span>, []);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 4 子集II  90.</span><span class="hljs-comment">// 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</span><span class="hljs-comment">// 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,2,2]</span><span class="hljs-comment">// 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><span class="hljs-keyword">var</span> subsetsWithDup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length==<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> [nums];&#125;<span class="hljs-keyword">if</span> (nums.length==<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> [[],nums];&#125;nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 先排序</span><span class="hljs-keyword">let</span> result = [[]]; <span class="hljs-comment">// 记录全部子数组</span><span class="hljs-keyword">let</span> lastLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录上一个元素添加前，result的长度</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<span class="hljs-comment">// 当遇到重复元素时，从上一个元素添加前</span><span class="hljs-comment">// result的长度处，开始每一个子数组都添加该元素</span><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;j = lastLength;&#125;<span class="hljs-keyword">let</span> n = result.length;<span class="hljs-comment">// 保持lastLength的更新</span>lastLength = result.length;<span class="hljs-comment">// 如果不是重复元素，j初始为0,从result开头，每个子数组都添加上该元素</span><span class="hljs-keyword">for</span> (; j &lt; n; j++)&#123;result.push([...result[j],nums[i]])&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-comment">// 解法二 </span><span class="hljs-keyword">var</span> subsetsWithDup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> n = nums.length;nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> a - b&#125;);<span class="hljs-keyword">let</span> tmpPath = [];<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> hash = &#123;&#125;<span class="hljs-keyword">let</span> backtrack = <span class="hljs-function">(<span class="hljs-params">tmpPath,start</span>) =&gt;</span> &#123;res.push(tmpPath);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start;i &lt; n;i++)&#123;<span class="hljs-keyword">if</span>(hash[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; !hash[i-<span class="hljs-number">1</span>] &amp;&amp; nums[i-<span class="hljs-number">1</span>] == nums[i])) <span class="hljs-keyword">continue</span>;hash[i] = <span class="hljs-literal">true</span>;tmpPath.push(nums[i]);backtrack(tmpPath.slice(),i+<span class="hljs-number">1</span>);hash[i] = <span class="hljs-literal">false</span>;tmpPath.pop();&#125; &#125;backtrack(tmpPath,<span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 5 组合总和 39</span><span class="hljs-comment">// 给定一个无重复元素的数组 candidates 和一个目标数 target </span><span class="hljs-comment">// 找出 candidates 中所有可以使数字和为 target 的组合。</span><span class="hljs-comment">// candidates 中的数字可以无限制重复被选取。</span><span class="hljs-comment">// 说明：</span><span class="hljs-comment">// 所有数字（包括 target）都是正整数。</span><span class="hljs-comment">// 解集不能包含重复的组合。 </span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：candidates = [2,3,6,7], target = 7,</span><span class="hljs-comment">// 所求解集为：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [7],</span><span class="hljs-comment">//   [2,2,3]</span><span class="hljs-comment">// ]</span><span class="hljs-keyword">var</span> combinationSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums,target</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> dfs = <span class="hljs-function">(<span class="hljs-params">subArr, sum, start</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(sum &gt; target) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(sum  == target)&#123;<span class="hljs-comment">//这里不能直接push subArr这个数组，对于js这门语言来说，可以充分利用js的...运算符</span>res.push([...subArr]);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i  = start ; i &lt; nums.length ; i++)&#123;<span class="hljs-keyword">let</span> temp = sum;sum = sum + nums[i];subArr.push(nums[i]);dfs(subArr, sum,i);<span class="hljs-comment">//回到之前的状态，对于数组来讲就是pop，对于sum来讲可以用一个变量来记录以前的值</span>subArr.pop(nums[i]);sum = temp;&#125;&#125;dfs([], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二</span><span class="hljs-keyword">var</span> combinationSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) </span>&#123;<span class="hljs-keyword">let</span> n = candidates.length;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> tmpPath = [];<span class="hljs-keyword">let</span> backtrack = <span class="hljs-function">(<span class="hljs-params">tmpPath,target,start</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;res.push(tmpPath);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start;i &lt; n;i++)&#123;tmpPath.push(candidates[i]);backtrack(tmpPath.slice(),target - candidates[i],i);tmpPath.pop();&#125;&#125;backtrack(tmpPath, target, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="6-组合总和-II"><a href="#6-组合总和-II" class="headerlink" title="6 组合总和 II"></a>6 组合总和 II</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 6 组合总和 II 40</span><span class="hljs-comment">// 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><span class="hljs-comment">// candidates 中的每个数字在每个组合中只能使用一次。</span><span class="hljs-comment">// 说明：</span><span class="hljs-comment">// 所有数字（包括目标数）都是正整数。</span><span class="hljs-comment">// 解集不能包含重复的组合。 </span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><span class="hljs-comment">// 所求解集为:</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [1, 7],</span><span class="hljs-comment">//   [1, 2, 5],</span><span class="hljs-comment">//   [2, 6],</span><span class="hljs-comment">//   [1, 1, 6]</span><span class="hljs-comment">// ]</span><span class="hljs-keyword">var</span> combinationSum2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) </span>&#123;<span class="hljs-keyword">let</span> n = candidates.length;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> tmpPath = [];candidates = candidates.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> a - b&#125;)<span class="hljs-keyword">let</span> backtrack = <span class="hljs-function">(<span class="hljs-params">tmpPath,target,start</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;res.push(tmpPath);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start;i &lt; n;i++)&#123;<span class="hljs-keyword">if</span>(target &lt; candidates[i]) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(i &gt; start &amp;&amp; candidates[i-<span class="hljs-number">1</span>] == candidates[i]) <span class="hljs-keyword">continue</span>;tmpPath.push(candidates[i]);backtrack(tmpPath.slice(),target - candidates[i],i + <span class="hljs-number">1</span>);tmpPath.pop();&#125;&#125;backtrack(tmpPath,target,<span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 7 组合 77</span><span class="hljs-comment">// 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: n = 4, k = 2</span><span class="hljs-comment">// 输出:</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [2,4],</span><span class="hljs-comment">//   [3,4],</span><span class="hljs-comment">//   [2,3],</span><span class="hljs-comment">//   [1,2],</span><span class="hljs-comment">//   [1,3],</span><span class="hljs-comment">//   [1,4],</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 解法一 动态规划</span><span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;<span class="hljs-keyword">var</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;dp[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k+<span class="hljs-number">1</span>);dp[i][<span class="hljs-number">0</span>] = [[]];&#125;<span class="hljs-built_in">console</span>.log(dp);<span class="hljs-comment">// i：1~n</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-comment">//j：1～i/k</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;j &lt;= i &amp;&amp; j &lt;= k ;j++)&#123;dp[i][j] = [];<span class="hljs-comment">// 从 i-1 个里选 j 个</span><span class="hljs-comment">// 即从上题解法的：从 n-1 个里选 k个</span><span class="hljs-keyword">if</span>(i &gt; j)&#123;<span class="hljs-keyword">var</span> tmpA = dp[i-<span class="hljs-number">1</span>][j];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> t = <span class="hljs-number">0</span>;t&lt;tmpA.length;t++)&#123;dp[i][j].push(tmpA[t]);&#125;&#125;<span class="hljs-comment">// 从 i-1 个里选 j-1个</span><span class="hljs-keyword">var</span> tmpB = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> z = <span class="hljs-number">0</span>; z &lt; tmpB.length; z++)&#123;<span class="hljs-comment">// 这里注意不能修改dp[i-1][j-1]的原数组元素，需要深拷贝</span><span class="hljs-keyword">var</span> tmpC = [].concat(tmpB[z]);tmpC.push(i);dp[i][j].push(tmpC);&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[n][k];&#125;;<span class="hljs-comment">// 解法二：迭代回溯</span><span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;<span class="hljs-keyword">var</span> result = [];<span class="hljs-keyword">var</span> subresult = [];<span class="hljs-comment">// 初始化k个数字的临时组合各个元素为0</span><span class="hljs-comment">// 便于++对应 n的1，2，3，4..n</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; r &lt; k; r++)&#123;subresult[r] = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// n的总个数达不到k组合的个数 不可能实现</span><span class="hljs-keyword">if</span>(n &lt; k)&#123;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">// 迭代索引</span><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 当前数字加一 对于回溯中 subresult push 一个新的i 即为上一个i+1</span>subresult[i]++;<span class="hljs-comment">// 当i循环到n时，此时 i=n+1 </span><span class="hljs-comment">// i-- 对应回溯的函数调用执行栈的逆序出栈 即回到上一层的组合状态操作</span><span class="hljs-keyword">if</span>(subresult[i] &gt; n)&#123;i--;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == k -<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 索引从0开始 i == k-1 相等于 回溯i从1开始后i==k 的情况</span>result.push(subresult.slice(<span class="hljs-number">0</span>));&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 对于回溯外层for循环的下一层i操作 即start</span>++i;<span class="hljs-comment">// 相当于回溯的pop操作 去掉新加的值 退回上一层的值重新递归 此处为迭代</span>subresult[i] = subresult[i-<span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-comment">// 解法三 </span><span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;<span class="hljs-keyword">var</span> result = [];<span class="hljs-keyword">var</span> subresult = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineSub</span>(<span class="hljs-params">start,subresult</span>)</span>&#123;<span class="hljs-keyword">if</span>(subresult.length == k)&#123;result.push(subresult.slice(<span class="hljs-number">0</span>));<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">var</span> len = subresult.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i= start;i&lt;=n-(k-len)+<span class="hljs-number">1</span>;i++)&#123;subresult.push(i);combineSub(i+<span class="hljs-number">1</span>,subresult);subresult.pop();            &#125;   &#125;combineSub(<span class="hljs-number">1</span>,subresult);<span class="hljs-keyword">return</span> result;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 8 优美的排列 526</span><span class="hljs-comment">// 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组</span><span class="hljs-comment">// 使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</span><span class="hljs-comment">// 第 i 位的数字能被 i 整除</span><span class="hljs-comment">// i 能被第 i 位上的数字整除</span><span class="hljs-comment">// 现在给定一个整数 N，请问可以构造多少个优美的排列？</span><span class="hljs-comment">// 示例1:</span><span class="hljs-comment">// 输入: 2</span><span class="hljs-comment">// 输出: 2</span><span class="hljs-comment">// 解释: </span><span class="hljs-comment">// 第 1 个优美的排列是 [1, 2]:</span><span class="hljs-comment">//   第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除</span><span class="hljs-comment">//   第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</span><span class="hljs-comment">// 第 2 个优美的排列是 [2, 1]:</span><span class="hljs-comment">//   第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除</span><span class="hljs-comment">//   第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除</span><span class="hljs-comment">// 说明:</span><span class="hljs-comment">// N 是一个正整数，并且不会超过15。</span><span class="hljs-keyword">var</span> countArrangement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<span class="hljs-comment">// visited[num]表示num是否被使用</span><span class="hljs-comment">// 每次循环都通过visited去找下一个符合要求的数字 找到后索引值加一</span><span class="hljs-comment">// 一个for循环中每个数字只使用一次 使用完成以后需要释放 即visited[num] = false</span><span class="hljs-comment">// arr.fill(value[, start[, end]])</span><span class="hljs-comment">// value 填充值</span><span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(N+<span class="hljs-number">1</span>).fill(<span class="hljs-literal">false</span>);<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> dfs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>&#123;<span class="hljs-keyword">if</span> (index &gt; N) &#123;++res;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>; num &lt;= N; ++num) &#123;<span class="hljs-keyword">if</span> (!visited[num] &amp;&amp; (num % index === <span class="hljs-number">0</span> || index % num === <span class="hljs-number">0</span>)) &#123;visited[num] = <span class="hljs-literal">true</span>;dfs(index+<span class="hljs-number">1</span>)visited[num] = <span class="hljs-literal">false</span>;&#125;&#125;&#125; dfs(<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 9 优美的排列II 667</span><span class="hljs-comment">// 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数</span><span class="hljs-comment">// 并同时满足下述条件：</span><span class="hljs-comment">// 假设该列表是 answer = [a1, a2, a3, ... , an] </span><span class="hljs-comment">// 那么列表 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数。</span><span class="hljs-comment">// 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：n = 3, k = 1</span><span class="hljs-comment">// 输出：[1, 2, 3]</span><span class="hljs-comment">// 解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：n = 3, k = 2</span><span class="hljs-comment">// 输出：[1, 3, 2]</span><span class="hljs-comment">// 解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2</span><span class="hljs-comment">// 提示：</span><span class="hljs-comment">// 1 &lt;= k &lt; n &lt;= 104</span><span class="hljs-keyword">var</span> constructArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, k</span>) </span>&#123;<span class="hljs-comment">// 寻找规律：</span><span class="hljs-comment">// 使用k+1个数字，即可组成k个差值，剩余的部分直接使用差值为1顺序填充即可</span><span class="hljs-comment">// [1, 1**+k**, 1+k**-(k-1), 1+k-(k-1)+(k-1-1)**,,,]</span><span class="hljs-keyword">let</span> result = [<span class="hljs-number">1</span>];<span class="hljs-keyword">let</span> i = k;<span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// true为正，false为负</span><span class="hljs-keyword">while</span> (result.length &lt;= k) &#123;num = flag ? num + i : num - i;result.push(num);i--;flag = !flag;&#125;<span class="hljs-comment">// 基数已经准备好，进行剩余部分的填充</span>num = result.length + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (num &lt;= n) &#123;result.push(num++);&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 10 电话号码的字母组合 17</span><span class="hljs-comment">// 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</span><span class="hljs-comment">// 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：digits = &quot;23&quot;</span><span class="hljs-comment">// 输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：digits = &quot;&quot;</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：digits = &quot;2&quot;</span><span class="hljs-comment">// 输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-function">(<span class="hljs-params">digits</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!digits.length) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> map = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;ghi&#x27;</span>, <span class="hljs-string">&#x27;jkl&#x27;</span>, <span class="hljs-string">&#x27;mno&#x27;</span>, <span class="hljs-string">&#x27;pqrs&#x27;</span>, <span class="hljs-string">&#x27;tuv&#x27;</span>, <span class="hljs-string">&#x27;wxyz&#x27;</span>];<span class="hljs-keyword">let</span> result = [];<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">str, index</span>) =&gt;</span> &#123;<span class="hljs-comment">// 1 如果单个字符串到底了，那就添加它</span><span class="hljs-keyword">if</span> (index === digits.length) &#123;result.push(str);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// 2 获取当前数字对应的字母</span><span class="hljs-keyword">const</span> currentStr = map[<span class="hljs-built_in">Number</span>(digits[index])];<span class="hljs-comment">// 3 遍历这串字母，将其添加到下一次遍历中，同时位置向后挪一</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; currentStr.length; i++) &#123;backtrack(str + currentStr[i], index + <span class="hljs-number">1</span>);&#125;&#125;;<span class="hljs-comment">// 回溯</span>backtrack(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-comment">// 解法二： 暴力枚举</span><span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-function">(<span class="hljs-params">digits</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!digits.length) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> map = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;ghi&#x27;</span>, <span class="hljs-string">&#x27;jkl&#x27;</span>, <span class="hljs-string">&#x27;mno&#x27;</span>, <span class="hljs-string">&#x27;pqrs&#x27;</span>, <span class="hljs-string">&#x27;tuv&#x27;</span>, <span class="hljs-string">&#x27;wxyz&#x27;</span>];<span class="hljs-keyword">let</span> result = map[<span class="hljs-built_in">Number</span>(digits[<span class="hljs-number">0</span>])].split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span> &#123;<span class="hljs-comment">// 1 设置 temp 获取当前的组合</span><span class="hljs-keyword">let</span> temp = [];<span class="hljs-comment">// 2 暴力遍历添加</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prev.length; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; next.length; j++) &#123;temp.push(prev[i] + next[j]);&#125;&#125;<span class="hljs-comment">// 3 返回拼接后的组合</span><span class="hljs-keyword">return</span> temp;&#125;;<span class="hljs-comment">// 遍历字符串</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; digits.length; i++) &#123;<span class="hljs-comment">// 1 获取下一项添加的</span><span class="hljs-keyword">const</span> next = map[<span class="hljs-built_in">Number</span>(digits[i])];<span class="hljs-comment">// 2 组合后返回给 result</span>result = backtrack(result, next);&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre><h3 id="11-括号生成-22"><a href="#11-括号生成-22" class="headerlink" title="11 括号生成 22"></a>11 括号生成 22</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 11 括号生成 22</span><span class="hljs-comment">// 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：n = 3</span><span class="hljs-comment">// 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><span class="hljs-comment">// 递归</span><span class="hljs-keyword">var</span> generateParenthesis = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">let</span> list = []<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span>(<span class="hljs-params">left, right, s</span>) </span>&#123;<span class="hljs-comment">//  终止条件：如果左右括弧都用完则结束</span><span class="hljs-keyword">if</span> (left === n &amp;&amp; right === n) &#123;list.push(s)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 如果左括弧未用完则继续增加左括弧</span><span class="hljs-keyword">if</span> (left &lt; n) &#123;generate(left + <span class="hljs-number">1</span>, right, s + <span class="hljs-string">&quot;(&quot;</span>)&#125;<span class="hljs-comment">// 如果右括弧少于左括弧则继续增加右括弧</span><span class="hljs-keyword">if</span> (left &gt; right) &#123;generate(left, right + <span class="hljs-number">1</span>, s + <span class="hljs-string">&quot;)&quot;</span>)&#125;&#125;generate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>)<span class="hljs-keyword">return</span> list&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 12 盛最多水的容器 11</span><span class="hljs-comment">// 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) </span><span class="hljs-comment">//在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)</span><span class="hljs-comment">// 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><span class="hljs-comment">// 说明：你不能倾斜容器。</span><span class="hljs-comment">// 输入：[1,8,6,2,5,4,8,3,7]</span><span class="hljs-comment">// 输出：49 </span><span class="hljs-comment">// 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：height = [1,1]</span><span class="hljs-comment">// 输出：1</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：height = [4,3,2,1,4]</span><span class="hljs-comment">// 输出：16</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：height = [1,2,1]</span><span class="hljs-comment">// 输出：2</span><span class="hljs-keyword">var</span> maxArea = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">height</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = height.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (left &lt; right) &#123;<span class="hljs-keyword">const</span> area = <span class="hljs-built_in">Math</span>.min(height[left], height[right]) * (right - left);res = <span class="hljs-built_in">Math</span>.max(res, area);<span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;left++;&#125; <span class="hljs-keyword">else</span> &#123;right--;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 13 三数之和 15</span><span class="hljs-comment">// 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c </span><span class="hljs-comment">// 使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</span><span class="hljs-comment">// 注意：答案中不可以包含重复的三元组。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [-1,0,1,2,-1,-4]</span><span class="hljs-comment">// 输出：[[-1,-1,2],[-1,0,1]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [0]</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-keyword">var</span> threeSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">let</span> arr = [...nums];arr = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<span class="hljs-keyword">if</span>(arr[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">2</span>; i++) &#123;<span class="hljs-keyword">const</span> target = <span class="hljs-number">0</span> - arr[i];<span class="hljs-keyword">let</span> p1 = i + <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> p2 = arr.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;<span class="hljs-keyword">if</span> (arr[p1] + arr[p2] === target) &#123;<span class="hljs-keyword">const</span> subArr = [arr[i], arr[p1], arr[p2]];<span class="hljs-keyword">if</span> (!isIncludes(res, subArr)) &#123;res.push(subArr);&#125;p1++;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[p1] + arr[p2] &lt; target) &#123;p1++;&#125; <span class="hljs-keyword">else</span> &#123;p2--;&#125;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">var</span> isIncludes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, subArr</span>) </span>&#123;<span class="hljs-keyword">if</span>(!arr.length) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> arr.some(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item[<span class="hljs-number">0</span>] === subArr[<span class="hljs-number">0</span>] &amp;&amp; item[<span class="hljs-number">1</span>] === subArr[<span class="hljs-number">1</span>] &amp;&amp; item[<span class="hljs-number">2</span>] === subArr[<span class="hljs-number">2</span>])&#125;<span class="hljs-comment">// 扩展:从长度为 n 的数组中找到 长度为 m 的所有子集</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSub</span>(<span class="hljs-params">nums, m</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length &lt; m) <span class="hljs-keyword">return</span> []; <span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> backtrck = <span class="hljs-function">(<span class="hljs-params">arr, i</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (arr.length === m) &#123;res.push(arr);<span class="hljs-keyword">return</span>;&#125;nums.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (index &gt; i) &#123;backtrck([...arr, item], index);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span>;&#125;&#125;)&#125;backtrck([], -<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 14 删除有序数组中的重复项 26</span><span class="hljs-comment">// 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</span><span class="hljs-comment">// 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><span class="hljs-comment">// 说明:</span><span class="hljs-comment">// 为什么返回数值是整数，但输出的答案是数组呢?</span><span class="hljs-comment">// 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><span class="hljs-comment">// 你可以想象内部操作如下:</span><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><span class="hljs-comment">// int len = removeDuplicates(nums);</span><span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><span class="hljs-comment">// for (int i = 0; i &lt; len; i++) &#123;</span><span class="hljs-comment">//     print(nums[i]);</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,1,2]</span><span class="hljs-comment">// 输出：2, nums = [1,2]</span><span class="hljs-comment">// 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 </span><span class="hljs-comment">// 不需要考虑数组中超出新长度后面的元素。</span><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> p2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (p2 &lt; nums.length) &#123;<span class="hljs-keyword">if</span> (nums[p1] !== nums[p2]) &#123;p1++;nums[p1] = nums[p2];&#125;p2++;&#125;<span class="hljs-keyword">while</span>(nums.length &gt; p1 + <span class="hljs-number">1</span>)&#123;nums.length--;&#125;<span class="hljs-comment">// 返回的是实际的长度，因为下标是从0开始的</span><span class="hljs-keyword">return</span> p1 + <span class="hljs-number">1</span>;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 15 加一 66</span><span class="hljs-comment">// 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</span><span class="hljs-comment">// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</span><span class="hljs-comment">// 你可以假设除了整数 0 之外，这个整数不会以零开头。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：digits = [1,2,3]</span><span class="hljs-comment">// 输出：[1,2,4]</span><span class="hljs-comment">// 解释：输入数组表示数字 123。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：digits = [4,3,2,1]</span><span class="hljs-comment">// 输出：[4,3,2,2]</span><span class="hljs-comment">// 解释：输入数组表示数字 4321。</span><span class="hljs-keyword">var</span> plusOne = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">digits</span>) </span>&#123;<span class="hljs-keyword">let</span> carry = <span class="hljs-literal">false</span>;digits[digits.length - <span class="hljs-number">1</span>] ++;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = digits.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-keyword">if</span>(carry) digits[i]++;carry = digits[i] &gt; <span class="hljs-number">9</span>;digits[i] %= <span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">if</span>(carry) digits.unshift(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> digits;&#125;;</code></pre><h3 id="16-移动零"><a href="#16-移动零" class="headerlink" title="16 移动零"></a>16 移动零</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 16 移动零 283</span><span class="hljs-comment">// 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: [0,1,0,3,12]</span><span class="hljs-comment">// 输出: [1,3,12,0,0]</span><span class="hljs-comment">// 说明:</span><span class="hljs-comment">// 必须在原数组上操作，不能拷贝额外的数组。</span><span class="hljs-comment">// 尽量减少操作次数。</span><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>;<span class="hljs-comment">// 把所有的非0移到前面</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 遇到非0项</span>nums[p] = nums[i]; <span class="hljs-comment">// 覆盖到p上</span>p++;    <span class="hljs-comment">// j后移</span>&#125;&#125;<span class="hljs-comment">// 剩下的位置赋为0</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = p; i &lt; nums.length; i++) &#123;nums[i] = <span class="hljs-number">0</span>;&#125;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 17 最小栈 155</span><span class="hljs-comment">// 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</span><span class="hljs-comment">// push(x) —— 将元素 x 推入栈中。</span><span class="hljs-comment">// pop() —— 删除栈顶的元素。</span><span class="hljs-comment">// top() —— 获取栈顶元素。</span><span class="hljs-comment">// getMin() —— 检索栈中的最小元素。</span><span class="hljs-keyword">var</span> MinStack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.stack = [];    <span class="hljs-built_in">this</span>.min_stack = [];&#125;;MinStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-built_in">this</span>.stack.push(val);    <span class="hljs-keyword">if</span> (val &lt;= <span class="hljs-built_in">this</span>.getMin() || <span class="hljs-built_in">this</span>.min_stack.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">this</span>.min_stack.push(val);    &#125;&#125;;MinStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> out = <span class="hljs-built_in">this</span>.stack.pop();    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getMin() == out) &#123;        <span class="hljs-built_in">this</span>.min_stack.pop();    &#125;&#125;;MinStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>];&#125;;MinStack.prototype.getMin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.min_stack[<span class="hljs-built_in">this</span>.min_stack.length - <span class="hljs-number">1</span>];&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 18 跳跃游戏 55</span><span class="hljs-comment">// 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</span><span class="hljs-comment">// 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><span class="hljs-comment">// 判断你是否能够到达最后一个下标。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [2,3,1,1,4]</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [3,2,1,0,4]</span><span class="hljs-comment">// 输出：false</span><span class="hljs-comment">// 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><span class="hljs-comment">// 解法一： 贪心算法</span><span class="hljs-keyword">var</span> canJump = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// maxStep 代表跳到的最远的距离</span><span class="hljs-keyword">let</span> maxStep = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<span class="hljs-comment">// 如果遍历的到的索引已经比最远能到到的距离还要大</span><span class="hljs-comment">// 说明根本没有机会再继续走下去</span><span class="hljs-keyword">if</span> (i &gt; maxStep) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;maxStep = <span class="hljs-built_in">Math</span>.max(maxStep, i + nums[i]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-comment">// 解法二：</span><span class="hljs-comment">// 1、起跳点：当前位置</span><span class="hljs-comment">// 2、最大可能：跳一次能影响的最大长度</span><span class="hljs-comment">// 3、return 起跳点+最大可能 &gt;= 终点</span><span class="hljs-keyword">var</span> canJump = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>;) &#123;<span class="hljs-comment">// i: 起跳点</span><span class="hljs-keyword">if</span>(nums[i] === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-keyword">let</span> n = nums[i];<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= nums[i]; j++) &#123;<span class="hljs-keyword">let</span> m = j + nums[i+j];<span class="hljs-keyword">if</span>(m &gt; n) &#123;n = m;index = j; <span class="hljs-comment">// 最大可能时的位移长度</span>&#125;&#125;<span class="hljs-keyword">if</span>(i + n &gt;= nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;i += index;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 19 跳跃游戏 II 45</span><span class="hljs-comment">// 给定一个非负整数数组，你最初位于数组的第一个位置。</span><span class="hljs-comment">// 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><span class="hljs-comment">// 你的目标是使用最少的跳跃次数到达数组的最后一个位置。</span><span class="hljs-comment">// 假设你总是可以到达数组的最后一个位置。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: [2,3,1,1,4]</span><span class="hljs-comment">// 输出: 2</span><span class="hljs-comment">// 解释: 跳到最后一个位置的最小跳跃数是 2。</span><span class="hljs-comment">//      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: [2,3,0,1,4]</span><span class="hljs-comment">// 输出: 2</span><span class="hljs-comment">// 贪心算法 动态规划</span><span class="hljs-comment">// 从第一项出发，用最少的步数跳到最后一项</span><span class="hljs-comment">// (1)遍历一个可抵达的区间，从中选出能跳最远的点</span><span class="hljs-comment">// (2)就有了新的可抵达的区间，然后跳跃一次，进入新的区间继续遍历寻求最优解</span><span class="hljs-keyword">var</span> jump = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 记录当前能去到的最远的位置</span><span class="hljs-comment">// 遍历每个点都会求能跳到的最远位置，与它比较，如果把它大就更新它</span><span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// farthestPos</span><span class="hljs-keyword">let</span> p2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// endOfCanReach</span><span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;p1 = <span class="hljs-built_in">Math</span>.max(p1, i + nums[i]);<span class="hljs-keyword">if</span> (i === p2) &#123; <span class="hljs-comment">// 可抵达区间的右端位置</span>p2 = p1;res++;&#125;<span class="hljs-comment">// 一旦新的可抵达区间触碰到nums数组的边界，则直接break，不用对区间的点遍历了</span><span class="hljs-keyword">if</span> (p2 &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 20 最大子序和 53</span><span class="hljs-comment">// 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素）</span><span class="hljs-comment">// 返回其最大和。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><span class="hljs-comment">// 输出：6</span><span class="hljs-comment">// 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 </span><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> ans = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<span class="hljs-comment">// if(sum &gt; 0) &#123; 可以写成这样</span><span class="hljs-keyword">if</span>(sum + num &gt; num )&#123;sum = sum + num;&#125; <span class="hljs-keyword">else</span> &#123;sum = num;&#125;ans = <span class="hljs-built_in">Math</span>.max(ans, sum);&#125;;<span class="hljs-keyword">return</span> ans;&#125;;</code></pre><h3 id="21-最接近的三数之和"><a href="#21-最接近的三数之和" class="headerlink" title="21 最接近的三数之和"></a>21 最接近的三数之和</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 21 最接近的三数之和 16</span><span class="hljs-comment">// 给定一个包括 n 个整数的数组 nums 和 一个目标值 target,找出 nums 中的三个整数</span><span class="hljs-comment">// 使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</span><span class="hljs-comment">// 示例：</span><span class="hljs-comment">// 输入：nums = [-1,2,1,-4], target = 1</span><span class="hljs-comment">// 输出：2</span><span class="hljs-comment">// 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><span class="hljs-keyword">var</span> threeSumClosest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<span class="hljs-keyword">let</span> res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<span class="hljs-keyword">let</span> p1 = i + <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> p2 = nums.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;<span class="hljs-keyword">const</span> sum = nums[i] + nums[p1] + nums[p2];<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(target - sum) &lt; <span class="hljs-built_in">Math</span>.abs(target - res)) &#123;res = sum;&#125;<span class="hljs-keyword">if</span> (target &gt; sum) &#123;p1++;&#125; <span class="hljs-keyword">else</span> &#123;p2--;&#125;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 22 四数之和 18</span><span class="hljs-comment">// 给定一个包含 n 个整数的数组 nums 和一个目标值 target</span><span class="hljs-comment">// 判断 nums 中是否存在四个元素 a，b，c 和 d </span><span class="hljs-comment">// 使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><span class="hljs-comment">// 注意：答案中不可以包含重复的四元组。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,0,-1,0,-2,2], target = 0</span><span class="hljs-comment">// 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [], target = 0</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-keyword">var</span> fourSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;    <span class="hljs-keyword">const</span> res = [&#123;&#125;, []];    nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = nums.length, key; i &lt; len - <span class="hljs-number">3</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len - <span class="hljs-number">2</span>; j++) &#123;            <span class="hljs-keyword">let</span> l = j + <span class="hljs-number">1</span>;            <span class="hljs-keyword">let</span> r = len - <span class="hljs-number">1</span>;            <span class="hljs-keyword">const</span> sum = nums[i] + nums[j];            <span class="hljs-keyword">while</span> (l &lt; r) &#123;                <span class="hljs-keyword">if</span> (sum + nums[l] + nums[r] === target) &#123;                    <span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;&#x27;</span> + nums[i] + nums[j] + nums[l] + nums[r];                    <span class="hljs-keyword">if</span> (!res[<span class="hljs-number">0</span>][key]) &#123;                        res[<span class="hljs-number">0</span>][key] = <span class="hljs-number">1</span>;                        res[<span class="hljs-number">1</span>].push([nums[i], nums[j], nums[l], nums[r]]);                    &#125;                    r--;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (!(sum + nums[l] + nums[r] &gt; target &amp;&amp; r--)) &#123;                        l++;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res[<span class="hljs-number">1</span>];&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 23 字母异位词分组 49</span><span class="hljs-comment">// 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><span class="hljs-comment">// 输出:</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><span class="hljs-comment">//   [&quot;nat&quot;,&quot;tan&quot;],</span><span class="hljs-comment">//   [&quot;bat&quot;]</span><span class="hljs-comment">// ]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">strs</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) </span>&#123;<span class="hljs-keyword">const</span> hashTable = &#123;&#125;;<span class="hljs-comment">// 这个方法需要排序，因此不是很优，但是很直观，容易想到</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<span class="hljs-keyword">const</span> str = strs[i];<span class="hljs-keyword">const</span> key = str.split(<span class="hljs-string">&quot;&quot;</span>).sort().join(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">if</span> (!hashTable[key]) &#123;hashTable[key] = [str];&#125; <span class="hljs-keyword">else</span> &#123;hashTable[key].push(str);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(hashTable);&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 24 最长连续递增序列 674</span><span class="hljs-comment">// 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</span><span class="hljs-comment">// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定</span><span class="hljs-comment">// 如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] </span><span class="hljs-comment">// 那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,3,5,4,7]</span><span class="hljs-comment">// 输出：3</span><span class="hljs-comment">// 解释：最长连续递增序列是 [1,3,5], 长度为3。</span><span class="hljs-comment">// 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [2,2,2,2,2]</span><span class="hljs-comment">// 输出：1</span><span class="hljs-comment">// 解释：最长连续递增序列是 [2], 长度为1。</span><span class="hljs-comment">// 解法一：贪心算法</span><span class="hljs-keyword">var</span> findLengthOfLCIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> n = nums.length;<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span><span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (right &lt; n) &#123;<span class="hljs-keyword">if</span> (nums[right] &gt; nums[left])&#123;maxLen++;&#125; <span class="hljs-keyword">else</span> &#123;maxLen = <span class="hljs-number">1</span>;&#125;left++;right++;res = <span class="hljs-built_in">Math</span>.max(res, maxLen);&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二：双指针</span><span class="hljs-comment">// var findLengthOfLCIS = function(nums) &#123;</span><span class="hljs-comment">// if(!nums.length) return 0;</span><span class="hljs-comment">// let res = 0;</span><span class="hljs-comment">// let left = 0;</span><span class="hljs-comment">// let right = 0;</span><span class="hljs-comment">// while(right &lt; nums.length) &#123;</span><span class="hljs-comment">// while(nums[right + 1] &gt; nums[right]) &#123;</span><span class="hljs-comment">// right++;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// const sub = nums.slice(left, right + 1);</span><span class="hljs-comment">// res = Math.max(res, sub.length);</span><span class="hljs-comment">// right++;</span><span class="hljs-comment">// left = right;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return res;</span><span class="hljs-comment">// &#125;</span></code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 25 最长递增子序列 300</span><span class="hljs-comment">// 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span><span class="hljs-comment">// 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [10,9,2,5,3,7,101,18]</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [0,1,0,3,2,3]</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [7,7,7,7,7,7,7]</span><span class="hljs-comment">// 输出：1</span><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">var</span> lengthOfLIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> temArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums.length);<span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i &lt; nums.length) &#123;temArr[i] = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">let</span> m = i - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(m &gt; -<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (nums[i] &gt; nums[m] &amp;&amp; temArr[m] + <span class="hljs-number">1</span> &gt; temArr[i]) &#123;temArr[i] = temArr[m] + <span class="hljs-number">1</span>;res = <span class="hljs-built_in">Math</span>.max(res, temArr[i])&#125;m--;&#125;&#125;i++;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="26-寻找两个正序数组的中位数"><a href="#26-寻找两个正序数组的中位数" class="headerlink" title="26 寻找两个正序数组的中位数"></a>26 寻找两个正序数组的中位数</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 26 寻找两个正序数组的中位数 4</span><span class="hljs-comment">// 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2</span><span class="hljs-comment">// 请你找出并返回这两个正序数组的 中位数 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums1 = [1,3], nums2 = [2]</span><span class="hljs-comment">// 输出：2.00000</span><span class="hljs-comment">// 解释：合并数组 = [1,2,3] ，中位数 2</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums1 = [1,2], nums2 = [3,4]</span><span class="hljs-comment">// 输出：2.50000</span><span class="hljs-comment">// 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums1 = [0,0], nums2 = [0,0]</span><span class="hljs-comment">// 输出：0.00000</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：nums1 = [], nums2 = [1]</span><span class="hljs-comment">// 输出：1.00000</span><span class="hljs-comment">// 示例 5：</span><span class="hljs-comment">// 输入：nums1 = [2], nums2 = []</span><span class="hljs-comment">// 输出：2.00000</span><span class="hljs-comment">//  </span><span class="hljs-comment">// 提示：</span><span class="hljs-comment">// nums1.length == m</span><span class="hljs-comment">// nums2.length == n</span><span class="hljs-comment">// 0 &lt;= m &lt;= 1000</span><span class="hljs-comment">// 0 &lt;= n &lt;= 1000</span><span class="hljs-comment">// 1 &lt;= m + n &lt;= 2000</span><span class="hljs-comment">// -106 &lt;= nums1[i], nums2[i] &lt;= 106</span><span class="hljs-keyword">var</span> findMedianSortedArrays = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) </span>&#123;<span class="hljs-keyword">let</span> m = nums1.length;<span class="hljs-keyword">let</span> n = nums2.length;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> newArr = [];<span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;newArr.push(nums1[i++]);&#125; <span class="hljs-keyword">else</span> &#123;newArr.push(nums2[j++]);&#125;&#125;newArr = newArr.concat(i &lt; m ? nums1.slice(i) : nums2.slice(j));<span class="hljs-keyword">const</span> len = newArr.length;<span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> (newArr[len / <span class="hljs-number">2</span>] + newArr[len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> newArr[<span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>)];&#125;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 27 和为K的子数组 560</span><span class="hljs-comment">// 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</span><span class="hljs-comment">// 示例 1 :</span><span class="hljs-comment">// 输入:nums = [1,1,1], k = 2</span><span class="hljs-comment">// 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><span class="hljs-comment">// 说明 :</span><span class="hljs-comment">// 数组的长度为 [1, 20,000]。</span><span class="hljs-comment">// 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</span><span class="hljs-keyword">var</span> subarraySum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> sum1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> sum2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();map.set(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= nums.length; i++) &#123;sum1 += nums[i];sum2 = sum1 - k;<span class="hljs-keyword">if</span> (map.has(sum2)) &#123;res += map.get(sum2);&#125;<span class="hljs-keyword">let</span> sumCnt = map.get(sum1) || <span class="hljs-number">0</span>;map.set(sum1, sumCnt + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 28 两数之和 II - 输入有序数组 167</span><span class="hljs-comment">// 给定一个已按照 升序排列  的整数数组 numbers</span><span class="hljs-comment">// 请你从数组中找出两个数满足相加之和等于目标数 target 。</span><span class="hljs-comment">// 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。</span><span class="hljs-comment">// numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</span><span class="hljs-comment">// 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：numbers = [2,7,11,15], target = 9</span><span class="hljs-comment">// 输出：[1,2]</span><span class="hljs-comment">// 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：numbers = [2,3,4], target = 6</span><span class="hljs-comment">// 输出：[1,3]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：numbers = [-1,0], target = -1</span><span class="hljs-comment">// 输出：[1,2]</span><span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">numbers, target</span>) </span>&#123;<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length; i++) &#123;<span class="hljs-keyword">let</span> tmp = target - numbers[i]<span class="hljs-keyword">if</span> (map.has(tmp)) &#123;<span class="hljs-keyword">return</span> [map.get(tmp) + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>]&#125;map.set(numbers[i], i)&#125;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 29 合并区间 56</span><span class="hljs-comment">// 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]</span><span class="hljs-comment">// 请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><span class="hljs-comment">// 输出：[[1,6],[8,10],[15,18]]</span><span class="hljs-comment">// 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：intervals = [[1,4],[4,5]]</span><span class="hljs-comment">// 输出：[[1,5]]</span><span class="hljs-comment">// 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><span class="hljs-keyword">var</span> merge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) </span>&#123;<span class="hljs-keyword">if</span> (intervals.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<span class="hljs-keyword">const</span> mergeArr = [intervals[<span class="hljs-number">0</span>]];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<span class="hljs-keyword">const</span> item = intervals[i];<span class="hljs-keyword">const</span> last = mergeArr[mergeArr.length - <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (last[<span class="hljs-number">1</span>] &gt;= item[<span class="hljs-number">0</span>]) &#123;last[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(item[<span class="hljs-number">1</span>], last[<span class="hljs-number">1</span>]);&#125; <span class="hljs-keyword">else</span> &#123;mergeArr.push(item);&#125;&#125;<span class="hljs-keyword">return</span> mergeArr;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 30 插入区间 57</span><span class="hljs-comment">// 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</span><span class="hljs-comment">// 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span><span class="hljs-comment">// 输出：[[1,5],[6,9]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><span class="hljs-comment">// 输出：[[1,2],[3,10],[12,16]]</span><span class="hljs-comment">// 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：intervals = [], newInterval = [5,7]</span><span class="hljs-comment">// 输出：[[5,7]]</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：intervals = [[1,5]], newInterval = [2,3]</span><span class="hljs-comment">// 输出：[[1,5]]</span><span class="hljs-comment">// 示例 5：</span><span class="hljs-comment">// 输入：intervals = [[1,5]], newInterval = [2,7]</span><span class="hljs-comment">// 输出：[[1,7]]</span><span class="hljs-keyword">var</span> insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals, newInterval</span>) </span>&#123;<span class="hljs-keyword">if</span> (intervals.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [newInterval];<span class="hljs-comment">// 最左侧</span><span class="hljs-keyword">if</span> (newInterval[<span class="hljs-number">1</span>] &lt; intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &#123;<span class="hljs-keyword">return</span> [newInterval, ...intervals];&#125;<span class="hljs-comment">// 最右侧</span><span class="hljs-keyword">if</span> (newInterval[<span class="hljs-number">0</span>] &gt; intervals[intervals.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<span class="hljs-keyword">return</span> [...intervals, newInterval];&#125;<span class="hljs-keyword">let</span> leftSub = [];<span class="hljs-keyword">let</span> midSub = [];<span class="hljs-keyword">let</span> rifhtSub = [];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; i++) &#123;<span class="hljs-comment">// 左侧 有重叠</span><span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">0</span>] &amp;&amp; newInterval[<span class="hljs-number">0</span>] &lt;= intervals[i][<span class="hljs-number">1</span>]) &#123;midSub[<span class="hljs-number">0</span>] = intervals[i][<span class="hljs-number">0</span>];leftSub = intervals.slice(<span class="hljs-number">0</span>, i);&#125;<span class="hljs-comment">// 右侧 有重叠</span><span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>] &amp;&amp; newInterval[<span class="hljs-number">1</span>] &lt;= intervals[i][<span class="hljs-number">1</span>]) &#123;midSub[<span class="hljs-number">1</span>] = intervals[i][<span class="hljs-number">1</span>];rifhtSub = intervals.slice(i + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 左侧 无重叠，在区间中</span><span class="hljs-keyword">if</span> (intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>] &amp;&amp; newInterval[<span class="hljs-number">0</span>] &lt; intervals[i][<span class="hljs-number">0</span>]) &#123;midSub[<span class="hljs-number">0</span>] = newInterval[<span class="hljs-number">0</span>];leftSub = intervals.slice(<span class="hljs-number">0</span>, i);&#125;<span class="hljs-comment">// 右侧 无重叠，在区间中</span><span class="hljs-keyword">if</span> (intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">1</span>] &amp;&amp;  newInterval[<span class="hljs-number">1</span>] &lt; intervals[i][<span class="hljs-number">0</span>]) &#123;midSub[<span class="hljs-number">1</span>] = newInterval[<span class="hljs-number">1</span>];rifhtSub = intervals.slice(i);&#125;&#125;<span class="hljs-comment">// 超出左侧边界</span><span class="hljs-keyword">if</span> (newInterval[<span class="hljs-number">0</span>] &lt; intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &#123;midSub[<span class="hljs-number">0</span>] = newInterval[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 超出右侧边界</span><span class="hljs-keyword">if</span> (i === intervals.length - <span class="hljs-number">1</span> &amp;&amp; newInterval[<span class="hljs-number">1</span>] &gt; intervals[i][<span class="hljs-number">1</span>]) &#123;midSub[<span class="hljs-number">1</span>] = newInterval[<span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">return</span> [...leftSub, midSub, ...rifhtSub];&#125;;</code></pre><h3 id="31-搜索旋转排序数组"><a href="#31-搜索旋转排序数组" class="headerlink" title="31 搜索旋转排序数组"></a>31 搜索旋转排序数组</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 31 搜索旋转排序数组 I 33 / II 81</span><span class="hljs-comment">// 整数数组 nums 按升序排列，数组中的值 互不相同 。</span><span class="hljs-comment">// 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，</span><span class="hljs-comment">// 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</span><span class="hljs-comment">// （下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span><span class="hljs-comment">// 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，</span><span class="hljs-comment">// 则返回它的下标，否则返回 -1 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [4,5,6,7,0,1,2], target = 0</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [4,5,6,7,0,1,2], target = 3</span><span class="hljs-comment">// 输出：-1</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [1], target = 0</span><span class="hljs-comment">// 输出：-1</span><span class="hljs-keyword">var</span> search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> end = nums.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(start &lt;= end) &#123;<span class="hljs-keyword">const</span> mid = start + <span class="hljs-built_in">Math</span>.floor((end - start) / <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<span class="hljs-keyword">return</span> mid;&#125;<span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[start]) &#123;<span class="hljs-keyword">if</span> (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;end = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;start = mid + <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (target &lt;= nums[end] &amp;&amp; target &gt; nums[mid]) &#123;start = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;end = mid - <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;;<span class="hljs-comment">// 搜索旋转排序数组 II 81</span><span class="hljs-comment">// 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span><span class="hljs-comment">// 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，</span><span class="hljs-comment">// 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</span><span class="hljs-comment">// （下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] </span><span class="hljs-comment">// 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span><span class="hljs-comment">// 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。</span><span class="hljs-comment">// 如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [2,5,6,0,0,1,2], target = 0</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [2,5,6,0,0,1,2], target = 3</span><span class="hljs-comment">// 输出：false</span><span class="hljs-keyword">var</span> search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span><span class="hljs-keyword">let</span> end = nums.length - <span class="hljs-number">1</span><span class="hljs-keyword">while</span> (start &lt;= end) &#123;<span class="hljs-comment">// let mid = start + ((end - start) &gt;&gt; 1)</span><span class="hljs-keyword">let</span> mid = start + <span class="hljs-built_in">Math</span>.floor((end - start) / <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">if</span> (nums[start] &gt; nums[mid]) &#123; <span class="hljs-comment">// 左大于中, 最大值在左边</span><span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) &#123; start = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;end = mid - <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[start] &lt; nums[mid]) &#123;<span class="hljs-comment">// 左小于中, 说明左边是非递减的</span><span class="hljs-keyword">if</span> (nums[start] &lt;= target &amp;&amp; nums[mid] &gt; target) &#123;end = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;start = mid + <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 左等于中, 无法判断</span>start++;<span class="hljs-keyword">if</span> (nums[end] === nums[mid]) &#123;end--;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 32 在排序数组中查找元素的第一个和最后一个位置</span><span class="hljs-comment">// 给定一个按照升序排列的整数数组 nums，和一个目标值 target。</span><span class="hljs-comment">// 找出给定目标值在数组中的开始位置和结束位置。</span><span class="hljs-comment">// 如果数组中不存在目标值 target，返回 [-1, -1]。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [5,7,7,8,8,10], target = 8</span><span class="hljs-comment">// 输出：[3,4]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [5,7,7,8,8,10], target = 6</span><span class="hljs-comment">// 输出：[-1,-1]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [], target = 0</span><span class="hljs-comment">// 输出：[-1,-1]</span><span class="hljs-keyword">var</span> searchRange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span> (<span class="hljs-params">nums, target, flag</span>) </span>&#123;<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> end = nums.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (start &lt;= end) &#123;<span class="hljs-keyword">let</span> mid = start + (<span class="hljs-built_in">Math</span>.floor((end - start) / <span class="hljs-number">2</span>));<span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<span class="hljs-keyword">if</span> (flag) &#123;<span class="hljs-keyword">if</span> (mid === <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] !== target) &#123;<span class="hljs-keyword">return</span> mid;&#125;end = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (mid === nums.length - <span class="hljs-number">1</span> || nums[mid + <span class="hljs-number">1</span>] !== target) &#123;<span class="hljs-keyword">return</span> mid;&#125;start = mid + <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;end = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;start = mid + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> [search(nums, target, <span class="hljs-literal">true</span>), search(nums, target, <span class="hljs-literal">false</span>)]&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 33 下一个排列 31</span><span class="hljs-comment">// 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</span><span class="hljs-comment">// 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span><span class="hljs-comment">// 必须 原地 修改，只允许使用额外常数空间。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,2,3]</span><span class="hljs-comment">// 输出：[1,3,2]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [3,2,1]</span><span class="hljs-comment">// 输出：[1,2,3]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [1,1,5]</span><span class="hljs-comment">// 输出：[1,5,1]</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：nums = [1]</span><span class="hljs-comment">// 输出：[1]</span><span class="hljs-comment">// 示例 5：</span><span class="hljs-comment">// 输入 [4,2,3,1]</span><span class="hljs-comment">// 输出 [4,3,1,2]</span><span class="hljs-comment">// 1 从右往左，找到第一个小于 它右边的 数字</span><span class="hljs-comment">// 2 把这个数字 与 它右边 互换</span><span class="hljs-comment">// 3 把它右边所有的数 翻转</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextPermutation</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 从右向左遍历，i从倒数第二开始是为了nums[index1+1]要存在</span><span class="hljs-keyword">let</span> index1 = nums.length - <span class="hljs-number">2</span>;<span class="hljs-comment">// 寻找第一个小于右邻居的数</span><span class="hljs-keyword">while</span> (index1 &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[index1] &gt;= nums[index1 + <span class="hljs-number">1</span>]) &#123;index1--;&#125;<span class="hljs-comment">// 这个数在数组中存在，从它身后挑一个数，和它换</span><span class="hljs-keyword">if</span> (index1 &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 从最后一项，向左遍历                     </span><span class="hljs-keyword">let</span> index2 = nums.length - <span class="hljs-number">1</span>;   <span class="hljs-comment">// 寻找第一个大于 nums[index1] 的数             </span><span class="hljs-keyword">while</span> (index2 &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[index2] &lt;= nums[index1]) &#123;  index2--;&#125;<span class="hljs-comment">// 两数交换，实现变大</span>[nums[index1], nums[index2]] = [nums[index2], nums[index1]]; &#125;<span class="hljs-comment">// 抹平另外两种情况：</span><span class="hljs-comment">// 1、如果 index1 = -1，说明是递减排列，如 3 2 1，没有下一排列，直接翻转为最小排列：1 2 3</span><span class="hljs-comment">// 2、[4,2,3,1] 预期结果 [4,3,1,2], 结果却是[4,3,2,1]</span><span class="hljs-keyword">let</span> l = index1 + <span class="hljs-number">1</span>;           <span class="hljs-keyword">let</span> r = nums.length - <span class="hljs-number">1</span>;<span class="hljs-comment">// index1 右边的数进行翻转，使得变大的幅度小一些</span><span class="hljs-keyword">while</span> (l &lt; r) &#123;                            [nums[l], nums[r]] = [nums[r], nums[l]];l++;r--;&#125;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 34 旋转图像 48</span><span class="hljs-comment">// 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span><span class="hljs-comment">// 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><span class="hljs-comment">// 输出：[[7,4,1],[8,5,2],[9,6,3]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><span class="hljs-comment">// 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：matrix = [[1]]</span><span class="hljs-comment">// 输出：[[1]]</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：matrix = [[1,2],[3,4]]</span><span class="hljs-comment">// 输出：[[3,1],[4,2]]</span><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<span class="hljs-keyword">let</span> n = matrix.length<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;<span class="hljs-keyword">let</span> tmp = matrix[i][j];matrix[i][j] = matrix[n - <span class="hljs-number">1</span> - j][i];matrix[n - <span class="hljs-number">1</span> - j][i] = matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> - j];matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> -j] = matrix[j][n - <span class="hljs-number">1</span> - i];matrix[j][n - <span class="hljs-number">1</span> - i] = tmp;&#125;&#125;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 35 螺旋矩阵 54</span><span class="hljs-comment">// 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><span class="hljs-comment">// 输出：[1,2,3,6,9,8,7,4,5]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><span class="hljs-comment">// 输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><span class="hljs-keyword">var</span> spiralOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;<span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> []<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">let</span> top = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> bottom = matrix.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = left; i &lt;= right; i++) &#123;res.push(matrix[top][i]);&#125;top++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = top; i &lt;= bottom; i++) &#123;res.push(matrix[i][right]);&#125;right--;<span class="hljs-keyword">if</span> (top &gt; bottom || left &gt; right) <span class="hljs-keyword">break</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = right; i &gt;= left; i--) &#123;res.push(matrix[bottom][i]);&#125;bottom--;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = bottom; i &gt;= top; i--) &#123;res.push(matrix[i][left]);&#125;left++;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="四-字符串"><a href="#四-字符串" class="headerlink" title="四 字符串"></a>四 字符串</h2><p>1 验证回文串 —— 给定一个字符串，验证它是否是回文串<br>2 爬楼梯 —— 每次你可以爬 1 或 2 个台阶。求有多少种方法<br>3 打家劫舍 —— 数组n的最大和，其中每一项不能相互连续<br>4 最长回文子串 —— 找到字符串 s 中最长的回文子串<br>5 编辑距离 —— 计算将 word1 转换成 word2 所使用的最少操作数<br>6 无重复字符的最长子串 —— 找出其中不含有重复字符的 最长子串 的长度<br>7 整数转罗马数字<br>8 罗马数字转整数<br>9 最小路径和 —— 从二位数组 的 第一个 到 最后一个 的最小路径和<br>10 最长公共前缀 —— 字符串数组中的最长公共前缀<br>11 最小覆盖子串 —— 找到字符串 s 中最小覆盖 字符串的 t<br>12 单词拆分 —— 判断 s 是否可以被空格拆分为一个或多个在字典中出现的单词<br>13 100层丢鸡蛋 —— 有2个鸡蛋，从100层中丢下，找到刚好破的那一层<br>14 较大分组的位置 —— 找到字符串中 最大连续(同样)的 子串<br>15 下划线与驼峰互换<br>16 Z 字形变换 —— 将字符串按照 从上往下、从左到右进行 Z 字形排列<br>17 不同的路径 —— 从 m*n 表格的左上角移动到右下角，有多少种路径</p><h3 id="1-验证回文串"><a href="#1-验证回文串" class="headerlink" title="1 验证回文串"></a>1 验证回文串</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 验证回文串 125</span><span class="hljs-comment">// 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span><span class="hljs-comment">// 说明：本题中，我们将空字符串定义为有效的回文串。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: &quot;A man, a plan, a canal: Panama&quot;</span><span class="hljs-comment">// 输出: true</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: &quot;race a car&quot;</span><span class="hljs-comment">// 输出: false</span><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">const</span> strArr = s.toLocaleLowerCase().match(<span class="hljs-regexp">/[A-Za-z0-9]+/g</span>);<span class="hljs-keyword">if</span>(!strArr) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">const</span> str = strArr.join(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = str.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(left &lt; right)&#123;<span class="hljs-keyword">if</span>(str[left] === str[right])&#123;left++;right--;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 2 爬楼梯 70</span><span class="hljs-comment">// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span><span class="hljs-comment">// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><span class="hljs-comment">// 注意：给定 n 是一个正整数。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入： 2</span><span class="hljs-comment">// 输出： 2</span><span class="hljs-comment">// 解释： 有两种方法可以爬到楼顶。</span><span class="hljs-comment">// 1.  1 阶 + 1 阶</span><span class="hljs-comment">// 2.  2 阶</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">// 动态规划一： 时间复杂度 O(n) 空间复杂度：O(n)</span><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">const</span> dp = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">// 斐波那契数列 f(n) = f(n-1) + f(n-2)</span>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];&#125;<span class="hljs-keyword">return</span> dp[n];&#125;;<span class="hljs-comment">// 动态规划二： 时间复杂度 O(n) 空间复杂度 O(1)</span><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">let</span> dp1 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录 n-2 的值</span><span class="hljs-keyword">let</span> dp2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录 n-1 的值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">// 将 n-1 的值赋值给 n-2</span><span class="hljs-comment">// 将 n-1 和 n-2 的和, 赋值给 n-1</span><span class="hljs-comment">// 即 完成了 f(n) = f(n-1) + f(n-2)</span><span class="hljs-keyword">const</span> tem = dp1;dp1 = dp2;dp2 = tem + dp1;&#125;<span class="hljs-keyword">return</span> dp2;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3 打家劫舍 198</span><span class="hljs-comment">// 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金</span><span class="hljs-comment">// 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统</span><span class="hljs-comment">// 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><span class="hljs-comment">// 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：[1,2,3,1]</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><span class="hljs-comment">//      偷窃到的最高金额 = 1 + 3 = 4 </span><span class="hljs-comment">// 动态规划解法一：</span><span class="hljs-keyword">var</span> rob = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 解题步骤：</span><span class="hljs-comment">// 1. 用 fn1(k) 代表 前k个房屋中能偷窃到的最大金额</span><span class="hljs-comment">// 2. 用 fn2(k) 代表 第k个房屋中的金额</span><span class="hljs-comment">// 3. fn1(k) = Math.max(fn1(k-2) + fn2(k), fn1(k-1))</span><span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// dp[0]代表第0个房屋的金额, dp[1]代表第1个房屋的金额</span><span class="hljs-keyword">const</span> dp = [<span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= nums.length; i++) &#123;dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">return</span> dp[dp.length - <span class="hljs-number">1</span>];&#125;;<span class="hljs-comment">// 动态规划解法二：</span><span class="hljs-keyword">var</span> rob = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">let</span> dp0 = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> dp1 = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= nums.length; i++) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">Math</span>.max(dp0 + nums[i - <span class="hljs-number">1</span>], dp1);dp0 = dp1;dp1 = tem;&#125;<span class="hljs-keyword">return</span> dp1;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 4 最长回文子串 5</span><span class="hljs-comment">// 给你一个字符串 s，找到 s 中最长的回文子串。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：s = &quot;babad&quot;</span><span class="hljs-comment">// 输出：&quot;bab&quot;</span><span class="hljs-comment">// 解释：&quot;aba&quot; 同样是符合题意的答案。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：s = &quot;cbbd&quot;</span><span class="hljs-comment">// 输出：&quot;bb&quot;</span><span class="hljs-comment">// 解法一: 动态规划, 性能比较查</span><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">let</span> len = s.length;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">// 创建二维数组</span><span class="hljs-keyword">let</span> dp = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len),<span class="hljs-function">()=&gt;</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-number">0</span>)));<span class="hljs-comment">// 从字符串首部开始</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-comment">// 从字符串i前开始依次向前查找</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;dp[j][i] = s[i] == s[j] &amp;&amp; (i - j &lt; <span class="hljs-number">2</span> || dp[j + <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span>(dp[j][i] &amp;&amp; i - j + <span class="hljs-number">1</span> &gt; res.length) &#123;res = s.substring(j, i + <span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-comment">// console.log(dp)</span><span class="hljs-keyword">return</span> res&#125;;<span class="hljs-comment">// 解法二: 从中间往两边寻找, 性能更好</span><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">if</span> (s.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<span class="hljs-keyword">let</span> maxRes = <span class="hljs-number">0</span>, maxStr = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<span class="hljs-comment">// str1 是为了防止 &quot;aba&quot; 的情况</span><span class="hljs-keyword">let</span> str1 = palindrome(s, i, i);<span class="hljs-comment">// str2 是为了防止 &quot;abba&quot; 的情况</span><span class="hljs-keyword">let</span> str2 = palindrome(s, i, i + <span class="hljs-number">1</span>);   <span class="hljs-keyword">if</span> (str1.length &gt; maxRes) &#123;maxStr = str1;maxRes = str1.length;&#125;<span class="hljs-keyword">if</span> (str2.length &gt; maxRes) &#123;maxStr = str2;maxRes = str2.length;&#125;&#125;<span class="hljs-keyword">return</span> maxStr;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">palindrome</span>(<span class="hljs-params">s, l, r</span>) </span>&#123;<span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length &amp;&amp; s[l] === s[r]) &#123;l--;r++;&#125;<span class="hljs-keyword">return</span> s.slice(l + <span class="hljs-number">1</span>, r);&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 5 编辑距离 72</span><span class="hljs-comment">// 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</span><span class="hljs-comment">// 你可以对一个单词进行如下三种操作：</span><span class="hljs-comment">//  - 插入一个字符</span><span class="hljs-comment">//  - 删除一个字符</span><span class="hljs-comment">//  - 替换一个字符</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><span class="hljs-comment">// 输出：3</span><span class="hljs-comment">// 解释：</span><span class="hljs-comment">// horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><span class="hljs-comment">// rorse -&gt; rose (删除 &#x27;r&#x27;)</span><span class="hljs-comment">// rose -&gt; ros (删除 &#x27;e&#x27;)</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><span class="hljs-comment">// 输出：5</span><span class="hljs-comment">// 解释：</span><span class="hljs-comment">// intention -&gt; inention (删除 &#x27;t&#x27;)</span><span class="hljs-comment">// inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><span class="hljs-comment">// enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><span class="hljs-comment">// exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><span class="hljs-comment">// exection -&gt; execution (插入 &#x27;u&#x27;)</span><span class="hljs-keyword">var</span> minDistance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">word1, word2</span>) </span>&#123;<span class="hljs-keyword">let</span> m = word1.length + <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> n = word2.length + <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; m; k++) &#123;dp[k] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++ ) &#123;dp[i][<span class="hljs-number">0</span>] =  i;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++ ) &#123;dp[<span class="hljs-number">0</span>][j] =  j;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++ ) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++ ) &#123;<span class="hljs-keyword">if</span>(word1[i-<span class="hljs-number">1</span>] == word2[j-<span class="hljs-number">1</span>]) &#123;dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]&#125; <span class="hljs-keyword">else</span> &#123;dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]&#125;;</code></pre><h3 id="6-无重复字符的最长子串"><a href="#6-无重复字符的最长子串" class="headerlink" title="6 无重复字符的最长子串"></a>6 无重复字符的最长子串</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 6 无重复字符的最长子串 3</span><span class="hljs-comment">// 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: s = &quot;abcabcbb&quot;</span><span class="hljs-comment">// 输出: 3 </span><span class="hljs-comment">// 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: s = &quot;bbbbb&quot;</span><span class="hljs-comment">// 输出: 1</span><span class="hljs-comment">// 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 解题思路：</span><span class="hljs-comment"> * 1、用双指针维护一个滑动窗口，从来剪切子串</span><span class="hljs-comment"> * 2、不断移动右指针，遇到重复字符串，就把左指针移动到重复字符串的下一位</span><span class="hljs-comment"> * 3、移动右指针的过程中，记录所有窗口的长度，并返回最大值</span><span class="hljs-comment"> * 时间复杂度： O(n)</span><span class="hljs-comment"> * 空间复杂度： O(m)  m是字符串s不重复字符的个数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">if</span>(!s) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<span class="hljs-keyword">if</span> (m.has(s[i]) &amp;&amp; m.get(s[i]) &gt;= l) &#123;l = m.get(s[i]) + <span class="hljs-number">1</span>;&#125;m.set(s[i], i);res = <span class="hljs-built_in">Math</span>.max(res, i - l + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 7 整数转罗马数字 12</span><span class="hljs-comment">// 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</span><span class="hljs-comment">// 字符          数值</span><span class="hljs-comment">// I             1</span><span class="hljs-comment">// V             5</span><span class="hljs-comment">// X             10</span><span class="hljs-comment">// L             50</span><span class="hljs-comment">// C             100</span><span class="hljs-comment">// D             500</span><span class="hljs-comment">// M             1000</span><span class="hljs-comment">// 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。</span><span class="hljs-comment">// 27 写做  XXVII, 即为 XX + V + II 。</span><span class="hljs-comment">// 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，</span><span class="hljs-comment">// 例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。</span><span class="hljs-comment">// 同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><span class="hljs-comment">//  - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><span class="hljs-comment">//  - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><span class="hljs-comment">//  - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><span class="hljs-comment">// 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: 3</span><span class="hljs-comment">// 输出: &quot;III&quot;</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: 4</span><span class="hljs-comment">// 输出: &quot;IV&quot;</span><span class="hljs-comment">// 示例 3:</span><span class="hljs-comment">// 输入: 9</span><span class="hljs-comment">// 输出: &quot;IX&quot;</span><span class="hljs-comment">// 示例 4:</span><span class="hljs-comment">// 输入: 58</span><span class="hljs-comment">// 输出: &quot;LVIII&quot;</span><span class="hljs-comment">// 解释: L = 50, V = 5, III = 3.</span><span class="hljs-comment">// 示例 5:</span><span class="hljs-comment">// 输入: 1994</span><span class="hljs-comment">// 输出: &quot;MCMXCIV&quot;</span><span class="hljs-comment">// 解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><span class="hljs-comment">// var intToRoman = function (num) &#123;</span><span class="hljs-comment">//     let keys = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],</span><span class="hljs-comment">//         values = [&#x27;M&#x27;, &#x27;CM&#x27;, &#x27;D&#x27;, &#x27;CD&#x27;, &#x27;C&#x27;, &#x27;XC&#x27;, &#x27;L&#x27;, &#x27;XL&#x27;, &#x27;X&#x27;, &#x27;IX&#x27;, &#x27;V&#x27;, &#x27;IV&#x27;, &#x27;I&#x27;];</span><span class="hljs-comment">//     let res = &quot;&quot;;</span><span class="hljs-comment">//     for (let i = 0; i &lt; keys.length; i++) &#123;</span><span class="hljs-comment">//         while (num &gt;= keys[i]) &#123;</span><span class="hljs-comment">//             num -= keys[i];</span><span class="hljs-comment">//             res += values[i];</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     return res;</span><span class="hljs-comment">// &#125;;</span><span class="hljs-keyword">var</span> intToRoman = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;<span class="hljs-keyword">let</span> keys = [<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>];<span class="hljs-keyword">const</span> values = [<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;CM&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;CD&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;XC&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;XL&#x27;</span>,<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-string">&#x27;IX&#x27;</span>,<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-string">&#x27;IV&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>];<span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">while</span>(num)&#123;<span class="hljs-keyword">if</span>(num &gt;= keys[<span class="hljs-number">0</span>])&#123;result += values[<span class="hljs-number">0</span>];num -= keys[<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">else</span>&#123;keys.shift();values.shift();&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 8 罗马数字转整数 13</span><span class="hljs-keyword">var</span> romanToInt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">const</span> map = &#123;<span class="hljs-string">&quot;I&quot;</span>: <span class="hljs-number">1</span>,<span class="hljs-string">&quot;V&quot;</span>: <span class="hljs-number">5</span>,<span class="hljs-string">&quot;X&quot;</span>: <span class="hljs-number">10</span>,<span class="hljs-string">&quot;L&quot;</span>: <span class="hljs-number">50</span>,<span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">100</span>,<span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-number">500</span>,<span class="hljs-string">&quot;M&quot;</span>: <span class="hljs-number">1000</span>&#125;<span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++)&#123;map[s[i]] &lt; map[s[i+<span class="hljs-number">1</span>]] ?result -= map[s[i]] : result += map[s[i]];&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 9 最小路径和 64</span><span class="hljs-comment">// 给定一个包含非负整数的 m x n 网格 grid ，</span><span class="hljs-comment">// 请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span><span class="hljs-comment">// 说明：每次只能向下或者向右移动一步。</span><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">var</span> minPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) </span>&#123;<span class="hljs-keyword">let</span> m = grid.length;<span class="hljs-keyword">let</span> n = grid[<span class="hljs-number">0</span>].length;<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-keyword">const</span> subArr = grid[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; subArr.length; j++) &#123;<span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) &#123;arr[i][j] = j === <span class="hljs-number">0</span> ? subArr[<span class="hljs-number">0</span>] : arr[i][j - <span class="hljs-number">1</span>] + subArr[j];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (j === <span class="hljs-number">0</span>) &#123;arr[i][j] = arr[i - <span class="hljs-number">1</span>][j] + subArr[j];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">Math</span>.min(arr[i - <span class="hljs-number">1</span>][j], arr[i][j - <span class="hljs-number">1</span>]);arr[i][j] = subArr[j] + tem;&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> arr[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 10 最长公共前缀 14</span><span class="hljs-comment">// 编写一个函数来查找字符串数组中的最长公共前缀。</span><span class="hljs-comment">// 如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><span class="hljs-comment">// 输出：&quot;fl&quot;</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><span class="hljs-comment">// 输出：&quot;&quot;</span><span class="hljs-comment">// 解释：输入不存在公共前缀。</span><span class="hljs-keyword">var</span> longestCommonPrefix = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<span class="hljs-keyword">let</span> str = strs[<span class="hljs-number">0</span>]<span class="hljs-keyword">if</span>(!str) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++)&#123;<span class="hljs-keyword">let</span> flag = strs.every(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item[i] == str[i]);<span class="hljs-keyword">if</span> (flag) &#123;res += str[i];&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> res;&#125;&#125;<span class="hljs-keyword">return</span> res&#125;;</code></pre><h3 id="11-最小覆盖子串"><a href="#11-最小覆盖子串" class="headerlink" title="11 最小覆盖子串"></a>11 最小覆盖子串</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 11 最小覆盖子串 76</span><span class="hljs-comment">// 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串</span><span class="hljs-comment">// 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span><span class="hljs-comment">// 注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><span class="hljs-comment">// 输出：&quot;BANC&quot;</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：s = &quot;a&quot;, t = &quot;a&quot;</span><span class="hljs-comment">// 输出：&quot;a&quot;</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 用双指针维护一个滑动窗口</span><span class="hljs-comment"> * 移动右指针，直到找到包含t的所有子串，此时再移动左指针，尽量减少包含t的子串的长度。</span><span class="hljs-comment"> * 时间复杂度:  O(m + n) ,m是t的长度,n是s的长度</span><span class="hljs-comment"> * 空间复杂度:  O(m) ,m是t中不同字符的个数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> minWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左指针</span><span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; <span class="hljs-comment">// 右指针</span><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// 保存t的map对象</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> t) &#123;m.set(item, m.has(item) ? m.get(item) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 结果值</span><span class="hljs-keyword">let</span> size = m.size; <span class="hljs-comment">// 记录</span><span class="hljs-keyword">while</span>(r &lt; s.length)&#123;<span class="hljs-keyword">const</span> ri = s[r];<span class="hljs-comment">// 记录右指针移动中对 m 和 size 的影响</span><span class="hljs-keyword">if</span> (m.has(ri)) &#123;m.set(ri, m.get(ri) - <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(m.get(ri) === <span class="hljs-number">0</span>) size-- ;&#125;<span class="hljs-comment">// 当 size = 0 表示 s 从 l 到 r 正好涵盖 t</span><span class="hljs-keyword">while</span> (size === <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 记录子串</span><span class="hljs-keyword">let</span> sub = s.substring(l, r + <span class="hljs-number">1</span>);res = !res || sub.length &lt; res.length ? sub : res;<span class="hljs-comment">// 记录左指针移动中对 m 和 size 的影响</span><span class="hljs-keyword">const</span> li = s[l];<span class="hljs-keyword">if</span> (m.has(li)) &#123;m.set(li, m.get(li) + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(m.get(li) === <span class="hljs-number">1</span>) size ++;&#125;l++;&#125;r++;&#125;<span class="hljs-keyword">return</span> res; &#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 12 单词拆分 139</span><span class="hljs-comment">// 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</span><span class="hljs-comment">// 说明：</span><span class="hljs-comment">// 1. 拆分时可以重复使用字典中的单词。</span><span class="hljs-comment">// 2. 你可以假设字典中没有重复的单词。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><span class="hljs-comment">// 输出: true</span><span class="hljs-comment">// 解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><span class="hljs-comment">// 输出: true</span><span class="hljs-comment">// 解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><span class="hljs-comment">//      注意你可以重复使用字典中的单词。</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><span class="hljs-comment">// 输出: false</span><span class="hljs-comment">// 动态规划， 从后往前扫描</span><span class="hljs-keyword">var</span> wordBreak = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, wordDict</span>) </span>&#123;<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(wordDict);<span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(s.length + <span class="hljs-number">1</span>).fill(<span class="hljs-literal">false</span>);dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= s.length; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">const</span> subStr = s.slice(j, i);<span class="hljs-keyword">if</span> (set.has(subStr) &amp;&amp; dp[j]) &#123;dp[i] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[s.length];&#125;;<span class="hljs-comment">// 解法二： DFS</span><span class="hljs-keyword">const</span> wordBreak = <span class="hljs-function">(<span class="hljs-params">s, wordDict</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> len = s.length;<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(wordDict);<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);<span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">startIndex</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (startIndex == len) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// memo中有，就用memo中的</span><span class="hljs-keyword">if</span> (buffer[startIndex] !== <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> buffer[startIndex];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex + <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<span class="hljs-keyword">const</span> subStr = s.slice(startIndex, i);<span class="hljs-keyword">if</span> (set.has(subStr) &amp;&amp; dfs(i)) &#123;buffer[startIndex] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 当前递归的结果存一下</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;buffer[startIndex] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 当前递归的结果存一下</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>);&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 13 100层丢鸡蛋</span><span class="hljs-comment">// 有2个鸡蛋，可能在任意一层丢下刚好会摔破</span><span class="hljs-comment">// 现在假设有num层，找到最少尝试的次数m</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFlort</span>(<span class="hljs-params">num</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i &lt; num) &#123;<span class="hljs-keyword">let</span> t = i;<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(t &gt; <span class="hljs-number">0</span> &amp;&amp; sum &lt; num) &#123;sum += t;<span class="hljs-keyword">if</span> (sum + (t - <span class="hljs-number">1</span>) &gt; num) &#123;<span class="hljs-keyword">return</span> i;&#125;t--;&#125;i++;&#125;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 14 较大分组的位置 830</span><span class="hljs-comment">// 在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</span><span class="hljs-comment">// 例如，在字符串 s = &quot;abbxxxxzyy&quot; 中，就含有 &quot;a&quot;, &quot;bb&quot;, &quot;xxxx&quot;, &quot;z&quot; 和 &quot;yy&quot; 这样的一些分组。</span><span class="hljs-comment">// 分组可以用区间 [start, end] 表示，其中 start 和 end </span><span class="hljs-comment">//    分别表示该分组的起始和终止位置的下标。上例中的 &quot;xxxx&quot; 分组用区间表示为 [3,6] 。</span><span class="hljs-comment">// 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</span><span class="hljs-comment">// 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：s = &quot;abbxxxxzzy&quot;</span><span class="hljs-comment">// 输出：[[3,6]]</span><span class="hljs-comment">// 解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：s = &quot;abc&quot;</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：s = &quot;abcdddeeeeaabbbcd&quot;</span><span class="hljs-comment">// 输出：[[3,5],[6,9],[12,14]]</span><span class="hljs-comment">// 解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：s = &quot;aba&quot;</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 解法一: 双指针</span><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> res;<span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(p1 &lt; s.length - <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">let</span> p2 = p1 + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(s[p1] === s[p2]) &#123;p2++;&#125;<span class="hljs-keyword">if</span>(p2 - p1 &gt;= <span class="hljs-number">3</span> ) &#123;res.push([p1, p2 - <span class="hljs-number">1</span>]);p1 = p2;&#125; <span class="hljs-keyword">else</span> &#123;p1++;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 解法二: 正则:matchAll —— ([a-z])捕获小写字母，\1反向引用刚才捕获的字母，&#123;2,&#125;该字母又出现&gt;=2次</span><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> iterator = s.matchAll(<span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span>);<span class="hljs-keyword">let</span> ite = iterator.next();<span class="hljs-comment">// ite.done = false,表示迭代器还没有结束</span><span class="hljs-keyword">while</span> (!ite.done) &#123;<span class="hljs-comment">// res = &#123; done: false, value: &#123;0: &#x27;bbb&#x27;, 1: &#x27;b&#x27;, index: 2, input: &quot;aabbbcccdddddeeeeee&quot;&#125;&#125;</span>res.push([ite.value.index, ite.value.index + ite.value[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>])ite = iterator.next();&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 解法三 正则:replace  \1反向引用刚才捕获的字母，&#123;2,&#125;该字母又出现&gt;=2次</span><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">const</span> r = [];s.replace(<span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">a, _, i</span>)=&gt;</span> r.push([i, i + a.length - <span class="hljs-number">1</span>]));<span class="hljs-keyword">return</span> r;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 15 下划线与驼峰互换</span><span class="hljs-comment">// 解法一 正则 replace</span><span class="hljs-comment">// 1-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">var</span> resStr = str.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-params">match</span> =&gt;</span> <span class="hljs-string">&quot;_&quot;</span> + match.toLowerCase());<span class="hljs-comment">//如果首字母是大写，执行replace时会多一个_ ,这里需要去掉</span>  <span class="hljs-keyword">if</span>(resStr.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;_&#x27;</span>) &#123; <span class="hljs-comment">// resStr.startsWith(&#x27;_&#x27;)</span>  resStr = resStr.slice(<span class="hljs-number">1</span>);  &#125;<span class="hljs-keyword">return</span> resStr;&#125;;<span class="hljs-comment">// test:</span>toLowerLine(<span class="hljs-string">&quot;TestToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span>toLowerLine(<span class="hljs-string">&quot;testToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-comment">// 1-2.下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([^_])(?:_+([^_]))/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>&#123;<span class="hljs-comment">// match=t_b, $1=t, $2=b</span><span class="hljs-comment">// match=e_c, $1=e, $2=c</span><span class="hljs-keyword">return</span> $<span class="hljs-number">1</span> + $<span class="hljs-number">2.</span>toUpperCase();  &#125;);&#125;<span class="hljs-comment">// test</span>toCamel(<span class="hljs-string">&#x27;test_be_camel&#x27;</span>) <span class="hljs-comment">// testBeCamel</span><span class="hljs-comment">// 解法二: reduce</span><span class="hljs-comment">// 2-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(cur))&#123;cur = cur.toLowerCase();<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? pre + cur :  pre + <span class="hljs-string">&#x27;_&#x27;</span> + cur&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> pre + cur;&#125;&#125;, <span class="hljs-string">&#x27;&#x27;</span>)&#125;<span class="hljs-comment">// test</span>toLowerLine(<span class="hljs-string">&#x27;TestToLowerLine&#x27;</span>); <span class="hljs-comment">// test_to_lower_line</span><span class="hljs-comment">// 2-2.下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (pre.endsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) &#123;<span class="hljs-keyword">return</span> pre.substring(<span class="hljs-number">0</span>, pre.length - <span class="hljs-number">1</span>) + cur.toUpperCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> pre + cur;&#125;&#125;)&#125;<span class="hljs-comment">// test</span>toCamel(<span class="hljs-string">&#x27;test_to_camel&#x27;</span>); <span class="hljs-comment">// testToCamel</span><span class="hljs-comment">// 解法三: Array.map()</span><span class="hljs-comment">// 3-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-comment">// return [].map.call(arr, doLowerLine).join(&#x27;&#x27;);</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.map.call(arr, <span class="hljs-function">(<span class="hljs-params">val, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(val))&#123;<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? val.toLowerCase() : <span class="hljs-string">&#x27;_&#x27;</span> + val.toLowerCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> val;&#125;&#125;).join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;</code></pre><h3 id="16-Z-字形变换"><a href="#16-Z-字形变换" class="headerlink" title="16 Z 字形变换"></a>16 Z 字形变换</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 16 Z 字形变换 6</span><span class="hljs-comment">// 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</span><span class="hljs-comment">// 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：</span><span class="hljs-comment">// P   A   H   N</span><span class="hljs-comment">// A P L S I I G</span><span class="hljs-comment">// Y   I   R</span><span class="hljs-comment">// 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><span class="hljs-comment">// 输出：&quot;PAHNAPLSIIGYIR&quot;</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><span class="hljs-comment">// 输出：&quot;PINALSIGYAHRPI&quot;</span><span class="hljs-comment">// 解释：</span><span class="hljs-comment">// P     I    N</span><span class="hljs-comment">// A   L S  I G</span><span class="hljs-comment">// Y A   H R</span><span class="hljs-comment">// P     I</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：s = &quot;A&quot;, numRows = 1</span><span class="hljs-comment">// 输出：&quot;A&quot;</span><span class="hljs-keyword">var</span> convert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, numRows</span>) </span>&#123;<span class="hljs-keyword">if</span> (numRows === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(numRows).fill(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">const</span> n = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<span class="hljs-keyword">const</span> index = <span class="hljs-built_in">Math</span>.min(i % n, n - i % n);arr[index] += s[i]&#125;<span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 17 不同的路径 62</span><span class="hljs-comment">// 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span><span class="hljs-comment">// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span><span class="hljs-comment">// 问总共有多少条不同的路径？</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：m = 3, n = 7</span><span class="hljs-comment">// 输出：28</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：m = 3, n = 2</span><span class="hljs-comment">// 输出：3</span><span class="hljs-comment">// 解释：</span><span class="hljs-comment">// 从左上角开始，总共有 3 条路径可以到达右下角。</span><span class="hljs-comment">// 1. 向右 -&gt; 向下 -&gt; 向下</span><span class="hljs-comment">// 2. 向下 -&gt; 向下 -&gt; 向右</span><span class="hljs-comment">// 3. 向下 -&gt; 向右 -&gt; 向下</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：m = 7, n = 3</span><span class="hljs-comment">// 输出：28</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：m = 3, n = 3</span><span class="hljs-comment">// 输出：6</span><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n</span>) </span>&#123;<span class="hljs-comment">// 新建一个 m行 n列 的二维数组</span><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);   <span class="hljs-comment">// 每一列的第一个值 置为1</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);arr[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;&#125;    <span class="hljs-comment">// 每一列的第一个值 置为1</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;arr[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;arr[i][j] = arr[i - <span class="hljs-number">1</span>][j] + arr[i][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">return</span> arr[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;;<span class="hljs-comment">// var uniquePaths = function(m, n) &#123;</span><span class="hljs-comment">// let res = 1;</span><span class="hljs-comment">// for (let x = n, y = 1; y &lt; m; ++x, ++y) &#123;</span><span class="hljs-comment">// res = Math.floor(res * x / y);</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return res;</span><span class="hljs-comment">// &#125;;</span></code></pre><h2 id="五-链表"><a href="#五-链表" class="headerlink" title="五 链表"></a>五 链表</h2><p>1 反转链表<br>2 两数相加<br>3 删除链表的倒数第 N 个结点<br>4 合并两个有序链表<br>5 两两交换链表中的节点 —— 给定一个链表，两两交换其中相邻的节点<br>6 相交链表 —— 找到两个单链表相交的起始节点<br>7 回文链表 —— 判断一个链表是否为回文链表<br>8 合并K个升序链表 —— 将n个升序链表合并的一个链表<br>9 排序链表 —— 将链表升序排列</p><h3 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1 反转链表"></a>1 反转链表</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1 反转链表 206</span><span class="hljs-comment">// 反转一个单链表。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><span class="hljs-comment">// 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><span class="hljs-comment">// 进阶:</span><span class="hljs-comment">// 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">let</span> p1 = head;    <span class="hljs-keyword">let</span> p2 = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span>(p1) &#123;        <span class="hljs-keyword">const</span> tmp = p1.next; <span class="hljs-comment">// 1. 临时存储当前指针后续内容</span>        p1.next = p2;<span class="hljs-comment">// 2. 反转链表</span>        p2 = p1;<span class="hljs-comment">// 3. 接收反转结果</span>        p1 = tmp;<span class="hljs-comment">// 4. 接回临时存储的后续内容</span>    &#125;    <span class="hljs-keyword">return</span> p2;&#125;;<span class="hljs-comment">// 反转链表 II 92</span><span class="hljs-comment">// 给你单链表的头指针 head 和两个整数 left 和 right ，</span><span class="hljs-comment">// 其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 </span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：head = [1,2,3,4,5], left = 2, right = 4</span><span class="hljs-comment">// 输出：[1,4,3,2,5]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：head = [5], left = 1, right = 1</span><span class="hljs-comment">// 输出：[5]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">left</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">right</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">// 解法一: 把原链表 分割，再反转，再拼接</span><span class="hljs-keyword">var</span> reverseBetween = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, left, right</span>) </span>&#123;<span class="hljs-keyword">if</span> (left === right) <span class="hljs-keyword">return</span> head;<span class="hljs-keyword">let</span> p = head;<span class="hljs-keyword">let</span> res;<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> leftList = <span class="hljs-keyword">new</span> ListNode();<span class="hljs-keyword">let</span> p1 = leftList;<span class="hljs-keyword">let</span> midList = <span class="hljs-keyword">new</span> ListNode();<span class="hljs-keyword">let</span> p2 = midList;<span class="hljs-keyword">let</span> rightList = <span class="hljs-keyword">new</span> ListNode();<span class="hljs-keyword">let</span> p3 = rightList;<span class="hljs-comment">// 1 先找到 leftList、midList、rightList</span><span class="hljs-keyword">while</span>(p) &#123; <span class="hljs-keyword">if</span> (index &lt; left) &#123;  p1.next = <span class="hljs-keyword">new</span> ListNode(p.val);  p1 = p1.next; &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &gt; right) &#123;  p3.next = <span class="hljs-keyword">new</span> ListNode(p.val);  p3 = p3.next; &#125; <span class="hljs-keyword">else</span> &#123;  p2.next = <span class="hljs-keyword">new</span> ListNode(p.val);  p2 = p2.next; &#125; p = p.next; index++;&#125;leftList = leftList.next;midList = midList.next;rightList = rightList.next;<span class="hljs-comment">// 2 将 midList 反转</span><span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> p4 = midList;<span class="hljs-keyword">while</span> (p4) &#123;<span class="hljs-keyword">let</span> tem = p4.next;p4.next = pre;pre = p4;p4 = tem;&#125;midList.next = rightList;<span class="hljs-comment">// 3 将 leftList、midList、rightList 组合 得到结果</span><span class="hljs-keyword">if</span> (leftList) &#123;res = leftList;p1.next = pre;&#125; <span class="hljs-keyword">else</span> &#123;res = pre;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二: 找到反转的 位置，直接进行反转</span><span class="hljs-keyword">var</span> reverseBetween = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, left, right</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> ListNode();res.next = head;<span class="hljs-keyword">let</span> pre = res;<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (index &lt; left) &#123;pre = pre.next;index++;&#125;<span class="hljs-keyword">let</span> cur = pre.next;<span class="hljs-keyword">while</span>(index &lt; right) &#123;<span class="hljs-keyword">const</span> tem = cur.next;cur.next = tem.next;tem.next = pre.next;pre.next = tem;index++;&#125;<span class="hljs-keyword">return</span> res.next;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 2 两数相加 (链表) 2</span><span class="hljs-comment">// 给你两个 非空 的链表，表示两个非负的整数</span><span class="hljs-comment">// 它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</span><span class="hljs-comment">// 请你将两个数相加，并以相同形式返回一个表示和的链表。</span><span class="hljs-comment">// 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：l1 = [2,4,3], l2 = [5,6,4]</span><span class="hljs-comment">// 输出：[7,0,8]</span><span class="hljs-comment">// 解释：342 + 465 = 807.</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：l1 = [0], l2 = [0]</span><span class="hljs-comment">// 输出：[0]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><span class="hljs-comment">// 输出：[8,9,9,9,0,0,0,1]</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;<span class="hljs-keyword">const</span> l3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> p1 = l1;<span class="hljs-keyword">let</span> p2 = l2;<span class="hljs-keyword">let</span> p3 = l3;<span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(p1 || p2) &#123;<span class="hljs-keyword">const</span> v1 = p1 ? p1.val : <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> v2 = p2 ? p2.val : <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> val = v1 + v2 + carry;carry = <span class="hljs-built_in">Math</span>.floor(val / <span class="hljs-number">10</span>);p3.next = <span class="hljs-keyword">new</span> ListNode(val % <span class="hljs-number">10</span>);<span class="hljs-keyword">if</span> (p1) p1 = p1.next;<span class="hljs-keyword">if</span> (p2) p2 = p2.next;p3 = p3.next;&#125;<span class="hljs-keyword">if</span> (carry) &#123;p3.next = <span class="hljs-keyword">new</span> ListNode(carry);&#125;<span class="hljs-keyword">return</span> l3.next;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3 删除链表的倒数第 N 个结点  19</span><span class="hljs-comment">// 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span><span class="hljs-comment">// 进阶：你能尝试使用一趟扫描实现吗？</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：head = [1,2,3,4,5], n = 2</span><span class="hljs-comment">// 输出：[1,2,3,5]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：head = [1], n = 1</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：head = [1,2], n = 1</span><span class="hljs-comment">// 输出：[1]]</span><span class="hljs-comment">// 找到删除节点的前一个节点</span><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) </span>&#123;<span class="hljs-keyword">let</span> node = head;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(node) &#123;node = node.next;count++;&#125;count = count - n - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (count === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head.next;node = head;<span class="hljs-keyword">while</span>(count &gt; <span class="hljs-number">0</span>) &#123;node = node.next;count--;&#125;node.next = node.next.next;<span class="hljs-keyword">return</span> head;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 4 合并两个有序链表 21</span><span class="hljs-comment">// 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：l1 = [1,2,4], l2 = [1,3,4]</span><span class="hljs-comment">// 输出：[1,1,2,3,4,4]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：l1 = [], l2 = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：l1 = [], l2 = [0]</span><span class="hljs-comment">// 输出：[0]</span><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;<span class="hljs-keyword">let</span> l3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-literal">null</span>);<span class="hljs-keyword">let</span> p1 = l1;<span class="hljs-keyword">let</span> p2 = l2;<span class="hljs-keyword">let</span> p3 = l3;<span class="hljs-keyword">while</span>(p1 &amp;&amp; p2) &#123;<span class="hljs-keyword">if</span> (p1.val &gt; p2.val) &#123;p3.next = p2;p2 = p2.next&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1.val &lt;= p2.val) &#123;p3.next = p1;p1 = p1.next&#125;p3 = p3.next;&#125;p3.next = p1 ? p1 : p2;<span class="hljs-keyword">return</span> l3.next;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 5 两两交换链表中的节点 24</span><span class="hljs-comment">// 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><span class="hljs-comment">// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：head = [1,2,3,4]</span><span class="hljs-comment">// 输出：[2,1,4,3]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：head = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：head = [1]</span><span class="hljs-comment">// 输出：[1]</span><span class="hljs-keyword">const</span> swapPairs = <span class="hljs-function">(<span class="hljs-params">head</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> resNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);resNode.next = head;<span class="hljs-keyword">let</span> prev = resNode;<span class="hljs-keyword">while</span> (head &amp;&amp; head.next) &#123;<span class="hljs-comment">// 临时保存head.next，因为head.next待会要改变</span><span class="hljs-keyword">const</span> next = head.next;head.next = next.next;next.next = head;prev.next = next;  prev = head;      <span class="hljs-comment">// 指针更新</span>head = head.next; <span class="hljs-comment">// 指针更新</span>&#125;<span class="hljs-keyword">return</span> resNode.next;&#125;;</code></pre><h3 id="6-相交链表"><a href="#6-相交链表" class="headerlink" title="6 相交链表"></a>6 相交链表</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 6 相交链表 160</span><span class="hljs-comment">// 编写一个程序，找到两个单链表相交的起始节点。</span><span class="hljs-comment">// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><span class="hljs-comment">// 输出：Reference of the node with value = 8</span><span class="hljs-comment">// 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><span class="hljs-comment">// 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><span class="hljs-comment">// 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><span class="hljs-comment">// 输出：Reference of the node with value = 2</span><span class="hljs-comment">// 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><span class="hljs-comment">// 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;<span class="hljs-comment">// 解法一: 对headA打标记</span><span class="hljs-comment">// while(headA) &#123;</span><span class="hljs-comment">//     headA.flag = true;</span><span class="hljs-comment">//     headA = headA.next;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// while(headB) &#123;</span><span class="hljs-comment">//     if(headB.flag) return headB;</span><span class="hljs-comment">//     headB = headB.next;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return null;</span><span class="hljs-comment">// 解法二: 嵌套循环</span><span class="hljs-comment">// let p1 = headA;</span><span class="hljs-comment">// while(p1) &#123;</span><span class="hljs-comment">//     let p2 = headB;</span><span class="hljs-comment">//     while(p2) &#123;</span><span class="hljs-comment">//         if (p1 === p2) &#123;</span><span class="hljs-comment">//             return p1</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         p2 = p2.next;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     p1 = p1.next;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return null;</span><span class="hljs-comment">// 解法三: 消除多余</span><span class="hljs-keyword">let</span> p1 = headA;<span class="hljs-keyword">let</span> p2 = headB;<span class="hljs-keyword">while</span>(p1 || p2) &#123;<span class="hljs-keyword">if</span> (p1 === p2) &#123;<span class="hljs-keyword">return</span> p1;&#125;p1 = p1 === <span class="hljs-literal">null</span> ? headB : p1.next;p2 = p2 === <span class="hljs-literal">null</span> ? headA : p2.next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 7  回文链表 234</span><span class="hljs-comment">// 请判断一个链表是否为回文链表。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: 1-&gt;2</span><span class="hljs-comment">// 输出: false</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: 1-&gt;2-&gt;2-&gt;1</span><span class="hljs-comment">// 输出: true</span><span class="hljs-comment">// 解法一</span><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> p = head;<span class="hljs-keyword">while</span>(p)&#123;a = a + p.val;b = p.val + b;p = p.next;&#125;  <span class="hljs-keyword">return</span> a === b;&#125;;<span class="hljs-comment">// 解法二</span><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">let</span> left = head;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">right</span>) </span>&#123;<span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">let</span> res = traverse(right.next);res = res &amp;&amp; (right.val === left.val);left = left.next;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">return</span> traverse(head);&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 8 合并K个升序链表 23</span><span class="hljs-comment">// 给你一个链表数组，每个链表都已经按升序排列。</span><span class="hljs-comment">// 请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><span class="hljs-comment">//  </span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><span class="hljs-comment">// 输出：[1,1,2,3,4,4,5,6]</span><span class="hljs-comment">// 解释：链表数组如下：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   1-&gt;4-&gt;5,</span><span class="hljs-comment">//   1-&gt;3-&gt;4,</span><span class="hljs-comment">//   2-&gt;6</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 将它们合并到一个有序链表中得到。</span><span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：lists = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：lists = [[]]</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">/*</span><span class="hljs-comment">解法一：</span><span class="hljs-comment">reduce，将链表数组中的每一个值放入新数组</span><span class="hljs-comment">sort，以链表的val作参考冒泡排序</span><span class="hljs-comment">reduceRight，从右向左遍历，将数组连成链表</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 解法一：</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">return</span> lists.reduce(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> &#123;<span class="hljs-keyword">while</span> (n) &#123;p.push(n), n = n.next&#125;<span class="hljs-keyword">return</span> p&#125;, []).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.val - b.val).reduceRight(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> (n.next = p, p = n, p), <span class="hljs-literal">null</span>)&#125;;<span class="hljs-comment">// 解法二：</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">let</span> mergeTwoLists = <span class="hljs-function">(<span class="hljs-params">l1, l2</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> preHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<span class="hljs-keyword">let</span> preNode = preHead;<span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;preNode.next = l1;l1 = l1.next;&#125; <span class="hljs-keyword">else</span> &#123;preNode.next = l2;l2 = l2.next;&#125;preNode = preNode.next;&#125;preNode.next = l1 ? l1 : l2;<span class="hljs-keyword">return</span> preHead.next;&#125;<span class="hljs-keyword">let</span> n = lists.length;<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> res = lists[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<span class="hljs-keyword">if</span>(lists[i])&#123;res = mergeTwoLists(res, lists[i]);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 9 排序链表148</span><span class="hljs-comment">// 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</span><span class="hljs-comment">// 解法一: 将对链表进行归并排序  比解法二更好、更快</span><span class="hljs-keyword">var</span> sortList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> head;<span class="hljs-keyword">let</span> p = head;<span class="hljs-keyword">return</span> mergeList(p);&#125;;<span class="hljs-comment">// 归并排序 =&gt; o(n logn)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeList</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">if</span> (head.next) &#123;<span class="hljs-comment">// 找到中间节点</span><span class="hljs-keyword">let</span> p1 = head;<span class="hljs-keyword">let</span> p2 = head.next;<span class="hljs-keyword">while</span>(p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123;p1 = p1.next;p2 = p2.next.next;&#125;<span class="hljs-keyword">let</span> rightPart = p1.next;p1.next = <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> left = mergeList(head);<span class="hljs-keyword">const</span> right = mergeList(rightPart);head = sortMerge(left, right);&#125;<span class="hljs-keyword">return</span> head;&#125;<span class="hljs-comment">// 合并两个有序链表</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortMerge</span>(<span class="hljs-params">left, right</span>) </span>&#123;<span class="hljs-keyword">let</span> head = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> p = <span class="hljs-literal">null</span>;<span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (left.val &lt; right.val) &#123;<span class="hljs-keyword">if</span> (!head) &#123;head = left;p = head;&#125; <span class="hljs-keyword">else</span> &#123;p.next = left;p = p.next;&#125;left = left.next;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (!head) &#123;head = right;p = head;&#125; <span class="hljs-keyword">else</span> &#123;p.next = right;p = p.next;&#125;right = right.next;&#125;&#125;p.next = left ? left : right;<span class="hljs-keyword">return</span> head;&#125;<span class="hljs-comment">// 解法二: 将链表转为数组,进行归并排序, 然后再转为链表</span><span class="hljs-keyword">var</span> sortList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> head;<span class="hljs-keyword">let</span> p = head;<span class="hljs-keyword">let</span> arr = [];<span class="hljs-keyword">while</span>(p) &#123;arr.push(p);p = p.next;&#125;arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;item.next = <span class="hljs-literal">null</span>;&#125;)arr = mergeSort(arr);<span class="hljs-keyword">const</span> newHead = arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> p1 = newHead;<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(index &lt; arr.length) &#123;p1.next = arr[index];p1 = p1.next;index++;&#125;<span class="hljs-keyword">return</span> newHead;&#125;;<span class="hljs-keyword">var</span> mergeSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">const</span> mid = arr.length / <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> left = arr.slice(<span class="hljs-number">0</span>, mid);<span class="hljs-keyword">const</span> right = arr.slice(mid);<span class="hljs-keyword">let</span> leftPart = mergeSort(left);<span class="hljs-keyword">let</span> rightPart = mergeSort(right);<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span>(leftPart.length || rightPart.length) &#123;<span class="hljs-keyword">if</span> (leftPart.length &amp;&amp; rightPart.length) &#123;<span class="hljs-keyword">const</span> item = leftPart[<span class="hljs-number">0</span>].val &lt; rightPart[<span class="hljs-number">0</span>].val ? leftPart.shift() : rightPart.shift();res.push(item);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftPart.length) &#123;res.push(leftPart.shift());&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightPart.length) &#123;res.push(rightPart.shift());&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="六-堆"><a href="#六-堆" class="headerlink" title="六 堆"></a>六 堆</h2><p>1 数组中的第K个最大元素<br>2 前K个高频元素<br>3 合并K个升序链表</p><p>堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或者 小于等于（最小堆）它的子节点。<br>堆的应用：</p><ul><li>堆能高效、快速的找出最大值和最小值——之间复杂度是 O(1)</li><li>找出第 K 个最大（小）值<ul><li>构建一个最小堆，并将元素一次插入堆中</li><li>当堆的容量超过 K，就删除堆顶</li><li>插入结束后，堆顶就是第 K 个最大元素</li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 1 数组中的第K个最大元素 215</span><span class="hljs-comment">// 在未排序的数组中找到第 k 个最大的元素</span><span class="hljs-comment">// 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: [3,2,1,5,6,4] 和 k = 2</span><span class="hljs-comment">// 输出: 5</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><span class="hljs-comment">// 输出: 4</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 解题思路：</span><span class="hljs-comment"> * 1、构建一个最小堆，并依次把数组的值插入堆中</span><span class="hljs-comment"> * 2、当堆的容量超过K， 就删除堆顶</span><span class="hljs-comment"> * 3、插入结束后，堆顶就是第K个最大元素</span><span class="hljs-comment"> * 时间复杂度： O(n * log(k))</span><span class="hljs-comment"> * 空间复杂度： O(k)</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap = [];&#125;<span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123; <span class="hljs-comment">// 插入</span><span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span><span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 删除堆顶</span><span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop();<span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移操作</span>&#125;<span class="hljs-comment">// 获取堆顶</span><span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 获取堆的大小</span><span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;&#125;<span class="hljs-comment">// 获取父节点</span><span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-comment">// return Math.floor((i - 1) / 2);</span><span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 把二进制的数字右移一位</span>&#125;<span class="hljs-comment">// 获取左侧子节点</span><span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取右侧子节点</span><span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 将两个节点的位置进行交换</span><span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];<span class="hljs-built_in">this</span>.heap[i2] = temp;&#125;<span class="hljs-comment">// 上移</span><span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-comment">// 递归的终点: 到达堆顶</span><span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &gt; <span class="hljs-built_in">this</span>.heap[index]) &#123;<span class="hljs-built_in">this</span>.swap(parentIndex, index);<span class="hljs-built_in">this</span>.shiftUp(parentIndex);&#125;&#125;<span class="hljs-comment">// 下移</span><span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &lt; <span class="hljs-built_in">this</span>.heap[index]) &#123;<span class="hljs-built_in">this</span>.swap(leftIndex, index);<span class="hljs-built_in">this</span>.shiftDown(leftIndex);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &lt; <span class="hljs-built_in">this</span>.heap[index]) &#123;<span class="hljs-built_in">this</span>.swap(rightIndex, index);<span class="hljs-built_in">this</span>.shiftDown(rightIndex);&#125;&#125;&#125;<span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<span class="hljs-keyword">const</span> h1 = <span class="hljs-keyword">new</span> MinHead();nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;h1.insert(n);<span class="hljs-keyword">if</span>(h1.size() &gt; k) &#123;h1.pop();&#125;&#125;)<span class="hljs-keyword">return</span> h1.peek();&#125;;<span class="hljs-comment">// 解法二：排序</span><span class="hljs-keyword">let</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a).slice(<span class="hljs-number">0</span>, k);<span class="hljs-keyword">return</span> nums[k-<span class="hljs-number">1</span>]&#125;;<span class="hljs-comment">// 时间复杂度: O(n^2 log n) [Array.sort =&gt; O(n log n), Array.slice =&gt; O(n)]</span></code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 2 前 K 个高频元素 347</span><span class="hljs-comment">// 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: nums = [1,1,1,2,2,3], k = 2</span><span class="hljs-comment">// 输出: [1,2]</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: nums = [1], k = 1</span><span class="hljs-comment">// 输出: [1]</span><span class="hljs-comment">// 提示：</span><span class="hljs-comment">// 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</span><span class="hljs-comment">// 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</span><span class="hljs-comment">// 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</span><span class="hljs-comment">// 你可以按任意顺序返回答案。</span><span class="hljs-keyword">var</span> topKFrequent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment">    解法一：</span><span class="hljs-comment">        1、建立最小堆</span><span class="hljs-comment">  2、当堆的容量超过K， 就删除堆顶</span><span class="hljs-comment">  3、插入结束后，堆顶就是第K个最大元素</span><span class="hljs-comment"></span><span class="hljs-comment">    时间复杂度： </span><span class="hljs-comment">        1、nums.forEach =&gt; O(n)</span><span class="hljs-comment">        2、map.forEach =&gt; O(n) 而 嵌套的 insert 和 pop 都是 logK, 结合起来就是 O(n log k)</span><span class="hljs-comment">        所以结合起来， 时间复杂度 就是 O(n log K) ，由于 k &lt; n 所有符合题目要求的</span><span class="hljs-comment">   */</span><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;map.set(n, map.has(n) ? map.get(n) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);&#125;);<span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> MinHead();map.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;h.insert(&#123;value, key&#125;);<span class="hljs-keyword">if</span> (h.size() &gt; k) &#123;h.pop();&#125;&#125;)<span class="hljs-keyword">return</span> h.heap.map(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a.key)    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap = [];&#125;<span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123; <span class="hljs-comment">// 插入</span><span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span><span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 上移</span>&#125;<span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 删除堆顶</span><span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop(); <span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移</span>&#125;<span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 获取堆顶</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 获取堆的大小</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;&#125;<span class="hljs-comment">// 获取父节点</span><span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-comment">// return Math.floor((i - 1) / 2);</span><span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取左侧子节点</span><span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取右侧子节点</span><span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 将两个节点的位置进行交换</span><span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];<span class="hljs-built_in">this</span>.heap[i2] = temp;&#125;<span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 上移</span><span class="hljs-comment">// 递归的终点: 到达堆顶</span><span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[parentIndex].value &gt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;<span class="hljs-built_in">this</span>.swap(parentIndex, index); <span class="hljs-comment">// 实现交换的方法</span><span class="hljs-built_in">this</span>.shiftUp(parentIndex); <span class="hljs-comment">// 如果还是需要上移，则递归</span>&#125;&#125;<span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 下移</span><span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[leftIndex].value &lt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;<span class="hljs-built_in">this</span>.swap(leftIndex, index);<span class="hljs-built_in">this</span>.shiftDown(leftIndex);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[rightIndex].value &lt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;<span class="hljs-built_in">this</span>.swap(rightIndex, index);<span class="hljs-built_in">this</span>.shiftDown(rightIndex);&#125;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">解法二：</span><span class="hljs-comment">1、将输入的数组进行统计，得到每个元素出现次数的二维数组（二维数组的第一项是元素，第二项是元素出现的次数）</span><span class="hljs-comment">2、再将元素按照统计次数进行降序排列，数组的前K个就是所需要的结果</span><span class="hljs-comment">3、但是这个解法 不符合 题目时间复杂度的要求</span><span class="hljs-comment"></span><span class="hljs-comment">时间复杂度： </span><span class="hljs-comment">1、nums.forEach =&gt; O(n)</span><span class="hljs-comment">2、Array.sort =&gt; O(n log n)</span><span class="hljs-comment">所以结合起来， 时间复杂度 就是 O(n log n) ，不符合题目要求的 时间复杂度必须优于 O(n log n)</span><span class="hljs-comment">*/</span><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;map.set(n, map.has(n) ? map.get(n) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);&#125;);<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(map).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> arr.slice(<span class="hljs-number">0</span>, k).map(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n[<span class="hljs-number">0</span>]);</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3合并K个升序链表 23</span><span class="hljs-comment">// 给你一个链表数组，每个链表都已经按升序排列。</span><span class="hljs-comment">// 请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><span class="hljs-comment">//  </span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><span class="hljs-comment">// 输出：[1,1,2,3,4,4,5,6]</span><span class="hljs-comment">// 解释：链表数组如下：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   1-&gt;4-&gt;5,</span><span class="hljs-comment">//   1-&gt;3-&gt;4,</span><span class="hljs-comment">//   2-&gt;6</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 将它们合并到一个有序链表中得到。</span><span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：lists = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：lists = [[]]</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 时间复杂度： O(n) * logK // n是所有链表树的和，k是链表的数</span><span class="hljs-comment"> * 空间复杂度： O(k) // 中间遍历是 堆，堆的大小是K，k是链表的数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> p = res;<span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> MinHead();lists.forEach(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span>(l) h.insert(l);&#125;)<span class="hljs-keyword">while</span>(h.size()) &#123;<span class="hljs-keyword">const</span> n = h.pop(); <span class="hljs-comment">// 弹出堆顶（即lists中最小的那个链表节点）</span>p.next = n;p = p.next;<span class="hljs-keyword">if</span>(n.next) h.insert(n.next); <span class="hljs-comment">// 再把最小节点的下一个节点加到堆中</span>&#125;<span class="hljs-keyword">return</span> res.next;    &#125;;<span class="hljs-comment">// 构建一个最小堆（堆中的元素时 链表的节点）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap = [];&#125;<span class="hljs-comment">// 插入方法</span><span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123;<span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span><span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 上移操作</span>&#125;<span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 删除堆顶</span><span class="hljs-comment">// 与原生的最小堆相比，需要做修改。 需要记住 top 的元素，并返回</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.size() === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.shift();<span class="hljs-keyword">const</span> top = <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 把原来heap中最末尾的推出来, 并赋值给堆顶</span><span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop();<span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移操作</span><span class="hljs-keyword">return</span> top;&#125;<span class="hljs-comment">// 获取堆顶</span><span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 获取堆的大小</span><span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;&#125;<span class="hljs-comment">// 获取父节点</span><span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-comment">// 二进制操作，把二进制的数字右移一位</span><span class="hljs-comment">// return Math.floor((i - 1) / 2);</span><span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取左侧子节点</span><span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取右侧子节点</span><span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 将两个节点的位置进行交换</span><span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];<span class="hljs-built_in">this</span>.heap[i2] = temp;&#125;<span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 上移</span><span class="hljs-comment">// 递归的终点: 到达堆顶</span><span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[parentIndex].val &gt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;<span class="hljs-built_in">this</span>.swap(parentIndex, index); <span class="hljs-comment">// 实现交换的方法</span><span class="hljs-built_in">this</span>.shiftUp(parentIndex); <span class="hljs-comment">// 如果还是需要上移，则递归</span>&#125;&#125;<span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 下移</span><span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[leftIndex].val &lt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;<span class="hljs-built_in">this</span>.swap(leftIndex, index);<span class="hljs-built_in">this</span>.shiftDown(leftIndex);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[rightIndex].val &lt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;<span class="hljs-built_in">this</span>.swap(rightIndex, index);<span class="hljs-built_in">this</span>.shiftDown(rightIndex);&#125;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">解法二：</span><span class="hljs-comment">reduce，将链表数组中的每一个值放入新数组</span><span class="hljs-comment">sort，以链表的val作参考冒泡排序</span><span class="hljs-comment">reduceRight，从右向左遍历，将数组连成链表</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">return</span> lists.reduce(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> &#123;<span class="hljs-keyword">while</span> (n) &#123;p.push(n), n = n.next&#125;<span class="hljs-keyword">return</span> p&#125;, []).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.val - b.val).reduceRight(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> (n.next = p, p = n, p), <span class="hljs-literal">null</span>)&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment">解法三：</span><span class="hljs-comment">*/</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode[]&#125;</span> <span class="hljs-variable">lists</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">let</span> mergeTwoLists = <span class="hljs-function">(<span class="hljs-params">l1, l2</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> preHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<span class="hljs-keyword">let</span> preNode = preHead;<span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;preNode.next = l1;l1 = l1.next;&#125; <span class="hljs-keyword">else</span> &#123;preNode.next = l2;l2 = l2.next;&#125;preNode = preNode.next;&#125;preNode.next = l1 ? l1 : l2;<span class="hljs-keyword">return</span> preHead.next;&#125;<span class="hljs-keyword">let</span> n = lists.length;<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> res = lists[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<span class="hljs-keyword">if</span>(lists[i])&#123;res = mergeTwoLists(res, lists[i]);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="七-买卖股票"><a href="#七-买卖股票" class="headerlink" title="七 买卖股票"></a>七 买卖股票</h2><p>1 不限制交易次数，多次买卖一只股票<br>2 最多交易两次<br>3 可以交易k次<br>4 最佳买卖股票时机含冷冻期<br>5 买卖股票的最佳时机含手续费</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 买卖股票的最佳时机 II 122</span><span class="hljs-comment">// 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</span><span class="hljs-comment">// 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><span class="hljs-comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: prices = [7,1,5,3,6,4]</span><span class="hljs-comment">// 输出: 7</span><span class="hljs-comment">// 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><span class="hljs-comment">//      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: prices = [1,2,3,4,5]</span><span class="hljs-comment">// 输出: 4</span><span class="hljs-comment">// 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><span class="hljs-comment">//      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><span class="hljs-comment">// 示例 3:</span><span class="hljs-comment">// 输入: prices = [7,6,4,3,1]</span><span class="hljs-comment">// 输出: 0</span><span class="hljs-comment">// 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-comment">// 解法一: 统计找到最大利润</span><span class="hljs-comment">// var min = prices[0];</span><span class="hljs-comment">// var resArr = [];</span><span class="hljs-comment">// var tem = 0;</span><span class="hljs-comment">// for (let i = 1 ; i &lt; prices.length ; i++) &#123;</span><span class="hljs-comment">//     if (prices[i] &gt; prices[i - 1]) &#123;</span><span class="hljs-comment">//         tem = prices[i] - min</span><span class="hljs-comment">//         if (i === prices.length - 1) &#123;</span><span class="hljs-comment">//             resArr.push(tem)</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125; else &#123;</span><span class="hljs-comment">//         resArr.push(tem)</span><span class="hljs-comment">//         min = prices[i];</span><span class="hljs-comment">//         tem = 0</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return resArr.reduce((x, y) =&gt; &#123;</span><span class="hljs-comment">//     return x + y</span><span class="hljs-comment">// &#125;, 0)</span><span class="hljs-comment">// 解法二：贪心算法，只要有利润就赚</span><span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) &#123;res += prices[i] - prices[i - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 2 买卖股票的最佳时机 III 123</span><span class="hljs-comment">// 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span><span class="hljs-comment">// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</span><span class="hljs-comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入：prices = [3,3,5,0,0,3,1,4]</span><span class="hljs-comment">// 输出：6</span><span class="hljs-comment">// 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><span class="hljs-comment">//      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：prices = [1,2,3,4,5]</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><span class="hljs-comment">//      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><span class="hljs-comment">//      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：prices = [7,6,4,3,1] </span><span class="hljs-comment">// 输出：0 </span><span class="hljs-comment">// 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：prices = [1]</span><span class="hljs-comment">// 输出：0]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-keyword">if</span>(prices.length === <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 第一次 买入， 卖出的利润</span><span class="hljs-keyword">let</span> firIn = -prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> firOut = <span class="hljs-number">0</span>;<span class="hljs-comment">// 继第一次之后，第二次买入卖出的利润</span><span class="hljs-keyword">let</span> secIn = -prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> secOut = <span class="hljs-number">0</span>;<span class="hljs-comment">// 卖出时利润：求最大值（上次交易卖出时利润，本次交易卖出时利润）</span><span class="hljs-comment">// 买入时利润：求最大值（上次买入时利润，本次买入时利润）</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;secOut = <span class="hljs-built_in">Math</span>.max(secOut, secIn + prices[i]);<span class="hljs-comment">// 第二次买入后的利润: 第一次卖出的利润 - prices[i]</span>secIn = <span class="hljs-built_in">Math</span>.max(secIn, firOut - prices[i]);firOut = <span class="hljs-built_in">Math</span>.max(firOut, firIn + prices[i]);<span class="hljs-comment">// 第一次买入后: 利润为 -prices[i]</span>firIn = <span class="hljs-built_in">Math</span>.max(firIn, -prices[i]);&#125;<span class="hljs-keyword">return</span> secOut&#125;;<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-keyword">if</span> (prices.length === <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">let</span> firIn = -prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> firOut = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> secIn = -prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> secOut = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<span class="hljs-comment">// 第1次交易前 分支：什么都不做 或 买入 → 第1次交易后</span>firIn = <span class="hljs-built_in">Math</span>.max(firIn, -prices[i]);<span class="hljs-comment">// 第1次交易后 分支：什么都不做 或 卖出 → 第2次交易前</span>firOut = <span class="hljs-built_in">Math</span>.max(firOut, firIn + prices[i]);<span class="hljs-comment">// 第2次交易前 分支：什么都不做 或 买入 → 第2次交易后</span>secIn = <span class="hljs-built_in">Math</span>.max(secIn, firOut - prices[i]);<span class="hljs-comment">// 第2次交易后 分支：什么都不做 或 卖出 → 第3次交易前</span>secOut = <span class="hljs-built_in">Math</span>.max(secOut, secIn + prices[i]);&#125;<span class="hljs-keyword">return</span> secOut&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3 买卖股票的最佳时机 IV 188</span><span class="hljs-comment">// 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</span><span class="hljs-comment">// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</span><span class="hljs-comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：k = 2, prices = [2,4,1]</span><span class="hljs-comment">// 输出：2</span><span class="hljs-comment">// 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：k = 2, prices = [3,2,6,5,0,3]</span><span class="hljs-comment">// 输出：7</span><span class="hljs-comment">// 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><span class="hljs-comment">//      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;<span class="hljs-keyword">let</span> n = prices.length;<span class="hljs-keyword">if</span> (k &gt; n / <span class="hljs-number">2</span>) &#123;k = <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">2</span>);&#125;<span class="hljs-comment">// 记录每次交易的利润</span><span class="hljs-keyword">let</span> profit = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k);<span class="hljs-comment">//初始化买入卖出时的利润</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= k; j++)&#123;profit[j] = &#123;<span class="hljs-attr">in</span>: -prices[<span class="hljs-number">0</span>],<span class="hljs-attr">out</span>: <span class="hljs-number">0</span>&#125;;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;profit[j] = &#123;<span class="hljs-attr">out</span>: <span class="hljs-built_in">Math</span>.max(profit[j].out, profit[j].in + prices[i]), <span class="hljs-attr">in</span>: <span class="hljs-built_in">Math</span>.max(profit[j].in, profit[j - <span class="hljs-number">1</span>].out - prices[i])&#125;&#125;&#125;<span class="hljs-keyword">return</span> profit[k].out;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 4 最佳买卖股票时机含冷冻期 309</span><span class="hljs-comment">// 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</span><span class="hljs-comment">// 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span><span class="hljs-comment">// 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><span class="hljs-comment">// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: [1,2,3,0,2]</span><span class="hljs-comment">// 输出: 3 </span><span class="hljs-comment">// 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-keyword">let</span> n = prices.length;<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">let</span> dp = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n),<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[i];<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) &#123;dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+prices[i]);dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], - prices[i]);<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> &#123;dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] - prices[i]);&#125;&#125;<span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;;<span class="hljs-comment">// 解法二</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">let</span> inProfit = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> outProfit = -<span class="hljs-literal">Infinity</span>;<span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++)&#123;<span class="hljs-keyword">let</span> tmp = inProfit;inProfit = <span class="hljs-built_in">Math</span>.max(inProfit, outProfit + prices[i]);outProfit = <span class="hljs-built_in">Math</span>.max(outProfit, pre - prices[i]);pre = tmp;&#125;<span class="hljs-keyword">return</span> inProfit;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 5 买卖股票的最佳时机含手续费 714</span><span class="hljs-comment">// 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；</span><span class="hljs-comment">// 非负整数 fee 代表了交易股票的手续费用。</span><span class="hljs-comment">// 你可以无限次地完成交易，但是你每笔交易都需要付手续费。</span><span class="hljs-comment">// 如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</span><span class="hljs-comment">// 返回获得利润的最大值。</span><span class="hljs-comment">// 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><span class="hljs-comment">// 输出: 8</span><span class="hljs-comment">// 解释: 能够达到的最大利润:  </span><span class="hljs-comment">// 在此处买入 prices[0] = 1</span><span class="hljs-comment">// 在此处卖出 prices[3] = 8</span><span class="hljs-comment">// 在此处买入 prices[4] = 4</span><span class="hljs-comment">// 在此处卖出 prices[5] = 9</span><span class="hljs-comment">// 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><span class="hljs-comment">// 解法一 动态规划</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<span class="hljs-keyword">const</span> dp = [<span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, t; i &lt; prices.length; i++) &#123;t = dp[<span class="hljs-number">0</span>] <span class="hljs-comment">// 中间变量可省略，因为当天买入卖出不影响结果</span>dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] + prices[i] - fee)dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">1</span>], t - prices[i])&#125;<span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>] <span class="hljs-comment">// 最后一天，无股票 利润 &gt; 有股票时 利润</span>&#125;;<span class="hljs-comment">// 解法二：动态规划</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<span class="hljs-comment">// 初始利润</span><span class="hljs-keyword">var</span> getIn = <span class="hljs-number">0</span> - prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">var</span> getOut = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<span class="hljs-comment">// 卖出： 当前买入状态时的利润 + 卖出的股票 - 手续费</span>getOut = <span class="hljs-built_in">Math</span>.max(getOut, getIn + prices[i] - fee); <span class="hljs-comment">//买入： 当前卖出时的利润 - 买进的股票</span>getIn = <span class="hljs-built_in">Math</span>.max(getIn, getOut - prices[i]);     &#125;<span class="hljs-keyword">return</span> getOut;&#125;;<span class="hljs-comment">// 解法三：贪心算法</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<span class="hljs-keyword">let</span> min = prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(i &lt; prices.length) &#123;<span class="hljs-keyword">let</span> profit;<span class="hljs-keyword">if</span> (prices[i] &lt; min) &#123;min = prices[i];&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((profit = prices[i] - min - fee) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 两种情况：</span><span class="hljs-comment">// 1 无股票时：profit = 今天价格 - 最低买入价格min - 手续费 &gt; 0，即有利润就卖</span><span class="hljs-comment">// 2 有股票时：今天价格大于昨天价格。改今天卖。手续费昨天扣过，不再扣</span><span class="hljs-comment">//profit = pricep[i] - price[i - 1] = price[i] - (prices[i-1] - fee) - fee</span><span class="hljs-comment">//    profit = 昨天利润 + 今天价格 - 新最低买入价格 - 手续费</span><span class="hljs-comment">//     = 昨天利润 + 今天价格 - （昨天价格 - 手续费） - 手续费</span><span class="hljs-comment">//     = 昨天利润 + 今天价格 - 昨天价格</span>res += profit;min = prices[i] - fee;&#125;i++;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="八-算法总结"><a href="#八-算法总结" class="headerlink" title="八 算法总结"></a>八 算法总结</h2><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分而治之是将一个问题<strong>分</strong>成多个和原问题相似的小问题，通过<strong>递归</strong>解决这些小问题，再将小问题的结果<strong>合并</strong>以解决原来的问题。</p><p>例题：反转二叉树、相同的树</p><p>场景一： 归并排序</p><ul><li>分：先把数组从中间一分为二</li><li>解：递归的对两个子数组进行归并排序</li><li>合：合并有序子数组</li></ul><p>场景二： 快速排序</p><ul><li>分：选基准，按基准把数组分成两个子数组</li><li>解：递归的对两个子数组进行快速排序</li><li>合：对两个子数组进行合并</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划是将一个问题分解为<strong>相互重叠</strong>的子问题，通过反复求解子问题，来解决原来的问题。</p><p>例题：斐波那契数列、连续子数组的最大和</p><p><strong>动态规划</strong> 与 <strong>分而治之</strong> 的区别：</p><ul><li>动态规划: 它们的子问题是<strong>相互重叠</strong>的</li><li>分而治之: 它们的子问题是<strong>完全独立</strong>的</li></ul><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>回溯算法是一种<strong>渐进式</strong>寻找并构建问题解决方式的策略<br>回溯算法会先从一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决</p><p>例题：数组子集的全排列</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>期盼通过每个阶段的<strong>局部最优</strong>选择，从而达到全局的最优<br>结果并<strong>一定是最优</strong></p><p>例题：分发饼干、买卖股票的最佳时机</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-排序和二分搜索&quot;&gt;&lt;a href=&quot;#一-排序和二分搜索&quot; class=&quot;headerlink&quot; title=&quot;一 排序和二分搜索&quot;&gt;&lt;/a&gt;一 排序和二分搜索&lt;/h2&gt;&lt;p&gt;1冒泡排序 - 2选择排序 - 3插入排序(3-2 希尔排序) - 4归并排序 - </summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>js-性能优化</title>
    <link href="http://example.com/2021/06/17/interview/js-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/06/17/interview/js-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-06-17T07:51:55.000Z</published>
    <updated>2021-06-17T07:51:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-网络层面"><a href="#一-网络层面" class="headerlink" title="一 网络层面"></a>一 网络层面</h2><h3 id="1-减少-HTTP-请求"><a href="#1-减少-HTTP-请求" class="headerlink" title="1 减少 HTTP 请求"></a>1 减少 HTTP 请求</h3><p>通过 <code>webpack</code> 打包的方式，对文件压缩和图片合并。</p><p>一个完整的 HTTP 请求需要经历 <strong>DNS 查找 -&gt; TCP 握手 -&gt; 浏览器发出 HTTP 请求 -&gt; 服务器接收请求 -&gt; 服务器处理请求并发回响应 -&gt; 浏览器接收响应</strong>等过程。接下来看一个具体的例子帮助理解 HTTP</p><h3 id="2-使用-HTTP2"><a href="#2-使用-HTTP2" class="headerlink" title="2 使用 HTTP2"></a>2 使用 HTTP2</h3><ul><li><strong>二进制分帧</strong> —— 不再需要像 <code>HTTP1.1</code> 那样不断地读入字节，直到遇到分隔符 <code>CRLF</code> 为止。<code>HTTP2</code> 是基于帧的协议，每个帧都有表示帧长度的字段。</li><li><strong>多路复用</strong> —— <code>HTTP1.1</code> 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 <code>HTTP1.1</code> 的请求。在 <code>HTTP2</code> 上，多个请求可以共用一个 TCP 连接，同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。并且可以乱序发送，到达目的地后再通过流 ID 重新组建。</li><li><strong>首部压缩</strong> —— <code>HTTP/2</code> 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。当客户端发送请求时，它会根据首部值创建一张表，如果服务器收到了请求，它会照样创建一张表。当客户端发送下一个请求的时候，如果首部相同，客户端只需要发送表的索引，服务端按照表的索引查找并还原成完整首部。</li><li><strong>优先级</strong> —— <code>HTTP2</code> 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。</li><li><strong>服务器推送</strong> —— 服务器根据所客户端需要的资源，主动向客户端推送资源，而无需客户端明确地请求。</li></ul><h3 id="3-使用服务端渲染"><a href="#3-使用服务端渲染" class="headerlink" title="3 使用服务端渲染"></a>3 使用服务端渲染</h3><ul><li>优点：首屏渲染快，SEO 好</li><li>缺点：配置麻烦，增加了服务器的计算压力</li></ul><h3 id="4-静态资源使用-CDN"><a href="#4-静态资源使用-CDN" class="headerlink" title="4 静态资源使用 CDN"></a>4 静态资源使用 CDN</h3><p>在多个位置部署 CDN 服务器，让用户离服务器更近，从而缩短请求时间。</p><h3 id="5-善用缓存，不重复加载相同的资源"><a href="#5-善用缓存，不重复加载相同的资源" class="headerlink" title="5 善用缓存，不重复加载相同的资源"></a>5 善用缓存，不重复加载相同的资源</h3><p>对于不经常修改的文件使用强缓存: <code>Expires:12 Mar 2021 14:36:50 GMT</code> 或者 <code>Cache-Control: max-age=300</code><br>可能会修改变动的文件使用协商缓存: <code>Last-Modified / If-Modified-Since</code> 或者 <code>ETag / If-None-Match</code></p><h2 id="二-打包层面"><a href="#二-打包层面" class="headerlink" title="二 打包层面"></a>二 打包层面</h2><h3 id="1-减少-ES6-转为-ES5-的冗余代码"><a href="#1-减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="1 减少 ES6 转为 ES5 的冗余代码"></a>1 减少 ES6 转为 ES5 的冗余代码</h3><p><code>@babel/runtime</code> 包声明了所有需要用到的帮助函数，而 <code>@babel/plugin-transform-runtime</code> 的作用就是将所有需要 <code>helper</code> 函数的文件，从 <code>@babel/runtime</code> 包 引进来.</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 在 .babelrc 文件中</span><span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;@babel/plugin-transform-runtime&quot;</span>]</code></pre><h3 id="2-压缩文件"><a href="#2-压缩文件" class="headerlink" title="2 压缩文件"></a>2 压缩文件</h3><p>webpack 可以使用如下插件进行压缩：</p><ul><li><code>JavaScript：UglifyPlugin</code></li><li><code>CSS ：MiniCssExtractPlugin</code></li><li><code>HTML：HtmlWebpackPlugin</code></li></ul><p>或者使用 gzip 压缩。可以通过向 HTTP 请求头中的 <code>Accept-Encoding</code> 头添加 gzip 标识来开启这一功能，但是服务器也得支持这一功能。</p><pre><code class="hljs javaScript"><span class="hljs-comment">// webpack 配置</span><span class="hljs-keyword">const</span> CompressionPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression-webpack-plugin&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> CompressionPlugin()],&#125;<span class="hljs-comment">// node 层配置</span><span class="hljs-keyword">const</span> compression = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression&#x27;</span>)<span class="hljs-comment">// 在其他中间件前使用</span>app.use(compression())</code></pre><h3 id="3-根据文件内容生成文件名，结合-import-动态引入组件实现按需加载"><a href="#3-根据文件内容生成文件名，结合-import-动态引入组件实现按需加载" class="headerlink" title="3 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载"></a>3 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载</h3><p>通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。</p><h3 id="4-提取第三方库"><a href="#4-提取第三方库" class="headerlink" title="4 提取第三方库"></a>4 提取第三方库</h3><p>打包时提取公共代码和第三方库<br><code>optimization - splitChunks - cacheGroups - &#123; vendor, common&#125;</code></p><h3 id="5-图片压缩"><a href="#5-图片压缩" class="headerlink" title="5 图片压缩"></a>5 图片压缩</h3><p>打包时降低图片质量。<br>将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。<br>压缩方法有两种，一是通过 webpack 插件 <code>image-webpack-loader</code> ，二是通过在线网站进行压缩。</p><h2 id="三-代码层面"><a href="#三-代码层面" class="headerlink" title="三 代码层面"></a>三 代码层面</h2><h3 id="1-图片优化"><a href="#1-图片优化" class="headerlink" title="1 图片优化"></a>1 图片优化</h3><h4 id="1-图片延迟加载"><a href="#1-图片延迟加载" class="headerlink" title="(1) 图片延迟加载"></a>(1) 图片延迟加载</h4><p>先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片.</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 通过设置 data-src 来保存真实的 src 图片地址</span>&lt;img data-src=<span class="hljs-string">&quot;https://cdn.xxx....&quot;</span> /&gt;<span class="hljs-comment">// 等页面可见时，使用 JS 加载图片：</span><span class="hljs-keyword">const</span> img = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;img&#x27;</span>)img.src = img.dataset.src<span class="hljs-comment">// 判断图片是否显示</span><span class="hljs-keyword">let</span> coords = el.getBoundingClientRect();  <span class="hljs-keyword">return</span> (coords.left &gt;= <span class="hljs-number">0</span> &amp;&amp; coords.left &gt;= <span class="hljs-number">0</span> &amp;&amp; coords.top)&lt;= (<span class="hljs-built_in">document</span>.documentElement.clientHeight || <span class="hljs-built_in">window</span>.innerHeight) + <span class="hljs-built_in">parseInt</span>(offset);<span class="hljs-comment">// getBoundingClientRect: 元素的上下左右分别相对浏览器视窗的位置</span><span class="hljs-comment">// document.querySelector(&#x27;div&#x27;).clientWidth  可视区域的宽度（包括padding，不包括滚动条）</span><span class="hljs-comment">// document.querySelector(&#x27;div&#x27;).offsetWidth  可视区域的宽度（包括padding、border、滚动条）</span><span class="hljs-comment">// document.querySelector(&#x27;div&#x27;).scrollWidth  实际内容的宽度（可视区域宽度+被隐藏区域宽度）</span></code></pre><h4 id="2-响应式图片"><a href="#2-响应式图片" class="headerlink" title="(2) 响应式图片"></a>(2) 响应式图片</h4><p>可以通过 <code>picture</code> 标签 或者 媒体查询(<code>@media</code>) 实现</p><pre><code class="hljs javaScript"><span class="hljs-comment">// picture 标签</span>&lt;picture&gt;    &lt;source srcset=&quot;banner_w1000.jpg&quot; media=&quot;(min-width: 801px)&quot;&gt;    &lt;source srcset=&quot;banner_w800.jpg&quot; media=&quot;(max-width: 800px)&quot;&gt;    &lt;img src=&quot;banner_w800.jpg&quot; alt=&quot;&quot;&gt;&lt;/picture&gt;</code></pre><h4 id="3-使用-webp-格式的图片"><a href="#3-使用-webp-格式的图片" class="headerlink" title="(3) 使用 webp 格式的图片"></a>(3) 使用 webp 格式的图片</h4><p>如果能通过服务器端判断浏览器支持WebP就用WebP或SVG格式(颜色数多用JPG格式，而很少使用PNG格式)。<br>Chrome浏览器完全兼容，但是 IE、Firefox、Safari完全不支持。<br>WebP 具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。</p><p>PNG/JPG：无损 webp 体积减少 40% 左右，有损 webp 图片体积减少 75% 左右<br>GIF：无损 webp 体积减少 88% 左右</p><h4 id="4-小图片转-base64"><a href="#4-小图片转-base64" class="headerlink" title="(4) 小图片转 base64"></a>(4) 小图片转 base64</h4><p>在 <code>url-loader</code> 中增加 options 配置，指定 limit，图片转 base64 的图片大小</p><h4 id="5-使用-iconfont-代替图片图标"><a href="#5-使用-iconfont-代替图片图标" class="headerlink" title="(5) 使用 iconfont 代替图片图标"></a>(5) 使用 iconfont 代替图片图标</h4><p>icon-font 字体图标是矢量图，不会失真，还有一个优点是生成的文件特别小。<br>压缩字体文件：使用 fontmin-webpack 插件对字体文件进行压缩。</p><h4 id="6-为图片标明高度和宽度"><a href="#6-为图片标明高度和宽度" class="headerlink" title="(6) 为图片标明高度和宽度"></a>(6) 为图片标明高度和宽度</h4><p>如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小。如果图片很多，浏览器需要不断地调整页面。这不但影响速度，而且影响浏览体验。当浏览器知道高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容，从而优化加载时间，提升浏览体验。</p><h4 id="7-CSS-Sprite-图精灵、雪碧图"><a href="#7-CSS-Sprite-图精灵、雪碧图" class="headerlink" title="(7) CSS Sprite(图精灵、雪碧图)"></a>(7) CSS Sprite(图精灵、雪碧图)</h4><h3 id="2-Js-CSS-代码优化"><a href="#2-Js-CSS-代码优化" class="headerlink" title="2 Js/CSS 代码优化"></a>2 Js/CSS 代码优化</h3><h4 id="1-减少重绘重排"><a href="#1-减少重绘重排" class="headerlink" title="(1) 减少重绘重排"></a>(1) 减少重绘重排</h4><p>浏览器渲染过程：<br>1 解析HTML生成DOM树<br>2 解析CSS生成CSSOM规则树<br>3 将DOM树与CSSOM规则树合并在一起生成渲染树<br>4 遍历渲染树开始布局，计算每个节点的位置大小信息<br>5 将渲染树每个节点绘制到屏幕</p><p>重排: 当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树.<br>重绘: 当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。</p><p>重排和重绘这两个操作都是非常昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。</p><p>什么操作会导致重排: 添加或删除可见的 DOM 元素、元素位置改变、元素尺寸改变、内容改变、浏览器窗口尺寸改变<br>什么操作会导致重绘: 改变字体颜色、改变背景色 等等</p><p>如何减少重排重绘：<br>1 避免逐项更改样式。最好一次性更改style属性，或者将样式列表定义为class并一次性更改class属性<br>2 避免循环操作DOM。 可以在一个display:none的元素上进行操作，最终把它显示出来。因为<code>display:none</code>上的DOM操作不会引发重排和重绘。<br>3 避免循环读取<code>offsetLeft</code>等属性。在循环之前把它们存起来。读取<code>offsetWidth</code>等属性值，会会强制浏览器刷新队列，先回流重排，在计算结果。<br>4 绝对定位具有复杂动画的元素。绝对定位使它脱离文档流，否则会引起父元素及后续元素大量的重排。<br>5 尽量使用 <code>CSS3</code> 提供的功能实现动画效果，比如 <code>transform、opacity、filters</code>，CSS 使用了硬件加速(GPU 加速)。</p><p>CSS最终的表现分为四步：<code>Recalculate([ri:&#39;kælkjuleit]) Style</code> -&gt; <code>Layout</code> -&gt; <code>Paint Setup and Paint</code> -&gt; <code>Composite Layers</code><br>按照中文的意思大致是：查找并计算样式 -&gt; 排列 -&gt; 绘制 -&gt; 组合层<br><code>transform</code>是位于<code>Composite Layers</code>（组合层），而<code>width、left、margin</code>等是位于<code>layout</code>（排列层），所以所以<code>transform</code>实现动画肯定比<code>left</code>这些更流畅。</p><h4 id="2-使用事件委托"><a href="#2-使用事件委托" class="headerlink" title="(2) 使用事件委托"></a>(2) 使用事件委托</h4><p>好处：<br>1 子元素增加或者删除时，可以避免重复操作绑定解绑等操作，因此可以减少重复与DOM的交互次数，提高性能，减少重绘与重排的次数<br>2 减少内存，只需要在父元素绑定一次事件</p><h4 id="3-if-else-对比-switch"><a href="#3-if-else-对比-switch" class="headerlink" title="(3) if-else 对比 switch"></a>(3) if-else 对比 switch</h4><p>当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。<br>因为 if-else 语句要进行 多次 判断，switch 只需要进行一次判断。<br>或者将需要查找的遍历存放在一个数组、Object对象、Map对象中，可以直接通过key值索引到对应的value。</p><h4 id="4-不要覆盖原生方法"><a href="#4-不要覆盖原生方法" class="headerlink" title="(4) 不要覆盖原生方法"></a>(4) 不要覆盖原生方法</h4><p>无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。比如 js Math方法等</p><h4 id="5-降低-CSS-选择器的复杂性"><a href="#5-降低-CSS-选择器的复杂性" class="headerlink" title="(5) 降低 CSS 选择器的复杂性"></a>(5) 降低 CSS 选择器的复杂性</h4><ul><li>原则是从选择器的右边到左边读取 —— 因此当可以确定能准确查找到对象即可，不要过于复杂</li><li>CSS 选择器优先级 —— 优先级：内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</li></ul><p>因此选择器越短越好，尽量使用高优先级的选择器，避免使用通配符 *<br>其实，CSS 选择器没有优化的必要，因为最慢和慢快的选择器性能差别非常小</p><h4 id="6-使用-requestAnimationFrame-来实现视觉变化"><a href="#6-使用-requestAnimationFrame-来实现视觉变化" class="headerlink" title="(6) 使用 requestAnimationFrame 来实现视觉变化"></a>(6) 使用 requestAnimationFrame 来实现视觉变化</h4><p>目前大多数设备的屏幕刷新率为 60 次/秒（60fps）,最好保持浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。<br>其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动，此现象通常称为卡顿。<br>假设某个动画其中的一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。<br>保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame。</p><h4 id="7-将-CSS-放在文件头部，JavaScript-文件放在底部"><a href="#7-将-CSS-放在文件头部，JavaScript-文件放在底部" class="headerlink" title="(7) 将 CSS 放在文件头部，JavaScript 文件放在底部"></a>(7) 将 CSS 放在文件头部，JavaScript 文件放在底部</h4><p>所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。<br>如果先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。<br>JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。</p><h4 id="8-使用-Web-Worker"><a href="#8-使用-Web-Worker" class="headerlink" title="(8) 使用 Web Worker"></a>(8) 使用 Web Worker</h4><p>Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）.</p><p>Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。</p><p>不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。</p><h4 id="9-不滥用-Float"><a href="#9-不滥用-Float" class="headerlink" title="(9) 不滥用 Float"></a>(9) 不滥用 Float</h4><p>Float在渲染时计算量比较大，尽量少使用</p><h2 id="四-移动端性能如何优化"><a href="#四-移动端性能如何优化" class="headerlink" title="四 移动端性能如何优化"></a>四 移动端性能如何优化</h2><ul><li>尽量使用CSS3动画，开启硬件加速。</li><li>适当使用 touch事件代替 click事件。</li><li>避免使用CSS3渐变阴影效果。</li><li>可以用 transform:translateZ（0）来开启硬件加速。</li><li>不滥用 Float, Float在渲染时计算量比较大，尽量少使用。</li><li>不滥用 Web 字体，Web字体需要下载、解析、重绘当前页面，尽量少使用。</li><li>合理使用requestAnimation Frame动画代替 setTimeout。</li><li>合理使用CSS3中的属性（CSS3 transitions、CSS3 3D transforms、 Opacity、 Canvas、 WebGL、Video）触发GPU渲染。过度使用会使手机耗电量増加。</li></ul><p>H5秒开方案：</p><ul><li>降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</li><li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。</li><li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</li><li>渲染：JS/CSS优化，加载顺序，服务端渲染模板直出。</li></ul><h2 id="五-优化首屏加载速度"><a href="#五-优化首屏加载速度" class="headerlink" title="五 优化首屏加载速度"></a>五 优化首屏加载速度</h2><ul><li>降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</li><li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。</li><li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</li><li>渲染：JS/CSS优化，加载顺序，服务端渲染模板直出。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-网络层面&quot;&gt;&lt;a href=&quot;#一-网络层面&quot; class=&quot;headerlink&quot; title=&quot;一 网络层面&quot;&gt;&lt;/a&gt;一 网络层面&lt;/h2&gt;&lt;h3 id=&quot;1-减少-HTTP-请求&quot;&gt;&lt;a href=&quot;#1-减少-HTTP-请求&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>算法-正则</title>
    <link href="http://example.com/2021/06/14/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%AD%A3%E5%88%99/"/>
    <id>http://example.com/2021/06/14/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%AD%A3%E5%88%99/</id>
    <published>2021-06-14T09:17:14.000Z</published>
    <updated>2021-06-14T09:17:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-matchAll-And-replace"><a href="#一、-matchAll-And-replace" class="headerlink" title="一、 matchAll And replace"></a>一、 matchAll And replace</h2><h3 id="1、String-prototype-matchAll"><a href="#1、String-prototype-matchAll" class="headerlink" title="1、String.prototype.matchAll()"></a>1、String.prototype.matchAll()</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll">MDN-String.prototype.matchAll()</a></p><p>作用: matchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</p><p>语法: <code>str.matchAll(regexp)</code></p><p>参数:</p><ul><li>regexp: 正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。(RegExp必须是设置了全局模式g的形式，否则会抛出异常TypeError。)</li></ul><p>返回值: 一个迭代器（不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器）。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 实例一:</span><span class="hljs-keyword">const</span> regexp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo[a-z]*&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>); <span class="hljs-comment">// const regexp = /foo[a-z]*/g;</span><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;table football, foosball&#x27;</span>;<span class="hljs-comment">// 1、直接获取迭代器,进行 next() 遍历</span><span class="hljs-keyword">const</span> matches = str.matchAll(regexp);<span class="hljs-keyword">const</span> resArr = [];<span class="hljs-keyword">let</span> nextVal;<span class="hljs-keyword">while</span>(nextVal = matches.next().value) &#123;resArr.push(nextVal[<span class="hljs-number">0</span>]);&#125;<span class="hljs-comment">// 2、转换为数组</span><span class="hljs-keyword">var</span> ite = str.matchAll(regexp)<span class="hljs-keyword">var</span> array = [...ite];<span class="hljs-built_in">console</span>.log(array.length); <span class="hljs-comment">// 2</span></code></pre><img src="https://i.loli.net/2021/01/07/IWgdFcxN3XpOJoe.png" ><pre><code class="hljs javascript"><span class="hljs-comment">// 实例二:</span><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span><span class="hljs-keyword">var</span> r = [];<span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;abcdddeeeeaabbbcd&quot;</span>;s.replace(reg, <span class="hljs-function">(<span class="hljs-params">a, _, i</span>) =&gt;</span> r.push([i, i + a.length - <span class="hljs-number">1</span>]));<span class="hljs-built_in">console</span>.log(r);</code></pre><h3 id="2、String-prototype-replace"><a href="#2、String-prototype-replace" class="headerlink" title="2、String.prototype.replace()"></a>2、String.prototype.replace()</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace">MDN-String.prototype.replace()</a></p><p>作用: replace() 方法返回一个由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。<strong>如果pattern是字符串，则仅替换第一个匹配项。</strong><br><strong>原字符串不会改变。</strong></p><p>语法: <code>str.replace(regexp|substr, newSubStr|function)</code></p><p>参数:</p><ul><li><code>regexp (pattern)</code> —— 一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。</li><li><code>substr (pattern)</code> —— 一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。</li><li><code>newSubStr (replacement)</code> —— 用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。</li><li><code>function (replacement)</code> —— 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。</li></ul><pre><code class="hljs text">function (replacement)当指定一个函数作为第二个参数时，函数的参数如下：- match —— 匹配的子串- p1,p2, ... —— 如果第一个参数是一个正则，可能会匹配n个对象，代表匹配的对象如果是用 /(\a+)(\b+)/ 这个来匹配，p1 就是匹配的 \a+，p2 就是匹配的 \b+，以此类推- offset —— 匹配到的子字符串在原字符串中的偏移量- string —— 被匹配的原字符串- NamedCaptureGroup</code></pre><p>返回值: 一个部分或全部匹配由替代模式所取代的新的字符串。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 实例一:</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">match, p1, p2, p3, offset, string</span>) </span>&#123;  <span class="hljs-keyword">return</span> [p1, p2, p3].join(<span class="hljs-string">&#x27; - &#x27;</span>);&#125;<span class="hljs-keyword">var</span> newString = <span class="hljs-string">&#x27;abc12345#$*%&#x27;</span>.replace(<span class="hljs-regexp">/([^\d]*)(\d*)([^\w]*)/</span>, replacer);<span class="hljs-built_in">console</span>.log(newString);  <span class="hljs-comment">// abc - 12345 - #$*%</span><span class="hljs-comment">// 实例二:</span><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;abcdddeeeeaabbbcd&quot;</span>;<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span><span class="hljs-keyword">let</span> g = s.matchAll(reg);<span class="hljs-keyword">var</span> r = [];<span class="hljs-keyword">var</span> t;<span class="hljs-keyword">while</span> (t = g.next().value) r.push([t.index, t.index + t[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>]);<span class="hljs-built_in">console</span>.log(r);</code></pre><h3 id="3、例题"><a href="#3、例题" class="headerlink" title="3、例题"></a>3、例题</h3><h4 id="1-较大分组的位置"><a href="#1-较大分组的位置" class="headerlink" title="1.较大分组的位置"></a>1.较大分组的位置</h4><p><a href="https://leetcode-cn.com/problems/positions-of-large-groups/">leetcode-830较大分组的位置[简单]</a></p><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p><p>分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p><p>示例 1：</p><pre><code class="hljs text">输入：s = &quot;abbxxxxzzy&quot;输出：[[3,6]]解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：s = &quot;abc&quot;输出：[]解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</code></pre><p>示例 3：</p><pre><code class="hljs text">输入：s = &quot;abcdddeeeeaabbbcd&quot;输出：[[3,5],[6,9],[12,14]]解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</code></pre><p>示例 4：</p><pre><code class="hljs text">输入：s = &quot;aba&quot;输出：[]</code></pre><p>提示：</p><ol><li>1 &lt;= s.length &lt;= 1000</li><li>s 仅含小写英文字母</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-comment">// 解法一: 双指针</span>    <span class="hljs-comment">// let res = [];</span>    <span class="hljs-comment">// if (!s) return res;</span>    <span class="hljs-comment">// let p1 = 0;</span>    <span class="hljs-comment">// let p2;</span>    <span class="hljs-comment">// while(p1 &lt; s.length - 1) &#123;</span>    <span class="hljs-comment">//     p2 = p1 + 1;</span>    <span class="hljs-comment">//     while(s[p1] === s[p2]) &#123;</span>    <span class="hljs-comment">//         p2++;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     if(p2 - p1 &gt;= 3 ) &#123;</span>    <span class="hljs-comment">//         res.push([p1, p2 - 1]);</span>    <span class="hljs-comment">//         p1 = p2;</span>    <span class="hljs-comment">//     &#125; else &#123;</span>    <span class="hljs-comment">//         p1++;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// return res;</span>    <span class="hljs-comment">// 解法二: 正则matchAll —— ([a-z])捕获小写字母，\1反向引用刚才捕获的字母，&#123;2,&#125;该字母又出现&gt;=2次</span>    <span class="hljs-comment">// let g = s.matchAll(/([a-z])\1&#123;2,&#125;/g);</span>    <span class="hljs-comment">// let r = [];</span>    <span class="hljs-comment">// let t;</span>    <span class="hljs-comment">// while (t = g.next().value) r.push([t.index, t.index + t[0].length - 1])</span>    <span class="hljs-comment">// return r</span>    <span class="hljs-comment">// 解法三</span>    <span class="hljs-keyword">const</span> r = [];    s.replace(<span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">a, _, i</span>)=&gt;</span> r.push([i, i + a.length - <span class="hljs-number">1</span>]));    <span class="hljs-keyword">return</span> r;&#125;;</code></pre><h4 id="2-下划线转驼峰"><a href="#2-下划线转驼峰" class="headerlink" title="2.下划线转驼峰"></a>2.下划线转驼峰</h4><p>方法一：正则表达式 （推荐）</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">var</span> temp = str.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;_&quot;</span> + match.toLowerCase();  &#125;);<span class="hljs-comment">//如果首字母是大写，执行replace时会多一个_，这里需要去掉</span>  <span class="hljs-keyword">if</span>(temp.slice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;_&#x27;</span>)&#123;  temp = temp.slice(<span class="hljs-number">1</span>);  &#125;<span class="hljs-keyword">return</span> temp;&#125;;<span class="hljs-built_in">console</span>.log(toLowerLine(<span class="hljs-string">&quot;TestToLowerLine&quot;</span>));  <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-built_in">console</span>.log(toLowerLine(<span class="hljs-string">&quot;testToLowerLine&quot;</span>));  <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-comment">// 下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([^_])(?:_+([^_]))/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>&#123;<span class="hljs-comment">// match=t_b, $1=t, $2=b</span><span class="hljs-comment">// match=e_c, $1=e, $2=c</span><span class="hljs-keyword">return</span> $<span class="hljs-number">1</span> + $<span class="hljs-number">2.</span>toUpperCase();  &#125;);&#125;<span class="hljs-built_in">console</span>.log(toCamel(<span class="hljs-string">&#x27;test_be_camel&#x27;</span>)); <span class="hljs-comment">//testToCamel</span></code></pre><p>方法二：利用数组的 reduce 方法实现</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> arr === <span class="hljs-string">&#x27;string&#x27;</span>)&#123;arr = arr.split(<span class="hljs-string">&#x27;&#x27;</span>);&#125;<span class="hljs-keyword">return</span> arr.reduce(doLowerLine,<span class="hljs-string">&#x27;&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doLowerLine</span>(<span class="hljs-params">previousValue, currentValue, currentIndex, array</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(currentValue))&#123;currentValue = currentValue.toLowerCase();<span class="hljs-keyword">if</span>(currentIndex === <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> previousValue + currentValue;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> previousValue + <span class="hljs-string">&#x27;_&#x27;</span> + currentValue;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> previousValue + currentValue;&#125;&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;TestToLowerLine&#x27;</span>;<span class="hljs-keyword">var</span> res1 = toLowerLine(a);<span class="hljs-comment">//test_to_lower_line</span><span class="hljs-keyword">var</span> res2 = [].reduce.call(a,doLowerLine,<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-comment">//test_to_lower_line</span><span class="hljs-comment">// 下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> str === <span class="hljs-string">&#x27;string&#x27;</span>)&#123;str = str.split(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">//转为字符数组</span>&#125;<span class="hljs-keyword">return</span> str.reduce(doCamel);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doCamel</span>(<span class="hljs-params">previousValue, currentValue, currentIndex, array</span>)</span>&#123;<span class="hljs-keyword">if</span> (previousValue.endsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) &#123;<span class="hljs-keyword">return</span> previousValue.substring(<span class="hljs-number">0</span>, previousValue.length - <span class="hljs-number">1</span>) + currentValue.toUpperCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> previousValue + currentValue;&#125;&#125;<span class="hljs-built_in">console</span>.log(toCamel(<span class="hljs-string">&#x27;test_to_camel&#x27;</span>));    <span class="hljs-comment">//TestToCamel</span></code></pre><p>方法三：利用数组的 map 方法实现</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doLowerLine</span>(<span class="hljs-params">val, index, arr</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(val))&#123;<span class="hljs-keyword">if</span>(index === <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> val.toLowerCase();&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;_&#x27;</span> + val.toLowerCase();&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> val;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> arr === <span class="hljs-string">&#x27;string&#x27;</span>)&#123;<span class="hljs-keyword">return</span> [].map.call(arr,doLowerLine).join(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-comment">// Array.prototype.map.call(arr, doLowerLine).join(&#x27;&#x27;);</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> arr.map(doLowerLine).join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;TestToLowerLine&#x27;</span>;<span class="hljs-keyword">var</span> res1 = [].map.call(a,doLowerLine).join(<span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-keyword">var</span> res2 = toLowerLine(a);    <span class="hljs-comment">//test_to_lower_line</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、-matchAll-And-replace&quot;&gt;&lt;a href=&quot;#一、-matchAll-And-replace&quot; class=&quot;headerlink&quot; title=&quot;一、 matchAll And replace&quot;&gt;&lt;/a&gt;一、 matchAll And r</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTMLCSS</title>
    <link href="http://example.com/2021/06/11/interview/HTML&amp;CSS/"/>
    <id>http://example.com/2021/06/11/interview/HTML&amp;CSS/</id>
    <published>2021-06-11T05:48:23.000Z</published>
    <updated>2021-06-11T05:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.手写图片瀑布流效果<br>2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）<br>3.使用纯CSS实现曲线运动（贝塞尔曲线）<br>4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点</p><h3 id="1-三栏布局"><a href="#1-三栏布局" class="headerlink" title="1 三栏布局"></a>1 三栏布局</h3><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">dir</span>=<span class="hljs-string">&quot;ltr&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css"></span><span class="css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><span class="css">        <span class="hljs-attribute">background-color</span>: blue;</span><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="css">        <span class="hljs-attribute">text-align</span>: center;</span><span class="css">      &#125;</span><span class="css">      <span class="hljs-selector-class">.center</span> &#123;</span><span class="css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;</span><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="css">        <span class="hljs-attribute">text-align</span>: center;</span><span class="css">      &#125;</span><span class="css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="css">        <span class="hljs-attribute">text-align</span>: center;</span><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><span class="css">        <span class="hljs-attribute">background-color</span>: red;</span><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="css">      &#125;</span><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 浮动 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec1&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css"></span><span class="css">        <span class="hljs-selector-class">.sec1</span> <span class="hljs-selector-class">.left</span> &#123;</span><span class="css">          <span class="hljs-attribute">float</span>: left;</span><span class="css">        &#125;</span><span class="css">        <span class="hljs-selector-class">.sec1</span> <span class="hljs-selector-class">.right</span> &#123;</span><span class="css">          <span class="hljs-attribute">float</span>: right;</span><span class="css">        &#125;</span><span class="css">      </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>浮动 ： center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 绝对定位 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec2&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css"></span><span class="css">      <span class="hljs-selector-class">.sec2</span> &#123;</span><span class="css">        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><span class="css">        <span class="hljs-attribute">position</span>: relative;</span><span class="css">      &#125;</span><span class="css">      <span class="hljs-selector-class">.sec2</span> &gt; <span class="hljs-selector-tag">div</span> &#123;</span><span class="css">        <span class="hljs-attribute">position</span>: absolute;</span><span class="css">      &#125;</span><span class="css">      <span class="hljs-selector-class">.sec2</span> <span class="hljs-selector-class">.left</span> &#123;</span><span class="css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><span class="css">      &#125;</span><span class="css">      <span class="hljs-selector-class">.sec2</span> <span class="hljs-selector-class">.right</span> &#123;</span><span class="css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><span class="css">      &#125;</span><span class="css">      <span class="hljs-selector-class">.sec2</span> <span class="hljs-selector-class">.center</span> &#123;</span><span class="css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">300px</span>;</span><span class="css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">300px</span>;</span><span class="css">      &#125;</span><span class="css">      </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>绝对定位 ： center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>     <span class="hljs-comment">&lt;!-- flex布局 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec3&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css"></span><span class="css">        <span class="hljs-selector-class">.sec3</span> &#123;</span><span class="css">          <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">240px</span>;</span><span class="css">          <span class="hljs-attribute">display</span>: flex;</span><span class="css">        &#125;</span><span class="css">        <span class="hljs-selector-class">.sec3</span> <span class="hljs-selector-class">.center</span> &#123;</span><span class="css">          <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><span class="css">        &#125;</span><span class="css">      </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>flex : center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 表格布局 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec4&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css"></span><span class="css">        <span class="hljs-selector-class">.sec4</span> &#123;</span><span class="css">          <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><span class="css">          <span class="hljs-attribute">display</span>: table;</span><span class="css">          <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span></span><span class="css">        &#125;</span><span class="css">        <span class="hljs-selector-class">.sec4</span> &gt; <span class="hljs-selector-tag">div</span> &#123;</span><span class="css">          <span class="hljs-attribute">display</span>: table-cell;</span><span class="css">        &#125;</span><span class="css">      </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>表格布局 : center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 网格布局 --&gt;</span>    <span class="hljs-comment">&lt;!-- CSS3下一代标准 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec5&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css"></span><span class="css">        <span class="hljs-selector-class">.sec5</span> &#123;</span><span class="css">          <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><span class="css">          <span class="hljs-attribute">display</span>: grid;</span><span class="css">          <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="css">          <span class="hljs-comment">/* grid-template-rows: 100px; */</span></span><span class="css">          grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">300px</span> auto <span class="hljs-number">300px</span>;</span><span class="css">        &#125;</span><span class="css">      </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>网格布局 : center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">1、以上各种布局的优缺点，以及比较推荐哪一种方案</span><span class="hljs-comment">  (1)浮动 :</span><span class="hljs-comment">    - 缺点 :浮动是脱离文档流的，有些时候需要清除浮动，需要很好的处理浮动周边元素的关系</span><span class="hljs-comment">    - 优点 :兼容性比较好</span><span class="hljs-comment">  (2)绝对定位 :</span><span class="hljs-comment">    - 缺点 :该布局脱离文档流，所以子元素也必须脱离文档流，因此可使用性比较差</span><span class="hljs-comment">    - 优点 :快捷，比较不容易出问题</span><span class="hljs-comment">  (3)flex :</span><span class="hljs-comment">    - 缺点 :兼容性比较差(css3的属性)，不兼容IE8及以下</span><span class="hljs-comment">    - 优点 :非常有效的解决了浮动和绝对定位的问题</span><span class="hljs-comment">  (4)表格布局 :</span><span class="hljs-comment">    - 缺点 :操作繁琐，当三栏中其中某一栏高度超出时，其他两栏的高度也会自动跟着调整(不符合某些场景)</span><span class="hljs-comment">    - 优点 :兼容性非常好，补缺了flex布局兼容的问题</span><span class="hljs-comment">  (5)网格布局 :</span><span class="hljs-comment">    - 新技术，CSS3下一代局部方案</span><span class="hljs-comment">2、如果去掉&quot;高度已知&quot;， 以上哪种方案同样适用？</span><span class="hljs-comment">  只有 flex布局 和 表格布局 同样适用 </span><span class="hljs-comment"> --&gt;</span></code></pre><h3 id="2-水平垂直居中"><a href="#2-水平垂直居中" class="headerlink" title="2 水平垂直居中"></a>2 水平垂直居中</h3><p>（1）绝对定位+margin:auto</p><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">background</span>: green;<span class="hljs-attribute">position</span>: absolute;<span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">margin</span>: auto;&#125;</code></pre><p>(2) 绝对定位+负margin</p><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">background</span>: green;<span class="hljs-attribute">position</span>: absolute;<span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;<span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>;&#125;</code></pre><p>(3) 绝对定位+transform</p><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">background</span>: green;<span class="hljs-attribute">position</span>: absolute;<span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;    <span class="hljs-comment">/* 定位父级的50% */</span><span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>); <span class="hljs-comment">/*自己的50% */</span>&#125;</code></pre><p>(4) flex布局</p><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;      <span class="hljs-attribute">height</span>:<span class="hljs-number">600px</span>;              <span class="hljs-attribute">display</span>:flex;      <span class="hljs-attribute">justify-content</span>:center;  <span class="hljs-comment">/* 子元素水平居中 */</span>      <span class="hljs-attribute">align-items</span>:center;      <span class="hljs-comment">/* 子元素垂直居中 */</span>      <span class="hljs-comment">/* 只要三句话就可以实现不定宽高水平垂直居中 */</span> &#125; <span class="hljs-selector-class">.box</span>&gt;<span class="hljs-selector-tag">div</span>&#123;     <span class="hljs-attribute">background</span>: green;     <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; &#125;</code></pre><p>(5) table-cell实现居中</p><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">display</span>: table-cell;<span class="hljs-attribute">text-align</span>: center;<span class="hljs-attribute">vertical-align</span>: middle;&#125;</code></pre><h3 id="3-BFC"><a href="#3-BFC" class="headerlink" title="3 BFC"></a>3 BFC</h3><p>三种文档流的定位方案：</p><p>常规流(Normal flow)</p><ul><li>在常规流中，盒一个接着一个排列;</li><li>在块级格式化上下文里面， 它们竖着排列；</li><li>在行内格式化上下文里面， 它们横着排列;</li><li>当position为static或relative，并且float为none时会触发常规流；</li><li>对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置；</li><li>对于相对定位(relative positioning)，position: relative，盒偏移位置由top、bottom、left、right属性定义。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。</li></ul><p>浮动(Floats)</p><ul><li>左浮动元素尽量靠左、靠上，右浮动同理</li><li>这导致常规流环绕在它的周边，除非设置 clear 属性</li><li>浮动元素不会影响块级元素的布局</li><li>但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局</li><li>最高点不会超过当前行的最高点、它前面的浮动元素的最高点</li><li>不超过它的包含块，除非元素本身已经比包含块更宽</li><li>行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的右边是不会摆放浮动元素的</li></ul><p>绝对定位(Absolute positioning)</p><ul><li>绝对定位方案，盒从常规流中被移除，不影响常规流的布局；</li><li>它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right；</li><li>如果元素的属性position为absolute或fixed，它是绝对定位元素；</li><li>对于position: absolute，元素定位将相对于上级元素中最近的一个relative、fixed、absolute，如果没有则相对于body；</li></ul><p>BFC触发方式：</p><ul><li>根元素，即HTML标签</li><li>浮动元素：float值为left、right</li><li>overflow值不为 visible，为 auto、scroll、hidden</li><li>display值为 inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li><li>定位元素：position值为 absolute、fixed</li></ul><p>浏览器对BFC区域的约束规则：</p><ul><li>内部的Box会在垂直方向上一个接一个的放置</li><li>内部的Box垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。）</li><li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li></ul><p>作用：</p><ul><li>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素</li><li>阻止元素被浮动元素覆盖<br>一个正常文档流的block元素可能被一个float元素覆盖，挤占正常文档流，因此可以设置一个元素的float、display、position值等方式触发BFC，以阻止被浮动盒子覆盖。</li><li>可以包含浮动元素<br>通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。</li><li>阻止因为浏览器因为四舍五入造成的多列布局换行的情况<br>有时候因为多列布局采用小数点位的width导致因为浏览器因为四舍五入造成的换行的情况，可以在最后一列触发BFC的形式来阻止换行的发生。</li><li>阻止相邻元素的margin合并<br>属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠</li></ul><p>BFC、IFC、GFC、FFC：</p><ul><li>BFC BFC(Block Formatting Contexts)直译为”块级格式化上下文”。Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。如何产生BFC？ float的值不为none。  overflow的值不为visible。  position的值不为relative和static。 display的值为table-cell,table-caption, inline-block中的任何一个。  那BFC一般有什么用呢？比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。 </li><li>IFC IFC(Inline Formatting Contexts)直译为”内联格式化上下文”，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响) IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。<br>IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。 那么IFC一般有什么用呢？ 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li><li>GFC GFC(GridLayout Formatting Contexts)直译为”网格布局格式化上下文”，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid<br>columns）为每一个网格项目（grid item）定义位置和空间。  那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。 </li><li>FFC FFC(Flex Formatting Contexts)直译为”自适应格式化上下文”，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。 Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex<br>可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。 伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</li></ul><h3 id="4-选择器和权重"><a href="#4-选择器和权重" class="headerlink" title="4 选择器和权重"></a>4 选择器和权重</h3><p>选择器分类：</p><ul><li>id选择器 #id { }</li><li>类选择器 .link { }</li><li>元素选择器 a { }</li><li>属性选择器  [ type = radio ] { }</li><li>伪元素选择器  ::before { }</li><li>伪类选择器  :hover { }</li><li>否定选择器 :not ( .link ) { }</li><li>通用选择器  * { }</li><li>组合选择器  [ type = radio] + babel { }</li></ul><p>同样的方式权重计算规则：</p><ul><li>id选择器 #id { }    +100</li><li>类/属性/伪类       +10</li><li>元素/伪元素        +1</li><li>其他选择器         +0</li></ul><p>不同方式的权重计算规则：</p><ul><li>!important 优先级最高</li><li>元素属性的内联样式 优先级高</li><li>相同权重 后写的生效</li></ul><h3 id="5-超过省略号"><a href="#5-超过省略号" class="headerlink" title="5 超过省略号"></a>5 超过省略号</h3><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">overflow</span>: hidden;<span class="hljs-attribute">white-space</span>: nowrap;<span class="hljs-attribute">text-overflow</span>: ellipsis;&#125;</code></pre><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">overflow</span>: hidden;<span class="hljs-attribute">text-overflow</span>: ellipsis;<span class="hljs-attribute">display</span>: -webkit-box;-webkit-line-clamp: <span class="hljs-number">2</span>;  <span class="hljs-comment">/* 控制多行的行数 */</span><span class="hljs-comment">/* ! autoprefixer: off */</span>-webkit-box-orient: vertical;<span class="hljs-comment">/* autoprefixer: on */</span>&#125;</code></pre><h3 id="6-上中下三栏布局"><a href="#6-上中下三栏布局" class="headerlink" title="6 上中下三栏布局"></a>6 上中下三栏布局</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>headerBodyFooter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><span class="css"><span class="hljs-selector-tag">body</span> &#123;</span><span class="css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.content</span> &#123;</span><span class="css"><span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;</span><span class="css"><span class="hljs-attribute">display</span>: flex;</span><span class="css"><span class="hljs-attribute">flex-direction</span>: column;</span><span class="css"><span class="hljs-attribute">text-align</span>: center;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.head</span> &#123;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="css"><span class="hljs-attribute">position</span>: fixed;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="css"><span class="hljs-attribute">background-color</span>: cadetblue;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.center</span> &#123;</span><span class="css"><span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;</span><span class="css"><span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100px</span>;</span><span class="css"><span class="hljs-attribute">background-color</span>: mediumspringgreen;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.footer</span> &#123;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="css"><span class="hljs-attribute">background-color</span>: gold;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.center-1</span> &#123;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="css">&#125;</span><span class="css"><span class="hljs-selector-class">.center-2</span> &#123;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">900px</span>;</span><span class="css">&#125;</span><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span>head<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center-1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center-2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.手写图片瀑布流效果&lt;br&gt;2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）&lt;br&gt;3.使用纯CSS实现曲线运动（贝塞尔曲线）&lt;br&gt;4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点&lt;/p&gt;
&lt;h3 id=&quot;1-三栏布局&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="HTMLCSS" scheme="http://example.com/tags/HTMLCSS/"/>
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>打印结果</title>
    <link href="http://example.com/2021/06/10/interview/js-consoleRes/"/>
    <id>http://example.com/2021/06/10/interview/js-consoleRes/</id>
    <published>2021-06-10T06:03:03.000Z</published>
    <updated>2021-06-10T06:03:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-打印结果-Object再次赋值"><a href="#1-打印结果-Object再次赋值" class="headerlink" title="1. 打印结果 (Object再次赋值)"></a>1. 打印结果 (Object再次赋值)</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeObjProperty</span>(<span class="hljs-params">o</span>) </span>&#123;    o.siteUrl = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>;    o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    o.siteUrl = <span class="hljs-string">&quot;http://www.google.com&quot;</span>;&#125;<span class="hljs-keyword">let</span> webSite = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();changeObjProperty(webSite);<span class="hljs-built_in">console</span>.log(webSite.siteUrl);</code></pre><p>解答: <code>webSite</code> 属于复合数据类型，函数参数中以地址传递，修改值会影响到原始值， 但如果将其完全替换成另一个值，则原来的值不会受到影响.<br>因为当执行到 <code>o = new Object();</code> 时，相当于执行 <code>var o = new Object();</code>，即从新定义了一个对象，函数参数传递的对象不受影响。 因此打印结果是<code>&quot;http://www.baidu.com&quot;</code>;</p><h3 id="2-执行结果"><a href="#2-执行结果" class="headerlink" title="2. 执行结果"></a>2. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> &#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">obj</span>) </span>&#123;    obj.b = <span class="hljs-number">5</span>;    <span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-keyword">const</span> aa = foo(a);<span class="hljs-built_in">console</span>.log(a.b);<span class="hljs-built_in">console</span>.log(aa.b);<span class="hljs-built_in">console</span>.log(a === aa);</code></pre><p>解答:  函数参数中以地址传递，修改值会影响到原始值, 因此 a 与 aa 都指向同一个对象</p><h3 id="3-执行结果"><a href="#3-执行结果" class="headerlink" title="3. 执行结果"></a>3. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ofo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bick</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;mybick&#x27;</span>;&#125;<span class="hljs-keyword">var</span> m1 = <span class="hljs-keyword">new</span> Ofo();Ofo.prototype = <span class="hljs-keyword">new</span> Bick();<span class="hljs-keyword">var</span> m2 = <span class="hljs-keyword">new</span> Bick();<span class="hljs-keyword">var</span> m3 = <span class="hljs-keyword">new</span> Ofo();<span class="hljs-built_in">console</span>.log(m1.name);<span class="hljs-built_in">console</span>.log(m2.name);<span class="hljs-built_in">console</span>.log(m3.name);</code></pre><p>解答:<br>m1 = new Ofo() =&gt; m1.construetor = function Ofo() {}, 因此 m1.name = undefined<br>m2 = new Bick() =&gt; m1.construetor = function Bick() { this.name = ‘mybick’}, 因此 m2.name = ‘mybick’<br>m3 = new Ofo() =&gt; 由于 Ofo.prototype = new Bick(), 因此 m3.<strong>proto</strong> = Bink {name: ‘mybick’}, m3.name = ‘mybick’</p><h3 id="4-执行结果"><a href="#4-执行结果" class="headerlink" title="4. 执行结果"></a>4. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-meta">&#x27;use strict&#x27;</span><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.x = <span class="hljs-number">3</span>;&#125;<span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.x = <span class="hljs-number">4</span>;&#125;method = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); &#125;&#125;<span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,<span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); &#125;&#125;<span class="hljs-keyword">const</span> b = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">2</span>,<span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); &#125;&#125;<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> C();<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> D();<span class="hljs-keyword">const</span> e = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">5</span>,<span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">console</span>.log(x); &#125;&#125;a.method();b.method = a.method;b.method();<span class="hljs-keyword">const</span> fc = c.method.bind(a);fc();<span class="hljs-keyword">const</span> fd = d.method.bind(a);fd();<span class="hljs-keyword">const</span> fe = e.method.bind(a);fe();</code></pre><p>解答： 1 2 1 4 0</p><h3 id="5-执行结果"><a href="#5-执行结果" class="headerlink" title="5. 执行结果"></a>5. 执行结果</h3><pre><code class="hljs javaScript">fun();<span class="hljs-keyword">var</span> fun;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;fun();</code></pre><p>解答： 1 2</p><h3 id="6-执行结果"><a href="#6-执行结果" class="headerlink" title="6. 执行结果"></a>6. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Page</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hosts;&#125;Page.hosts = [<span class="hljs-string">&#x27;h1&#x27;</span>];Page.prototype.hosts = [<span class="hljs-string">&#x27;h2&#x27;</span>];<span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> Page();<span class="hljs-keyword">var</span> p2 = Page();<span class="hljs-built_in">console</span>.log(p1.hosts);<span class="hljs-built_in">console</span>.log(p2.hosts);</code></pre><p>p1: new 的时候首先判断构造函数是否有返回值<br>  如果返回值是 Object Array Function，则实例对象就是这个返回对象.<br>  因此 var p1 = new Page() 时，Page构造函数返回的是 this.hosts<br>  构造函数没有 hosts，沿着原型链找到了 [‘h2’], 因此 p1 = [‘h2’]<br>  结论是：p1 = [‘h2’], p1.hosts = undefined<br>p2: p2 = Page() = this.hosts, 此时this = window<br>  因此 p2 = p2 = Page() = this.hosts = undefined<br>  结论是：p2 = undefined, p2.hosts = Uncaught TypeError: Cannot read property ‘hosts’ of undefined</p><h3 id="7-执行结果"><a href="#7-执行结果" class="headerlink" title="7. 执行结果"></a>7. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;    getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;foo.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;foo.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);&#125;<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);&#125;foo.getName();getName();foo().getName();getName();<span class="hljs-keyword">new</span> foo().getName();<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> foo().getName();</code></pre><p>题解：</p><ol><li>foo.getName(): 给 function foo 赋值了一个属性,该属性的key是 getName, value是一个function(){console.log(2)}<br>因此 执行结果是 2</li><li>getName(): 这里由于遍历提升, var getName = function() { console.log(4)} 比 function getName () {console.log(5) } 后提升<br>因此最后执行的是 var getName = function() { console.log(4)}, 执行结果是 4</li><li>foo().getName(): 执行了foo(), 该函数中的getName 没有用 var/let/const 定义，因此是覆盖了全局的 getName 方法<br>此时全局的 getName = function(){console.log(1)}, 因此执行结果是 1</li><li>getName(): 经过foo().getName()之后，全局的 getName 已经被覆盖，因此执行结果是 1</li><li>new foo().getName(): new foo() 返回一个空的实例对象, 执行该对象的getName() 需要沿着原型链查找<br>因此执行了 foo.prototype.getName = function () {console.log(3)}, 执行结果是 3</li><li>new new foo().getName(): 这一部比较复杂，需要拆分为3步<ol><li>执行 new foo() —— 返回一个foo构造函数的实例对象(空对象)，并且该实例对象的原型链上有个属性 foo.prototype.getName = function () {console.log(3)}</li><li>执行 new foo().getName —— 返回该实例对象原型链上的getName属性: function () {console.log(3)}</li><li>执行 new new foo().getName() —— 等同于 new function () {console.log(3)}, 返回该构造函数的实例对象(一个空对象)，但是却执行了 console.log(3), <strong>因此输出 3</strong></li></ol></li></ol><h3 id="8-执行结果"><a href="#8-执行结果" class="headerlink" title="8. 执行结果"></a>8. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<span class="hljs-keyword">await</span> async2()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);&#125;async1()<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5 - setTimeOut&#x27;</span>)&#125;, <span class="hljs-number">0</span>)requestAnimationFrame(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>));requestIdleCallback(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>));<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>)resolve()&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>)&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;13&#x27;</span>)&#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;14&#x27;</span>))&#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>)<span class="hljs-comment">// 1 2 4 6 9 3 7 8 undefined 10 5 12 14 11 13</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-打印结果-Object再次赋值&quot;&gt;&lt;a href=&quot;#1-打印结果-Object再次赋值&quot; class=&quot;headerlink&quot; title=&quot;1. 打印结果 (Object再次赋值)&quot;&gt;&lt;/a&gt;1. 打印结果 (Object再次赋值)&lt;/h3&gt;&lt;pre&gt;&lt;c</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="consoleResult" scheme="http://example.com/tags/consoleResult/"/>
    
  </entry>
  
  <entry>
    <title>js Q&amp;A</title>
    <link href="http://example.com/2021/05/12/interview/js-Q&amp;A/"/>
    <id>http://example.com/2021/05/12/interview/js-Q&amp;A/</id>
    <published>2021-05-12T07:55:59.000Z</published>
    <updated>2021-05-12T07:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-如何正确判断-this-的指向"><a href="#一-如何正确判断-this-的指向" class="headerlink" title="一.如何正确判断 this 的指向"></a>一.如何正确判断 this 的指向</h2><ol><li><p>全局环境中的 this</p><p>   &nbsp;&nbsp;&nbsp;&nbsp;– 浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 <code>window</code><br> &nbsp;&nbsp;&nbsp;&nbsp;– node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 <code>&#123;&#125;</code></p></li><li><p>是否是 new 的绑定</p><p> 如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下：</p> <pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数返回值不是 function 或 object</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> Super(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<span class="hljs-built_in">console</span>.log(instance.name); <span class="hljs-comment">// zhangsan</span></code></pre> <pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数返回值是 function 或 object</span><span class="hljs-comment">// 这种情况下 this 指向的是返回的对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;<span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> Super(<span class="hljs-string">&#x27;hello&#x27;</span>);<span class="hljs-built_in">console</span>.log(instance.name); <span class="hljs-comment">// undefined</span></code></pre></li><li><p>函数通过 call、apply 调用，或者通过 bind 绑定<br> this 绑定的就是指向的对象<br> <strong>特殊情况</strong>：如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)</p></li><li><p>箭头函数<br> 箭头函数没有自己的this，继承外层上下文绑定的this。</p> <pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<span class="hljs-attr">info</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age); <span class="hljs-comment">//this继承的是外层上下文绑定的this</span>&#125;&#125;&#125;<span class="hljs-keyword">let</span> person = &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">28</span>&#125;;<span class="hljs-keyword">let</span> info = obj.info();info(); <span class="hljs-comment">//20</span><span class="hljs-keyword">let</span> info2 = obj.info.call(person);info2(); <span class="hljs-comment">//28</span></code></pre></li><li><p>隐式绑定——函数的调用是在某个对象上触发,即调用位置上存在上下文对象。典型的隐式调用为: <code>obj1.fn()</code></p> <pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">info</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age);&#125;<span class="hljs-keyword">var</span> person = &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,info&#125;<span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span>;person.info(); <span class="hljs-comment">//20;执行的是隐式绑定</span></code></pre></li></ol><h2 id="二-剩余参数-和-arguments-对象的区别"><a href="#二-剩余参数-和-arguments-对象的区别" class="headerlink" title="二.剩余参数 和 arguments 对象的区别"></a>二.剩余参数 和 <code>arguments</code> 对象的区别</h2><p>剩余参数 —— 剩余参数语法允许我们将不定数量的参数表示为一个数组：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum2</span>(<span class="hljs-params">agr1, arg2, ...rest</span>) </span>&#123;<span class="hljs-comment">// ...</span>&#125;</code></pre><p>区别：</p><ol><li>剩余参数只包含那些没有对应形参的实参（可以是参数的 部分）<br>而 arguments 对象包含了传给函数的所有实参（是参数的全部）</li><li>arguments 对象<strong>不是一个真实的数组</strong><br>剩余参数<strong>是真实的 Array 实例</strong>。也就是说，能够在它上面直接使用所有的数组方法，比如 sort、map、forEach、pop</li><li>Arguments Objects 是函数上下文里的激活对象AO中的内部对象，arguments 对象还有一些附加的属性(如 callee 属性)<br>arguments.callee 是一个指针，指向拥有这个arguments对象的函数</li><li>如果想在 arguments 对象上使用数组方法，首先要将它转换为真实的数组，比如使用<ul><li>[].slice.call(arguments)</li><li>Array.from(arguments)</li><li>[… arguments]</li><li>Array.protoType.slice.call(arguments)</li></ul></li></ol><h2 id="三-39-1-39-39-2-39-39-3-39-map-parseInt"><a href="#三-39-1-39-39-2-39-39-3-39-map-parseInt" class="headerlink" title="三.[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)"></a>三.<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code></h2><pre><code class="hljs javaScript"><span class="hljs-comment">// Array.prototype.map() 语法:</span><span class="hljs-keyword">var</span> new_array = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">currentValue[, index[, array]]</span>) </span>&#123;<span class="hljs-comment">// Return element for new_array </span>&#125;[, thisArg])<span class="hljs-comment">/* 参数</span><span class="hljs-comment">-- callback 生成新数组元素的函数，使用三个参数</span><span class="hljs-comment">-- currentValue callback 数组中正在处理的当前元素</span><span class="hljs-comment">-- index (可选) 数组中正在处理的当前元素的索引</span><span class="hljs-comment">-- array (可选) 方法调用的数组</span><span class="hljs-comment">-- thisArg (可选) 执行 callback 函数时值被用作this</span><span class="hljs-comment">*/</span></code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// parseInt() 语法:</span><span class="hljs-built_in">parseInt</span>(string, radix);<span class="hljs-comment">/* 参数</span><span class="hljs-comment">-- string 要解析的值。</span><span class="hljs-comment">如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。</span><span class="hljs-comment">字符串开头的空白符将会被忽略</span><span class="hljs-comment">-- radix (可选) 一个介于2到36之间的整数，代表字符串的基数(数学数字系统中的基)</span><span class="hljs-comment">小心-这并不是默认为10</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 返回值: 从给定的字符串中解析出的一个整数 或者 NaN</span><span class="hljs-comment">// 返回NaN 的情况:</span><span class="hljs-comment">// (1)radix 小于 2 或大于 36 (2)第一个非空格字符不能转换为数字</span></code></pre><p>执行过程：</p><ol><li>parseInt(‘1’, 0)<br> -&gt; radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1</li><li>parseInt(‘2’, 1)<br> -&gt; radix 基数为 1（1 进制),而 radix 要求是小于 2 或大于 36，否则返回 NaN</li><li>parseInt(‘3’, 2)<br> -&gt; radix 基数为 2 (2 进制),而 二进制表示的数中最大值(为1)小于 3, 所以无法解析，返回 NaN</li></ol><p>因此执行结果是  [1, NaN, NaN]</p><h2 id="四-让-a-1-amp-amp-a-2-amp-amp-a-3-的值为true"><a href="#四-让-a-1-amp-amp-a-2-amp-amp-a-3-的值为true" class="headerlink" title="四.让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为true"></a>四.让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为true</h2><p>方法一: 利用隐式类型转换</p><p>将 a 转换为复杂数据类型(即 Object)。当 复杂数据类型(Object) 与 简单数据类型(Number)进行对比时, Object 转换为原始类型.<br>Object 转换为原始类型会调用什么方法呢？<br>(1) 如果部署了 [Symbol.toPrimitive] 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误<br>(2) 如果没有部署 [Symbol.toPrimitive] 接口，那么根据要转换的类型，先调用 valueOf / toString<br>    - 非Date类型对象，hint 是 default 时，调用顺序为：valueOf &gt;&gt;&gt; toString，即valueOf 返回的不是基本数据类型，才会继续调用 valueOf，如果toString 返回的还不是基本数据类型，那么抛出错误。<br>    - 如果 hint 是 string(Date对象的hint默认是string) ，调用顺序为：toString &gt;&gt;&gt; valueOf，即toString 返回的不是基本数据类型，才会继续调用 valueOf，如果valueOf 返回的还不是基本数据类型，那么抛出错误。<br>    - 如果 hint 是 number，调用顺序为： valueOf &gt;&gt;&gt; toString</p><pre><code class="hljs javascript"><span class="hljs-comment">// 部署 [Symbol.toPrimitive] / valueOf/ toString 皆可</span><span class="hljs-comment">// 一次返回1，2，3 即可。</span><span class="hljs-keyword">let</span> a = &#123;[<span class="hljs-built_in">Symbol</span>.toPrimitive]: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hint</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<span class="hljs-comment">//闭包的特性之一：i 不会被回收</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> i++;&#125;&#125;)()&#125;</code></pre><p>方法二: 利用数据劫持(Proxy/Object.definedProperty)</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;<span class="hljs-attr">i</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.i++;&#125;&#125;);</code></pre><p>方法三: 数组的 toString 接口默认调用数组的 join 方法，重新 join 方法</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];a.join = a.shift;</code></pre><blockquote><p><a href="https://github.com/YvetteLau/Blog/issues/35">github-blog</a></p></blockquote><h2 id="五-异步加载JS脚本的方式"><a href="#五-异步加载JS脚本的方式" class="headerlink" title="五.异步加载JS脚本的方式"></a>五.异步加载JS脚本的方式</h2><h3 id="1-async-和-defer"><a href="#1-async-和-defer" class="headerlink" title="1.async 和 defer"></a>1.async 和 defer</h3><p><code>&lt;script&gt;</code> 标签中增加 <code>async(html5)</code> 或者 <code>defer(html4)</code> 属性,脚本就会异步加载。</p><img src="https://i.loli.net/2021/02/23/qGLYkT7COZFlhz4.png" ><p>(绿色代表HTML解析，蓝色代表JavaScript加载，红色代表JavaScript执行)</p><p>defer 和 async 的区别在于：</p><ul><li>defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在window.onload 之前执行；</li><li>async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li><li>defer是顺序加载，async是无序加载</li></ul><h3 id="2-动态创建-script-标签"><a href="#2-动态创建-script-标签" class="headerlink" title="2.动态创建 script 标签"></a>2.动态创建 script 标签</h3><p>动态创建的 script ，设置 src 并不会开始下载，而是要添加到文档中，JS文件才会开始下载。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);script.src = <span class="hljs-string">&#x27;XXX.js&#x27;</span>;<span class="hljs-comment">// 添加到html文件中才会开始下载</span><span class="hljs-built_in">document</span>.body.append(script);</code></pre><h3 id="3-XHR-异步加载JS"><a href="#3-XHR-异步加载JS" class="headerlink" title="3.XHR 异步加载JS"></a>3.XHR 异步加载JS</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.open(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;js/xxx.js&quot;</span>,<span class="hljs-literal">true</span>);xhr.send();xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) &#123;<span class="hljs-built_in">eval</span>(xhr.responseText);&#125;&#125;</code></pre><h2 id="六-隐藏页面中的某个元素"><a href="#六-隐藏页面中的某个元素" class="headerlink" title="六.隐藏页面中的某个元素"></a>六.隐藏页面中的某个元素</h2><p>影藏元素的类型有：</p><ul><li>完全影藏： 元素从DOM树中消失，不占空间</li><li>视觉上的影藏：屏幕上不可见，占据空间</li><li>语义上的影藏：读屏软件不可读，但政策占据空间</li></ul><h3 id="1-完全影藏"><a href="#1-完全影藏" class="headerlink" title="1. 完全影藏"></a>1. 完全影藏</h3><ul><li>display: none</li><li><code>&lt;div hidden&gt;&lt;/div&gt;</code> : HTML5 新增的属性，相当于 display:none</li></ul><h3 id="2-视觉上的影藏"><a href="#2-视觉上的影藏" class="headerlink" title="2.视觉上的影藏"></a>2.视觉上的影藏</h3><ul><li><p>利用 <code>position</code> 和 盒模型 将元素移出可视区范围</p><ul><li><p>设置元素<code>posoition:absolute</code> 或 <code>position:fixed</code>,再通过设置 top、left 等值，将其移出可视区域</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">position</span>:absolute;<span class="hljs-attribute">left</span>: -<span class="hljs-number">99999px</span>;&#125;</code></pre></li><li><p>设置元素<code>posoition:relative</code>，通过设置 <code>top、left</code> 等值，将其移出可视区域</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">position</span>: relative;<span class="hljs-attribute">left</span>: -<span class="hljs-number">99999px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>&#125;</code></pre></li><li><p>设置 margin 值，将其移出可视区域范围（可视区域占位）</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">99999px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>利用 transform</p><ul><li><p>缩放 scale</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>);<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>移动 translateX, translateY</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">99999px</span>);<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>旋转 rotate</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">90deg</span>);&#125;</code></pre></li></ul></li><li><p>设置其大小为0</p><ul><li><p>宽高为0，字体大小为0</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>宽高为0，超出影藏</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">overflow</span>: hidden;&#125;</code></pre></li></ul></li><li><p>设置透明度为0 <code>opacity: 0;</code></p></li><li><p><code>visibility: hidden</code></p></li><li><p>层级覆盖, z-index 属性</p>  <pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">position</span>: relative;<span class="hljs-attribute">z-index</span>: -<span class="hljs-number">999</span>;&#125;</code></pre></li><li><p>clip-path:polygon(0 0, 0 0, 0 0, 0 0); 裁剪</p></li></ul><h3 id="3-语义上的隐藏"><a href="#3-语义上的隐藏" class="headerlink" title="3.语义上的隐藏"></a>3.语义上的隐藏</h3><p>aria-hidden 属性<br>读屏软件不可读，占据空间，可见。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h2 id="七-执行上下文栈和作用域链"><a href="#七-执行上下文栈和作用域链" class="headerlink" title="七.执行上下文栈和作用域链"></a>七.执行上下文栈和作用域链</h2><h3 id="1-执行上下文"><a href="#1-执行上下文" class="headerlink" title="1. 执行上下文"></a>1. 执行上下文</h3><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p><p>执行上下文创建过程中，需要做以下几件事:</p><ul><li>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。</li><li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。</li><li>确定this的值，即 ResolveThisBinding。</li></ul><h3 id="2-执行上下文栈-（执行栈）"><a href="#2-执行上下文栈-（执行栈）" class="headerlink" title="2.执行上下文栈 （执行栈）"></a>2.执行上下文栈 （执行栈）</h3><p>执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。</p><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3.作用域"></a>3.作用域</h3><p>作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限</p><h3 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4.作用域链"></a>4.作用域链</h3><p>作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。</p><h2 id="八-可迭代对象有哪些特点"><a href="#八-可迭代对象有哪些特点" class="headerlink" title="八 可迭代对象有哪些特点"></a>八 可迭代对象有哪些特点</h2><p>（呼应 js-手写代码 的 7-给对象加上 iterator 接口,使之能被 for…of 遍历）</p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，换个角度，也可以认为，一个数据结构只要具有 Symbol.iterator 属性(Symbol.iterator 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。</p><p>可迭代对象的特点:</p><ul><li>具有 Symbol.iterator 属性，Symbol.iterator() 返回的是一个遍历器对象</li><li>可以使用 for … of 进行循环</li><li>通过被 Array.from 转换为数组</li></ul><p>原生具有 Iterator 接口的数据结构：Array、Map、Set、String、TypedArray、函数的arguments对象、NodeList对象.</p><blockquote><p><a href="https://github.com/YvetteLau/Blog/issues/35">这儿有20道大厂面试题等你查收</a></p></blockquote><h2 id="九-diff-时间复杂度从-O-n-3-优化到-O-n"><a href="#九-diff-时间复杂度从-O-n-3-优化到-O-n" class="headerlink" title="九 diff 时间复杂度从 O(n^3) 优化到 O(n)"></a>九 diff 时间复杂度从 O(n^3) 优化到 O(n)</h2><p>oldNode 每一个节点都去遍历 newNode 的节点，直到找到新树对应的节点。那么这个流程就是 O(n^2).<br>再紧接着找到不同之后，再计算最短修改距离然后修改节点，这里是 O(n^3).</p><p>vue的更新策略就是：深度优先、同层比较。就是只比较同层级，也就是 O(n)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-如何正确判断-this-的指向&quot;&gt;&lt;a href=&quot;#一-如何正确判断-this-的指向&quot; class=&quot;headerlink&quot; title=&quot;一.如何正确判断 this 的指向&quot;&gt;&lt;/a&gt;一.如何正确判断 this 的指向&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;全</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js-设计模式</title>
    <link href="http://example.com/2021/05/12/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/05/12/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-12T07:53:59.000Z</published>
    <updated>2021-05-12T07:53:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-设计模式6大原则"><a href="#1-设计模式6大原则" class="headerlink" title="1 设计模式6大原则"></a>1 设计模式6大原则</h3><ul><li>开放封闭原则</li><li>单一职责原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li><li>迪米特法则</li></ul><ol><li><p>开放封闭原则<br> 解释：<strong>对扩展开放，对修改关闭</strong><br> 核心：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。<br> 好处：提高项目的稳定性、灵活性。</p></li><li><p>单一职责原则<br> 解释：<strong>实现类要职责单一，即一个类应该只负责一项职责</strong><br> 核心思想：应该有且仅有一个原因引起类的变更<br> 好处：降低了 类的复杂度 和 变更引起的风险，提高了 可读性、可维护性、扩展性<br> 需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。</p></li><li><p>里氏替换原则<br> 解释：<strong>在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类</strong><br> 说明：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。<br> 好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。<br> 需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚合、组合等关系代替继承</p></li><li><p>依赖倒置原则<br>解释：<strong>通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合</strong><br> 说明：高层模块不应该依赖低层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。<br> 高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。<br> 好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。</p></li><li><p>接口隔离原则<br>解释：<strong>类间的依赖关系应该建立在最小的接口上，建立单一接口，不要建立庞大臃肿的接口</strong><br> 说明：接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。<br> 需注意：<strong>接口尽量小，但是要有限度</strong>（对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂）；<strong>提高内聚，减少对外交互</strong>（使接口用最少的方法去完成最多的事情）；<strong>为依赖接口的类定制服务</strong>（只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。）</p></li><li><p>迪米特法则<br>解释：<strong>类间解耦，降低耦合</strong><br> 说明： 一个类对自己依赖的类知道的越少越好，即：低耦合，高内聚。使各个模块之间的耦合尽量的低，才能提高代码的复用率。</p></li></ol><h3 id="2-面向对象的基本特征"><a href="#2-面向对象的基本特征" class="headerlink" title="2 面向对象的基本特征"></a>2 面向对象的基本特征</h3><p>面向对象的三个基本特征是：<strong>封装、继承、多态</strong></p><ul><li><p>封装<br>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p></li><li><p>继承<br>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。<br>要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。</p></li><li><p>多态性<br>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有两种方式，覆盖和重载。覆盖和重载的区别在于，覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同，例如在 Java 中，重载方法的签名必须不同于原先方法的，但对于覆盖签名必须相同。</p></li></ul><h3 id="3-常见设计模式"><a href="#3-常见设计模式" class="headerlink" title="3 常见设计模式"></a>3 常见设计模式</h3><h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="(1) 单例模式"></a>(1) 单例模式</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>优点</p><ul><li>划分命名空间，减少全局变量</li><li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li><li>且只会实例化一次。简化了代码的调试和维护</li></ul><p>缺点</p><ul><li>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</li></ul><p>场景例子</p><ul><li>定义命名空间和实现分支型方法</li><li>登录框</li><li>vuex 和 redux中的store</li></ul><pre><code class="hljs javaScript"><span class="hljs-comment">// 提取出通用的单例</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSingleton</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-keyword">var</span> instance = <span class="hljs-literal">null</span>;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (!instance) &#123;instance = fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);&#125;<span class="hljs-keyword">return</span> instance;&#125;&#125;<span class="hljs-comment">// 构造函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this.name:&#x27;</span>, <span class="hljs-built_in">this</span>.name);<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;&#125;<span class="hljs-built_in">this</span>.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;&#125;&#125;<span class="hljs-comment">// 获取单例</span><span class="hljs-keyword">var</span> personSingleton = getSingleton(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(name);<span class="hljs-keyword">return</span> p;&#125;);<span class="hljs-keyword">const</span> p1 = personSingleton(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<span class="hljs-keyword">const</span> p2 = personSingleton(<span class="hljs-string">&#x27;lisi&#x27;</span>);<span class="hljs-keyword">const</span> p3 = personSingleton(<span class="hljs-string">&#x27;wangwu&#x27;</span>);p1.getName(); <span class="hljs-comment">// &#x27;zhangsan&#x27;</span>p2.getName(); <span class="hljs-comment">// &#x27;zhangsan&#x27;</span>p3.getName(); <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><span class="hljs-built_in">console</span>.log(p1 === p2); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(p2 === p3); <span class="hljs-comment">// true</span></code></pre><h4 id="2-观察者模式-发布订阅者模式"><a href="#2-观察者模式-发布订阅者模式" class="headerlink" title="(2) 观察者模式/发布订阅者模式"></a>(2) 观察者模式/发布订阅者模式</h4><p>定义了一种一对多的关系，让多个观察者对象同时监听某一个被观察对象，这个被观察对象的状态发生变化时就会通知所有的观察者对象。</p><p>优点</p><ul><li>支持简单的广播通信，自动通知所有已经订阅过的对象</li><li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li><li>增加了灵活性</li><li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li></ul><p>缺点</p><ul><li>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</li></ul><p>场景</p><ul><li>DOM事件 （document.body.addEventListener(‘click’, function(){}）</li><li>vue 响应式</li></ul><pre><code class="hljs javaScript"><span class="hljs-comment">// 对象：观察者/订阅者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">val</span>)</span> &#123;<span class="hljs-built_in">console</span>.log(val);&#125;&#125;<span class="hljs-comment">// 观察者模式</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// 观察者列表</span><span class="hljs-built_in">this</span>.observerList = [];&#125;<span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">observer</span>)</span> &#123;<span class="hljs-built_in">this</span>.observerList.push(observer);&#125;<span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params">...args</span>)</span> &#123;<span class="hljs-built_in">this</span>.observerList.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.update(...args));&#125;&#125;<span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> Subject(); <span class="hljs-comment">// 创建一个观察对象</span>s1.add(<span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;zhangsan&#x27;</span>)); <span class="hljs-comment">// 添加一个观察者</span>s1.add(<span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;lisi&#x27;</span>));<span class="hljs-comment">// 再添加一个观察者</span>s1.notify(<span class="hljs-string">&#x27;abc&#x27;</span>); <span class="hljs-comment">// 通知所有的观察者</span><span class="hljs-comment">// 发布订阅者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PubSub</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.subscribers = &#123;&#125;&#125;<span class="hljs-function"><span class="hljs-title">subscribe</span>(<span class="hljs-params">type, fn</span>)</span> &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(<span class="hljs-built_in">this</span>.subscribers, type)) &#123;<span class="hljs-built_in">this</span>.subscribers[type] = [];&#125;<span class="hljs-built_in">this</span>.subscribers[type].push(fn);&#125;<span class="hljs-function"><span class="hljs-title">publish</span>(<span class="hljs-params">type, ...args</span>)</span> &#123;<span class="hljs-keyword">let</span> listeners = <span class="hljs-built_in">this</span>.subscribers[type];<span class="hljs-keyword">if</span> (!listeners || !listeners.length) <span class="hljs-keyword">return</span>;listeners.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn(...args));        &#125;&#125;<span class="hljs-keyword">let</span> ob = <span class="hljs-keyword">new</span> PubSub(); <span class="hljs-comment">// 创建一个发布对象</span><span class="hljs-comment">// A 订阅了 add 事件（A只关注add本身，而不关心谁发布这个事件）</span>ob.subscribe(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(val));<span class="hljs-comment">// B 订阅了 add 事件（B只关注add本身，而不关心谁发布这个事件）</span>ob.subscribe(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(val));<span class="hljs-comment">// C发布了 add 事件（C只关注 add 本身，不关心谁订阅了这个事件）</span>ob.publish(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;I published `add` event&#x27;</span>);</code></pre><h4 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="(3) 工厂模式"></a>(3) 工厂模式</h4><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。<br>该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p><p>适用场景</p><ul><li>如果不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li><li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li><li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li></ul><p>优点</p><ul><li>创建对象的过程可能很复杂，但我们只需要关心创建结果。</li><li>构造函数和创建者分离, 符合“开闭原则”</li><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li></ul><p>缺点</p><ul><li>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度</li><li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li></ul><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<span class="hljs-built_in">this</span>.name = name&#125;<span class="hljs-function"><span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fun&#x27;</span>)&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params">name</span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(name)&#125;&#125;<span class="hljs-comment">// use</span><span class="hljs-keyword">let</span> factory = <span class="hljs-keyword">new</span> Factory()<span class="hljs-keyword">let</span> p = factory.create(<span class="hljs-string">&#x27;p1&#x27;</span>)p.fun()</code></pre><h4 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="(4) 适配器模式"></a>(4) 适配器模式</h4><p>将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。</p><p>优点</p><ul><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>适配对象，适配库，适配数据</li></ul><p>缺点</p><ul><li>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)</li><li>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</li></ul><p>场景</p><ul><li>整合第三方SDK</li><li>封装旧接口</li></ul><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plug</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;iphone充电头&#x27;</span>;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.plug = <span class="hljs-keyword">new</span> Plug();&#125;<span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.plug.getName() + <span class="hljs-string">&#x27; 适配器Type-c充电头&#x27;</span>;&#125;&#125;<span class="hljs-keyword">let</span> target = <span class="hljs-keyword">new</span> Target();<span class="hljs-comment">// iphone充电头 适配器转Type-c充电头</span>target.getName();</code></pre><h4 id="5-装饰者模式"><a href="#5-装饰者模式" class="headerlink" title="(5) 装饰者模式"></a>(5) 装饰者模式</h4><p>动态地给某个对象添加一些额外的职责，是一种实现继承的替代方案。<br>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象。</p><p>装饰者模式 与 适配器模式的区别：</p><ul><li>装饰着模式 给<strong>对象</strong>添加额外的职责，因此需要传入一个实例对象</li><li>适配器模式 给一个类的接口提供了包装和转化，因此只需要实例化调用包装后的构造函数即可</li></ul><p>场景例子</p><ul><li>ES7 Decorator</li><li>core-decorators</li></ul><p>优点</p><ul><li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。</li><li>方便动态的扩展功能，且提供了比继承更多的灵活性。</li></ul><p>缺点</p><ul><li>多层装饰比较复杂。</li><li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</li></ul><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cellphone</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;生成一个手机&#x27;</span>)&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">cellphone</span>)</span> &#123;<span class="hljs-built_in">this</span>.cellphone = cellphone&#125;<span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.cellphone.create()<span class="hljs-built_in">this</span>.createShell(cellphone)&#125;<span class="hljs-function"><span class="hljs-title">createShell</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;生成手机壳&#x27;</span>)&#125;&#125;<span class="hljs-comment">// 测试代码</span><span class="hljs-keyword">let</span> cellphone = <span class="hljs-keyword">new</span> Cellphone();cellphone.create();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------&#x27;</span>);<span class="hljs-comment">// 需要传入被庄饰的实例对象</span><span class="hljs-keyword">let</span> dec = <span class="hljs-keyword">new</span> Decorator(cellphone);dec.create();</code></pre><h4 id="6-代理模式"><a href="#6-代理模式" class="headerlink" title="(6) 代理模式"></a>(6) 代理模式</h4><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p><p>装饰者模式实现上 和 代理模式 的区别:</p><ul><li>装饰者模式： 扩展功能，原有功能不变且可直接使用</li><li>代理模式： 显示原有功能，但是经过限制之后的</li></ul><p>场景</p><ul><li>HTML元素 事件代理</li><li>ES6 的 proxy</li></ul><p>优点</p><ul><li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li></ul><p>缺点</p><ul><li>处理请求速度可能有差别，非直接访问存在开销</li></ul><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> Flower = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">let</span> xiaoming = &#123;<span class="hljs-attr">sendFlower</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">let</span> flower = <span class="hljs-keyword">new</span> Flower()target.receiveFlower(flower)&#125;&#125;<span class="hljs-keyword">let</span> B = &#123;<span class="hljs-attr">receiveFlower</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flower</span>) </span>&#123;A.listenGoodMood(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;A.receiveFlower(flower)&#125;)&#125;&#125;<span class="hljs-keyword">let</span> A = &#123;<span class="hljs-attr">receiveFlower</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flower</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;收到花&#x27;</span>+ flower)&#125;,<span class="hljs-attr">listenGoodMood</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;fn()&#125;, <span class="hljs-number">1000</span>)&#125;&#125;xiaoming.sendFlower(B)</code></pre><blockquote><p><a href="https://juejin.cn/post/6844904032826294286#heading-0">设计模式简介</a><br><a href="https://www.cnblogs.com/imwtr/p/9451129.html">JS设计模式</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-设计模式6大原则&quot;&gt;&lt;a href=&quot;#1-设计模式6大原则&quot; class=&quot;headerlink&quot; title=&quot;1 设计模式6大原则&quot;&gt;&lt;/a&gt;1 设计模式6大原则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;开放封闭原则&lt;/li&gt;
&lt;li&gt;单一职责原则&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-深入理解浮点数精度问题</title>
    <link href="http://example.com/2021/05/12/interview/js%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/"/>
    <id>http://example.com/2021/05/12/interview/js%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/</id>
    <published>2021-05-12T05:58:37.000Z</published>
    <updated>2021-05-12T05:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zhuanlan.zhihu.com/p/371530318">JavaScript-深入理解浮点数精度问题-Ninnka</a></p></blockquote><p><strong>深入问题前的准备</strong></p><p>在深入问题之前，我们先来了解下JS的Number在二进制中是怎么存储的</p><p><strong>双精度浮点数</strong></p><p>JS中的Number是以双精度浮点数的形式计算的，双精度浮点数总共有8个字节（byte），每字节有8比特（bit-位），即 8bit/byet，所以总共占位64位。</p><p>根据IEEE754的标准，双精度浮点数中的占位分为3个部分</p><img src="https://i.loli.net/2021/05/12/MtiLfeyuD4wZoGx.jpg" ><p>这三个部分组成这样一个公式</p><img src="https://i.loli.net/2021/05/12/fokFy5Qp2VmYnqP.jpg" ><p><strong>第一部分：</strong><br>Sign-符号位，长度是1，0是整数，1是负数</p><p><strong>第二部分：</strong><br>Exponent-指数位，长度是11，取值范围是[0,2047]（也可以说是0 ~ 2^11-1），本身是无符号位，取值范围是[0,2047]</p><p><strong>第三部分</strong><br>Mantissa-尾数，长度是52，取值范围是[0, 2^53-1]</p><p>根据第二部分的描述，我们可以把公式优化成这样：</p><img src="https://i.loli.net/2021/05/12/CpJmeGOixKycjhb.jpg" ><p>看完这两个公式，可能有同学开始疑惑了？？？</p><p>为什么需要M+1 ？</p><p>公式是遵循科学计数法规范的，我们常见的科学计数法是这样的</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">2021</span>;<span class="hljs-comment">// =&gt; 2.21 * 10^3</span><span class="hljs-comment">// =&gt; 2.21E3;</span></code></pre><p>二进制中的科学计数法则是这样的</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&quot;101011000&quot;</span>;<span class="hljs-comment">// =&gt; 1.01011 * 2^8</span><span class="hljs-comment">// 去除整数部分的1后，剩余 M=01011</span><span class="hljs-comment">// 整数部分只能为1，满足 0 &lt; N &lt; 2</span><span class="hljs-comment">// M 是去除1之后剩下的部分，最终计算时需要加回来，所以会有 M+1</span></code></pre><p>为什么需要E-1023 ？</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&quot;101011000&quot;</span>;<span class="hljs-comment">// =&gt; 1.01011 * 2^8</span><span class="hljs-comment">// E本身是无符号位，取值范围是[0,2047]，但是指数可以是负数</span><span class="hljs-comment">// 所以IEEE754标准规定，对于E为11位的情况，中间数是 2^10-1=1023</span><span class="hljs-comment">// 正数和负数各占1023个数字</span></code></pre><p>所以E的实际取值范围分为负数[0,1022]，正数[1024,2047]</p><p>举个例子</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 举一个我们常用的十进制数字</span><span class="hljs-keyword">const</span> num = <span class="hljs-number">8080</span>;<span class="hljs-comment">// 这个数字转成二进制之后</span><span class="hljs-keyword">const</span> numDec = num.toString(<span class="hljs-number">2</span>);<span class="hljs-comment">// =&gt; 1111110010000</span><span class="hljs-comment">// 用科学计数法表示</span><span class="hljs-comment">// =&gt; 1.111110010000 * 2^12</span><span class="hljs-comment">// E = 12 + 1023 =&gt; 10000001011</span><span class="hljs-comment">// M = 111110010000&#123;000...000补全到52位&#125;</span><span class="hljs-comment">// 结果如下图</span></code></pre><img src="https://i.loli.net/2021/05/12/5cnlKYbfitAZ4vF.jpg" ><p><strong>0.1 + 0.2 === 0.3 ？</strong><br>大家一定经常看到 0.1 + 0.2 这样的送命题，也知道结果肯定不等于0.3</p><p>相似的问题还有</p><p>0.1 + 0.7 === 0.8 ？</p><p>0.2 + 0.4 === 0.6 ？</p><p>等等…</p><p><strong>问题出现的原因</strong><br>在我们了解完JS的Number存储机制后，我们分析一下0.1+0.2中出现的问题</p><p>先分析0.1</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">0.1</span>;<span class="hljs-comment">// 转为二进制</span><span class="hljs-keyword">const</span> aDec = a.toString(<span class="hljs-number">2</span>)<span class="hljs-comment">// =&gt; 0.000110011001100110011001100110011001100110011001100110011001100&#123;后面循环1100&#125;</span><span class="hljs-comment">// 0.1转为二进制时因为有无限循环，在获取尾数时，第53位需要判断是否为1来进行进位，存在精度丢失</span><span class="hljs-comment">// 因为第53位为1的缘故，最后得到的二进制会比真实的0.1要大</span><span class="hljs-comment">// =&gt; 11001100110011001100110011001100110011001100110011010 * 2^-4</span><span class="hljs-comment">// 转换回十进制后</span><span class="hljs-comment">// =&gt; 1.00000000000000005551115123126E-1</span><span class="hljs-comment">// =&gt; 0.100000000000000005551115123126 &gt; 0.1</span></code></pre><p>同理 0.2 也会进行一样的操作</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">0.2</span>;<span class="hljs-comment">// 转为二进制</span><span class="hljs-keyword">const</span> aDec = a.toString(<span class="hljs-number">2</span>)<span class="hljs-comment">// =&gt; 0.001100110011001100110011001100110011001100110011001101&#123;后面循环0011&#125;</span><span class="hljs-comment">// 0.2转为二进制时因为有无限循环，在获取尾数时，第53位需要判断是否为1来进行进位，存在精度丢失</span><span class="hljs-comment">// 因为第53位为1的缘故，最后得到的二进制会比真实的0.1要大</span><span class="hljs-comment">// =&gt; 1100110011001100110011001100110011001100110011001101 * 2^-3</span><span class="hljs-comment">// 转换回十进制后</span><span class="hljs-comment">// =&gt; 2.00000000000000011102230246252E-1</span><span class="hljs-comment">// =&gt; 0.200000000000000011102230246252 &gt; 0.2</span></code></pre><p>0.1+0.2 ===</p><p>0.100000000000000005551115123126 + 0.200000000000000011102230246252 ===</p><p>0.30000000000000004</p><p>到这里真实应该都大白了(●—●)</p><p>最大安全数为什么是 2^53-1<br>JavaScript 中的 API 都是精度安全的吗？</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/371530318">JavaScript-深入理解浮点数精度问题-Ninnka</a><br><a href="https://github.com/camsong/blog/issues/9">JavaScript 浮点数陷阱及解法</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/371530318&quot;&gt;JavaScript-深入理解浮点数精度问题-Ninnka&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;深入问题前的准备&lt;/st</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Promise全解</title>
    <link href="http://example.com/2021/03/25/interview/Promise%E5%85%A8%E8%A7%A3/"/>
    <id>http://example.com/2021/03/25/interview/Promise%E5%85%A8%E8%A7%A3/</id>
    <published>2021-03-25T14:20:54.000Z</published>
    <updated>2021-03-25T14:20:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Promise规范"><a href="#一、Promise规范" class="headerlink" title="一、Promise规范"></a>一、Promise规范</h2><p>Promise/A+兼容扩展了Promise/A而来，ES6里的Promise遵守了Promise/A+规范，也就是当今的标准规范。</p><ol><li><p>一个 Promise 必然处于以下几种状态之一：<br>　　· <strong>pending</strong>（待定/等待）: 初始状态，既没有被兑现，也没有被拒绝。<br>　　· <strong>fulfilled</strong>（已兑现/已完成）: 意味着操作成功完成。<br>　　· <strong>rejected</strong>（已拒绝）: 意味着操作失败。</p></li><li><p>一个Promise对象的状态只能从<code>pending -&gt; fulfilled</code>, 或者<code>pending -&gt; rejected</code>状态，不能逆向转换，也不能互相转换。</p></li><li><p>一个Promise必须实现then方法（then是Promise的核心），而then必须返回一个Promise，同一个Promise的then可以调用多次，执行顺序跟它们的定义顺序一致。</p></li><li><p>then方法接收两个参数: resolve和reject，第一个参数是成功的回调，第二个是失败的回调。同时，then可以接收另一个Promise传入，也接收一个“类then”的对象或方法，即thenable对象。</p></li></ol><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN-Promise</a></p></blockquote><h2 id="二、手写一个Promise"><a href="#二、手写一个Promise" class="headerlink" title="二、手写一个Promise"></a>二、手写一个Promise</h2><ul><li>实现<strong>Promise类</strong>类</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 1、 定义status状态</span><span class="hljs-comment"> * 2、 定义fn1 fn2 数组</span><span class="hljs-comment"> * 3、 定义 resolve reject 方法</span><span class="hljs-comment"> * 4、 executor执行</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>&#123;  <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;  <span class="hljs-comment">// 初始化 status 为等待状态</span>  self.status = <span class="hljs-string">&#x27;pending&#x27;</span>;  self.fn1Callback = [];  self.fn2Callback = [];  <span class="hljs-comment">// resolve 做的事情：</span>  <span class="hljs-comment">// 1. 修改 this 实例的状态</span>  <span class="hljs-comment">// 2. 修改 this 实例的data</span>  <span class="hljs-comment">// 3. 遍历执行this fn1Callback 上挂载的方法</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;  <span class="hljs-keyword">return</span> value.then(resolve, reject);&#125;<span class="hljs-comment">// 异步执行所有的回调函数</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(self.status === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;self.status = <span class="hljs-string">&#x27;resolved&#x27;</span>;self.data = value;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; self.fn1Callback.length; i++) &#123;self.fn1Callback[i](value);&#125;  &#125;&#125;)  &#125;  <span class="hljs-comment">// reject 做的事情</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;<span class="hljs-comment">// 异步执行所有的回调函数</span>  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;self.status = <span class="hljs-string">&#x27;rejected&#x27;</span>;self.data = reason;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; self.fn2Callback.length; i++) &#123;  self.fn2Callback[i](reason);&#125;  &#125;&#125;)  &#125;  <span class="hljs-comment">// 如果 executor 执行报错, 直接执行reject</span>  <span class="hljs-keyword">try</span> &#123;    executor(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (err) &#123;    reject(err);  &#125;&#125;</code></pre><ul><li><p>实现<strong>then</strong>方法</p><ul><li>Promise对象有一个then方法，用来注册在这个Promise状态确定后的回调;</li><li>当Promise状态发生了转变，不论成功或者失败都会调用then方法;</li><li>then方法时在Promise实例上调用，因此then方法的实现是在Promise的prototype上;</li><li>then方法会返回一个Promise，而且是返回一个新的Promise对象</li></ul></li></ul><p><img src="https://i.loli.net/2020/12/13/vBFdAnoX2OrNb14.png" alt="PromiseThen.png"></p><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn1, fn2</span>) </span>&#123;  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">var</span> promose2;  <span class="hljs-comment">// 首先对fn1 fn2 做判断</span>  fn1 = <span class="hljs-keyword">typeof</span> fn1 === <span class="hljs-string">&#x27;function&#x27;</span> ? fn1 : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>&#123; <span class="hljs-keyword">return</span> v; &#125;;  fn2 = <span class="hljs-keyword">typeof</span> fn2 === <span class="hljs-string">&#x27;function&#x27;</span> ? fn2 : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>) </span>&#123; <span class="hljs-keyword">throw</span> r; &#125;;  <span class="hljs-comment">// 执行到 then, 并不确定 Promise的状态</span>  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 先定义一个方法，把方法挂载到 onResolvedCallback 数组上</span>  <span class="hljs-comment">// 方法里面就是调用传入的 fn1</span>  self.onResolvedCallback.push(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">let</span> x = fn1(value);  resolvePromise(promise2, x, resolve, reject);&#125; <span class="hljs-keyword">catch</span>(r) &#123;  reject(r);&#125;  &#125;)  self.onRejectedCallback.push(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;    <span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">let</span> x = fn2(reason);  resolvePromise(promise2, x, resolve, reject)&#125; <span class="hljs-keyword">catch</span>(r) &#123;  reject(r);&#125;  &#125;)&#125;)  &#125;  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">&#x27;resolved&#x27;</span>) &#123;<span class="hljs-comment">// then 执行后， 返回一个Promise</span><span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 异步执行onResolved</span>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">// 执行 fn1(), 拿到结果</span>  <span class="hljs-comment">// fn1 是用户传入的, 所以fn1的返回值 就可能有很多种,因此封装到 resolvePromise处理</span>  <span class="hljs-keyword">let</span> x = fn1(self.data);  resolvePromise(promise2, x, resolve, reject);&#125; <span class="hljs-keyword">catch</span> (err) &#123;reject(reason);&#125;  &#125;)&#125;)  &#125;  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 异步执行onRejected</span>        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = fn2(self.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (reason) &#123;          reject(reason);        &#125;      &#125;)    &#125;)  &#125;&#125;<span class="hljs-comment">// 1. 普通值</span><span class="hljs-comment">// 2. promise 值</span><span class="hljs-comment">// 3. thenable 的值，执行 then</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// 为了防止循环引用</span>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Chaining cycle detected for promise!&#x27;</span>));  &#125;  <span class="hljs-comment">// 如果 x 是 promise</span>  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;x.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;  resolve(data)&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;  reject(e)&#125;);<span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-comment">// 如果 x 是 object 类型或者是 function</span>  <span class="hljs-keyword">if</span> ((x !== <span class="hljs-literal">null</span>) &amp;&amp; ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) || (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>))) &#123;<span class="hljs-comment">// 拿x.then可能会报错</span><span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">// 先拿到 x.then</span>    <span class="hljs-keyword">var</span> then = x.then    <span class="hljs-keyword">var</span> called;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;    <span class="hljs-comment">// 这里的写法，是 then.call(this, fn1, fn2)</span>    then.call(x, <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<span class="hljs-comment">// called 是干什么用的呢？</span><span class="hljs-comment">// 有一些 promise 实现的不是很规范，瞎搞的，比如说，fn1, fn2 本应执行一个，</span><span class="hljs-comment">// 但是有些then实现里面，fn1, fn2都会执行</span><span class="hljs-comment">// 为了 fn1 和 fn2 只能调用一个, 设置一个 called 标志位</span><span class="hljs-keyword">if</span> (called) &#123;<span class="hljs-keyword">return</span>;&#125;called = <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> resolvePromise(promise2, y, resolve, reject);&#125;, <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (called) &#123;<span class="hljs-keyword">return</span>;&#125;called = <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> reject(r);&#125;);&#125; <span class="hljs-keyword">else</span> &#123;resolve(x);&#125;&#125; <span class="hljs-keyword">catch</span> (err) &#123;  <span class="hljs-keyword">if</span> (called) &#123;        <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">return</span> reject(e);&#125;  &#125; <span class="hljs-keyword">else</span> &#123;  resolve(x);  &#125;&#125;</code></pre><blockquote><p><a href="https://mp.weixin.qq.com/s/oURuka-Qgbbj8JKtlYNMaw">可能是目前最易理解的手写promise</a></p></blockquote><h2 id="三、手写Promise-all-Promise-retry"><a href="#三、手写Promise-all-Promise-retry" class="headerlink" title="三、手写Promise.all / Promise.retry"></a>三、手写Promise.all / Promise.retry</h2><p><strong><code>Promise.all</code></strong></p><pre><code class="hljs javascript"><span class="hljs-comment">// 只要有一个 promise 失败即返回失败的结果</span><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;argument must be a array&#x27;</span>);&#125;<span class="hljs-keyword">let</span> dataArr = [];<span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;  <span class="hljs-keyword">let</span> p = arr[i];  p.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    dataArr.push(data);    num ++;    <span class="hljs-keyword">if</span> (num === arr.length) &#123;      <span class="hljs-keyword">return</span> resolve(dataArr);    &#125;  &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> reject(e))&#125;  &#125;)&#125;</code></pre><p><strong><code>Promise.retry</code></strong></p><pre><code class="hljs javascript"><span class="hljs-comment">// retry 是报错会尝试，尝试超过一定次数才真正的 reject</span><span class="hljs-built_in">Promise</span>.retry = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">getData, times, delay</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attemp</span>(<span class="hljs-params"></span>) </span>&#123;  getData().then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;resolve(data);  &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (times === <span class="hljs-number">0</span>) &#123;  reject(err);&#125; <span class="hljs-keyword">else</span> &#123;  times --;  <span class="hljs-built_in">setTimeout</span>(attemp, delay);&#125;  &#125;)&#125;attemp();  &#125;)&#125;</code></pre><h2 id="四、promise-题"><a href="#四、promise-题" class="headerlink" title="四、promise 题"></a>四、promise 题</h2><p>1</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;resolve(a)&#125;).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`成功：<span class="hljs-subst">$&#123;result&#125;</span>`</span>)<span class="hljs-keyword">return</span> result * <span class="hljs-number">10</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`成功：<span class="hljs-subst">$&#123;result&#125;</span>`</span>)&#125;,<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`失败：<span class="hljs-subst">$&#123;reason&#125;</span>`</span>)&#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`catch：<span class="hljs-subst">$&#123;e&#125;</span>`</span>)&#125;)</code></pre><p>2</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">await</span> async2();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);&#125;async1();<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);&#125;, <span class="hljs-number">0</span>)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)<span class="hljs-comment">// script start -&gt; Promise -&gt; script end -&gt; async2 end -&gt; promise1 -&gt; async1 end -&gt; promise2 -&gt; setTimeout</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Promise规范&quot;&gt;&lt;a href=&quot;#一、Promise规范&quot; class=&quot;headerlink&quot; title=&quot;一、Promise规范&quot;&gt;&lt;/a&gt;一、Promise规范&lt;/h2&gt;&lt;p&gt;Promise/A+兼容扩展了Promise/A而来，ES6里的Pr</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="Promise" scheme="http://example.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>网络/浏览器百问百答</title>
    <link href="http://example.com/2021/03/11/interview/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2021/03/11/interview/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/</id>
    <published>2021-03-11T11:53:02.000Z</published>
    <updated>2021-03-11T11:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-谈谈你对dns-prefetch的理解"><a href="#1-谈谈你对dns-prefetch的理解" class="headerlink" title="1. 谈谈你对dns-prefetch的理解"></a>1. 谈谈你对dns-prefetch的理解</h3><p><a href="https://zhuanlan.zhihu.com/p/92700557">JS的Reflect学习和应用</a></p><p>DNS是什么 ———— Domain Name System, 域名系统, 作为域名和IP地址相互映射的一个分布式数据库.</p><p>DNS-Perfetching: DNS预解析, 浏览器根据自定义的规则, 提前去解析后面可能会用到的域名, 来加速网站的访问速度, 以免延迟。</p><p>方式:</p><pre><code class="hljs javascript">&lt;link rel=<span class="hljs-string">&quot;dns-prefetch&quot;</span> href=<span class="hljs-string">&quot;//wq.test.com&quot;</span>&gt;</code></pre><p>总结：</p><ol><li><p>DNS Prefetching是提前加载域名解析的,省去了解析时间。</p></li><li><p>a标签的href在Chrome、Firefox、高版本IE等浏览器会自动开启DNS Prefetching. 但是在HTTPS协议下不起作用，需要通过meta标签手动设置打开。<br><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code></p></li><li><p>DNS预解析对什么样的网站更有用呢？当你的网站引用了很多其他域名的资源, 类似淘宝这种网站。如果你的网站的资源基本都在你的本域名下, 那么这个基本没有什么作用了。因为DNS Chrome在访问你的网站就帮你缓存了。</p></li></ol><h3 id="2-get-post请求传参长度有什么特点"><a href="#2-get-post请求传参长度有什么特点" class="headerlink" title="2. get/post请求传参长度有什么特点"></a>2. get/post请求传参长度有什么特点</h3><p>HTTP协议相关只是，待补充<br><a href="https://juejin.cn/post/6860253625030017031">GET 请求能传图片吗</a>  </p><h3 id="3-前端需要注意哪些SEO"><a href="#3-前端需要注意哪些SEO" class="headerlink" title="3. 前端需要注意哪些SEO"></a>3. 前端需要注意哪些SEO</h3><ol><li><p>合理的title、description、keyWords<br>　　搜索对这三项的权重逐渐减小：　　<br>　　· title 值强调重点即可，不同title要有所不同，重要关键词不要超过两次，而且要靠前<br>　　· description 把页面内容高度概括，长度合适，不要过分堆砌关键字，不同页面的<br>　　· keyWords 列举出重要关键词即可</p></li><li><p>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</p></li><li><p>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</p></li><li><p>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p></li><li><p>少用 iframe(搜索引擎不会抓取 iframe 中的内容)</p></li><li><p>非装饰性图片必须加 alt</p></li><li><p>提高网站速度(网站速度是搜索引擎排序的一个重要指标)</p></li></ol><h3 id="4-实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后-退时正确响应。给出你的技术实现方案？"><a href="#4-实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后-退时正确响应。给出你的技术实现方案？" class="headerlink" title="4. 实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后 退时正确响应。给出你的技术实现方案？"></a>4. 实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后 退时正确响应。给出你的技术实现方案？</h3><p><a href="https://www.renfei.org/blog/html5-introduction-3-history-api.html">HTML5 简介（三）：利用 History API 无刷新更改地址栏</a><br><a href="https://juejin.cn/post/6844903558576341000">简单聊聊H5的pushState与replaceState</a><br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad">pushState + ajax 实现浏览器无刷新前进后退</a></p><p>方案：</p><ol><li><p>利用History.pushState(state, title[, url]) API记录当前浏览器会话的历史堆栈中需要保留的状态（state）,<br>浏览器历史记录可以看作一个「栈」，栈是一种后进先出的结构，用户每点开一个新网页，都会将当前网页加入到栈中，叫「入栈」。用户每次点击「后退」按钮都会取走最上面的那个记录，叫做「出栈」。而每次浏览器显示的自然是最顶端的盘子的内容。<br>执行pushState函数之后，会往浏览器的历史记录中添加一条新记录，同时改变地址栏的地址内容。</p></li><li><p>再利用popstate监听。 当用户点击浏览器的「前进」、「后退」按钮时，就会触发popstate事件。你可以监听这一事件，从而作出反应。</p><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;popstate&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-keyword">var</span> state = e.state;    <span class="hljs-comment">// do something...</span>&#125;);</code></pre></li><li><p>我们通过对 window.onpopstate 事件监听来响应浏览器 的前进后退操作。</p></li></ol><p>使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问 题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配 合将其重定向到一个页面。</p><h3 id="5-如何优化SPA应用的首屏加载速度慢的问题？"><a href="#5-如何优化SPA应用的首屏加载速度慢的问题？" class="headerlink" title="5. 如何优化SPA应用的首屏加载速度慢的问题？"></a>5. 如何优化SPA应用的首屏加载速度慢的问题？</h3><ul><li>将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</li><li>在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</li><li>root中插入loading 或者 骨架屏 prerender-spa-plugin，提升用户体验；</li><li>如果在webview中的页面，可以进行页面预加载</li><li>独立打包异步组件公共 Bundle，以提高复用性&amp;缓存命中率</li><li>静态文件本地缓存，有两种方式分别为HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头和Service Worker离线缓存</li><li>配合 PWA 使用</li><li>SSR</li><li>root中插入loading 或者 骨架屏 prerender-spa-plugin</li><li>使用 Tree Shaking 减少业务代码体积 更多参考：<a href="https://github.com/LuckyWinty/fe-weekly-questions/issues/69">如何优化SPA应用的首屏加载速度慢的问题？</a></li></ul><h3 id="6-Reflect-反射-对象创建目的？"><a href="#6-Reflect-反射-对象创建目的？" class="headerlink" title="6. Reflect(反射) 对象创建目的？"></a>6. Reflect(反射) 对象创建目的？</h3><p>MDN(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN-Reflect</a>)对Reflect的定义：Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。</p><ul><li>将 Object对象的一些明显属于语言内部的方法（ 比 如 Object.defineProperty）放到 Reflect 对象上。</li><li>修改某些 Object 方法的返回结果，让其变得更合理。</li><li>让 Object 操作都变成函数行为。</li><li>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象 的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可 以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。</li></ul><p>也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取 默认行为。</p><blockquote><p>参考：<br><a href="https://mp.weixin.qq.com/s/kWULrNVG7XQ1Zq4BW4Z52w">12 道腾讯前端面试真题及答案整理</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-谈谈你对dns-prefetch的理解&quot;&gt;&lt;a href=&quot;#1-谈谈你对dns-prefetch的理解&quot; class=&quot;headerlink&quot; title=&quot;1. 谈谈你对dns-prefetch的理解&quot;&gt;&lt;/a&gt;1. 谈谈你对dns-prefetch的理解</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>interview题 归类</title>
    <link href="http://example.com/2021/03/03/interview/%E6%96%87%E7%AB%A0%E5%BD%92%E7%B1%BB/"/>
    <id>http://example.com/2021/03/03/interview/%E6%96%87%E7%AB%A0%E5%BD%92%E7%B1%BB/</id>
    <published>2021-03-03T11:34:50.000Z</published>
    <updated>2021-03-03T11:34:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6860253625030017031">1、GET 请求能传图片吗</a><br>　　tags: Http协议、get/Post</p><p>1、错误收集  sendTry<br>2、性能监控<br>3、自动化测试<br>4、微前端<br>5、如何体现项目管理能力</p><p>正则表达式 - 算法</p><p>例题1：<br><a href="https://leetcode-cn.com/problems/positions-of-large-groups/">https://leetcode-cn.com/problems/positions-of-large-groups/</a></p><p>// matchAll<br>var largeGroupPositions = function(s) {<br>    let g = s.matchAll(/([a-z])\1{2,}/g), r = [], t<br>    while (t = g.next().value) r.push([t.index, t.index + t[0].length - 1])<br>    return r<br>};</p><p>// replace<br>var largeGroupPositions = function(s) {<br>    const r = []<br>    s.replace(/([a-z])\1{2,}/g, (a, _, i)=&gt; r.push([i, i + a.length - 1]))<br>    return r<br>};</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6860253625030017031&quot;&gt;1、GET 请求能传图片吗&lt;/a&gt;&lt;br&gt;　　tags: Http协议、get/Post&lt;/p&gt;
&lt;p&gt;1、错误收集  sendTry&lt;br&gt;2、性能监控&lt;br&gt;3、自</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js-优化方案</title>
    <link href="http://example.com/2021/03/03/interview/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2021/03/03/interview/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</id>
    <published>2021-03-03T11:34:40.000Z</published>
    <updated>2021-03-03T11:34:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、代码层面"><a href="#一、代码层面" class="headerlink" title="一、代码层面"></a>一、代码层面</h2><h3 id="1、使用懒加载和预加载"><a href="#1、使用懒加载和预加载" class="headerlink" title="1、使用懒加载和预加载"></a>1、使用懒加载和预加载</h3><h4 id="1、懒加载"><a href="#1、懒加载" class="headerlink" title="1、懒加载"></a>1、懒加载</h4><p>懒加载：懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。</p><p>目的：</p><ul><li>能提升用户的体验</li><li>减少无效资源的加载</li><li>防止并发加载的资源过多会阻塞js的加载</li></ul><p>原理：首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中，<br>当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。</p><p>监听页面滚动的方法：<br>1、<code>document.addEventListener(&quot;scroll&quot;, () =&gt; &#123; &#125;)</code><br>2、<code>IntersectionObserver</code></p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 实现方式一: document.addEventListener(&quot;scroll&quot;, () =&gt; &#123; &#125;) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Lazyload<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><span class="css"><span class="hljs-selector-class">.image-item</span> &#123;</span><span class="css"><span class="hljs-attribute">display</span>: block;</span><span class="css"><span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">50px</span>;</span><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; <span class="hljs-comment">/* 一定记得设置图片高度 */</span></span><span class="css">&#125;</span><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;image-item&quot;</span> <span class="hljs-attr">lazyload</span>=<span class="hljs-string">&quot;true&quot;</span>  <span class="hljs-attr">data-original</span>=<span class="hljs-string">&quot;images/1.png&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;image-item&quot;</span> <span class="hljs-attr">lazyload</span>=<span class="hljs-string">&quot;true&quot;</span>  <span class="hljs-attr">data-original</span>=<span class="hljs-string">&quot;images/2.png&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot;  data-original=&quot;images/3.png&quot;/&gt;</span><span class="hljs-comment">img4、img5、img6...</span><span class="hljs-comment">&lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot;  data-original=&quot;images/12.png&quot;/&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><span class="javascript">   <span class="hljs-comment">// 获取可视区高度</span></span><span class="javascript"><span class="hljs-keyword">var</span> viewHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> eles = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;img[data-original][lazyload]&#x27;</span>)</span><span class="javascript"><span class="hljs-built_in">Array</span>.prototype.forEach.call(eles, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,index</span>)</span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> rect</span><span class="javascript"><span class="hljs-keyword">if</span> (item.dataset.original === <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">return</span>;</span><span class="javascript"><span class="hljs-comment">// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span></span><span class="javascript">rect = item.getBoundingClientRect()</span><span class="javascript"><span class="hljs-keyword">if</span> (rect.bottom &gt;= <span class="hljs-number">0</span> &amp;&amp; rect.top &lt; viewHeight) &#123;</span><span class="javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();</span><span class="javascript">img.src = item.dataset.original;</span><span class="javascript">img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">item.src = img.src;</span><span class="javascript">&#125;</span><span class="javascript"><span class="hljs-comment">// 移除属性，下次不再遍历</span></span><span class="javascript">item.removeAttribute(<span class="hljs-string">&quot;data-original&quot;</span>)</span><span class="javascript">item.removeAttribute(<span class="hljs-string">&quot;lazyload&quot;</span>)</span><span class="javascript">&#125;()</span><span class="javascript">&#125;</span><span class="javascript">&#125;)</span><span class="javascript">&#125;</span><span class="javascript"><span class="hljs-comment">// 刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片</span></span><span class="javascript">lazyload()</span><span class="javascript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, lazyload)</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 实现方式二: IntersectionObserver （伪代码，未做测试）</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">entry</span>) </span>&#123;  <span class="hljs-keyword">if</span>(entry[<span class="hljs-number">0</span>].isIntersecting) &#123;   <span class="hljs-comment">// 出现在可视区内(默认 viewport)</span>    entry[<span class="hljs-number">0</span>].target.src = entry[<span class="hljs-number">0</span>].target.dataset.original;    observer.unobserve(entry[<span class="hljs-number">0</span>].target);  &#125;&#125;<span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(callback); <span class="hljs-comment">// 这里可以指定第二个参数做些定制化配置</span><span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;img&#x27;</span>);observer.observe(img);</code></pre><hr><p>扩展 MutationObserver、IntersectionObserver、ResizeObserver：</p><ul><li><p><code>MutationObserver</code>: 监控DOM节点的变化，如 属性变化、子节点增删改、子树的变化等</p><pre><code class="hljs javascript"><span class="hljs-comment">// 1、选择需要观察变动的节点</span><span class="hljs-keyword">const</span> targetNode = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;some-id&#x27;</span>);<span class="hljs-comment">// 2、观察器的配置（需要观察什么变动）</span><span class="hljs-keyword">const</span> config = &#123; <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span> &#125;;<span class="hljs-comment">// 3、当观察到变动时执行的回调函数</span><span class="hljs-keyword">const</span> callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mutationsList, observer</span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> mutation <span class="hljs-keyword">of</span> mutationsList) &#123;<span class="hljs-keyword">if</span> (mutation.type === <span class="hljs-string">&#x27;childList&#x27;</span>) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;A child node has been added or removed.&#x27;</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mutation.type === <span class="hljs-string">&#x27;attributes&#x27;</span>) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The &#x27;</span> + mutation.attributeName + <span class="hljs-string">&#x27; attribute was modified.&#x27;</span>);&#125;&#125;&#125;;<span class="hljs-comment">// 4、创建一个观察器实例并传入回调函数</span><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(callback);<span class="hljs-comment">// 5、以上述配置开始观察目标节点</span>observer.observe(targetNode, config);<span class="hljs-comment">// 6、之后，可停止观察</span>observer.disconnect();</code></pre></li><li><p><code>IntersectionObserver</code>: 目标A是否与目标B相交</p><pre><code class="hljs javascript"><span class="hljs-comment">// 图片懒加载的例子</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">entry</span>) </span>&#123;<span class="hljs-keyword">if</span>(entry[<span class="hljs-number">0</span>].isIntersecting) &#123;   <span class="hljs-comment">// 出现在可视区内(默认 viewport)</span>entry[<span class="hljs-number">0</span>].target.src = entry[<span class="hljs-number">0</span>].target.dataset.src;observer.unobserve(entry[<span class="hljs-number">0</span>].target);&#125;&#125;<span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(callback); <span class="hljs-comment">// 这里可以指定第二个参数做些定制化配置</span><span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;img&#x27;</span>);observer.observe(img);</code></pre><p>  详细解释：<a href="https://letswrite.tw/intersection-oserver-basic/">IntersectionObserver：上篇-基本介绍及使用</a></p></li><li><p><code>ResizeObserver</code>: 专门用来观察DOM元素的尺寸是否发生了变化，不光是窗体resize</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ro = <span class="hljs-keyword">new</span> ResizeObserver( <span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries) &#123;<span class="hljs-keyword">const</span> cr = entry.contentRect;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Element:&#x27;</span>, entry.target);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Element size: <span class="hljs-subst">$&#123;cr.width&#125;</span>px x <span class="hljs-subst">$&#123;cr.height&#125;</span>px`</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Element padding: <span class="hljs-subst">$&#123;cr.top&#125;</span>px ; <span class="hljs-subst">$&#123;cr.left&#125;</span>px`</span>);&#125;&#125;);<span class="hljs-comment">// 观察一个或多个元素</span>ro.observe(eleZxx);<span class="hljs-comment">/*</span><span class="hljs-comment">注意：观测的是 contentRect，只有 content 改变（margin,padding不行）才会触发回调</span><span class="hljs-comment">用途：</span><span class="hljs-comment">  1、原生resize行为的检测，如 textarea 的拉升</span><span class="hljs-comment">  2、感知交互行为的发生（无埋点方案）</span><span class="hljs-comment">  3、感知元素是否显示或隐藏（ MutationObserver 有时做不到）</span><span class="hljs-comment">*/</span></code></pre><p>  详细解释: <a href="https://www.zhangxinxu.top/wordpress/2020/03/dom-resize-api-resizeobserver/">检测DOM尺寸变化JS API ResizeObserver简介</a></p></li></ul><h4 id="2、预加载"><a href="#2、预加载" class="headerlink" title="2、预加载"></a>2、预加载</h4><p>预加载：预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</p><p>目的：在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。</p><p>实现方法：</p><ol><li><p>使用HTML标签<br> <code>&lt;img src=&quot;http://pic26.nipic.com/20121213/61681830044449030002.jpg&quot; style=&quot;display:none&quot;/&gt;</code></p></li><li><p>使用Image对象</p> <pre><code class="hljs javascript"><span class="hljs-comment">// 预加载</span>  &lt;script src=<span class="hljs-string">&quot;./myPreload.js&quot;</span>&gt;&lt;/script&gt;<span class="hljs-comment">// myPreload.js文件</span><span class="hljs-keyword">var</span> image= <span class="hljs-keyword">new</span> Image()image.src=<span class="hljs-string">&quot;http://pic26.nipic.com/20121213/61681830044449030002.jpg&quot;</span></code></pre></li><li><p>使用XMLHttpRequest对象,虽然存在跨域问题，但会精细控制预加载过程</p> <pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xmlhttprequest = <span class="hljs-keyword">new</span> XMLHttpRequest();xmlhttprequest.onreadystatechange = callback;xmlhttprequest.onprogress = progressCallback;xmlhttprequest.open(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;http://image.baidu.com/mouse,jpg&quot;</span>,<span class="hljs-literal">true</span>);xmlhttprequest.send();<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">if</span>(xmlhttprequest.readyState == <span class="hljs-number">4</span> &amp;&amp; xmlhttprequest.status == <span class="hljs-number">200</span>)&#123;<span class="hljs-keyword">var</span> responseText = xmlhttprequest.responseText;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Request was unsuccessful:&quot;</span> + xmlhttprequest.status);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">progressCallback</span>(<span class="hljs-params">e</span>)</span>&#123;e = e || event;<span class="hljs-keyword">if</span>(e.lengthComputable)&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Received&quot;</span>+e.loaded+<span class="hljs-string">&quot;of&quot;</span>+e.total+<span class="hljs-string">&quot;bytes&quot;</span>)&#125;&#125;</code></pre></li><li><p>使用PreloadJS库<br>reloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好.</p> <pre><code class="hljs javascript"><span class="hljs-comment">//使用preload.js</span><span class="hljs-comment">// 默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域</span><span class="hljs-keyword">var</span> queue = <span class="hljs-keyword">new</span> createjs.LoadQueue();queue.on(<span class="hljs-string">&quot;complete&quot;</span>, handleComplete, <span class="hljs-built_in">this</span>);queue.loadManifest([&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&quot;myImage&quot;</span>,<span class="hljs-attr">src</span>:<span class="hljs-string">&quot;http://pic26.nipic.com/20121213/6168183  0044449030002.jpg&quot;</span>&#125;,&#123;id：<span class="hljs-string">&quot;myImage2&quot;</span>，src:<span class="hljs-string">&quot;http://pic9.nipic.com/20100814/2839526  1931471581702.jpg&quot;</span>&#125;]);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleComplete</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">var</span> image=queue.getResuLt(<span class="hljs-string">&quot;myImage&quot;</span>);<span class="hljs-built_in">document</span>.body.appendChild(image);&#125;</code></pre></li></ol><h4 id="3、懒加载和预加载的对比"><a href="#3、懒加载和预加载的对比" class="headerlink" title="3、懒加载和预加载的对比"></a>3、懒加载和预加载的对比</h4><p>两者都是提高页面性能有效的办法，<strong>两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力</strong>。</p><h2 id="二、打包层面"><a href="#二、打包层面" class="headerlink" title="二、打包层面"></a>二、打包层面</h2><blockquote><p><a href="https://juejin.cn/post/6844903614138286094">懒加载和预加载</a><br><a href="https://www.jianshu.com/p/666ede29d5a9">MutationObserver、IntersectionObserver、ResizeObserver</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、代码层面&quot;&gt;&lt;a href=&quot;#一、代码层面&quot; class=&quot;headerlink&quot; title=&quot;一、代码层面&quot;&gt;&lt;/a&gt;一、代码层面&lt;/h2&gt;&lt;h3 id=&quot;1、使用懒加载和预加载&quot;&gt;&lt;a href=&quot;#1、使用懒加载和预加载&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>React百问百答</title>
    <link href="http://example.com/2021/03/03/interview/interview-React/"/>
    <id>http://example.com/2021/03/03/interview/interview-React/</id>
    <published>2021-03-03T11:34:27.000Z</published>
    <updated>2021-03-03T11:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、生命周期相关"><a href="#一、生命周期相关" class="headerlink" title="一、生命周期相关"></a>一、生命周期相关</h2><h3 id="1、React-V16生命周期发生了什么变化？"><a href="#1、React-V16生命周期发生了什么变化？" class="headerlink" title="1、React V16生命周期发生了什么变化？"></a>1、React V16生命周期发生了什么变化？</h3><p>React16废弃的三个生命周期函数</p><ul><li><p><del>componentWillMount</del></p></li><li><p><del>componentWillReceiveProps</del></p></li><li><p><del>componentWillUpdate</del></p><p>取而代之的是两个新的生命中后期函数:</p></li><li><p>static getDerivedStateFromProps</p></li><li><p>getSnapshotBeforeUpdate</p><blockquote><p>注：目前在16版本中componentWillMount、componentWillReceiveProps、componentWillUpdate并未完全删除这三个生命周期函数，而且新增了UNSAFE_componentWillMount、UNSAFE_componentWillReceiveProps、UNSAFE_componentWillUpdate三个函数，官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们  </p></blockquote></li></ul><h3 id="2、setState-异步设计原理"><a href="#2、setState-异步设计原理" class="headerlink" title="2、setState 异步设计原理"></a>2、setState 异步设计原理</h3><p>异步的作用是<strong>提高性能，降低冗余。简单说，因为state具有更新队列，将所有更新都累计到最后进行批量合，并再去渲染可以极大提高应用的性能，像源生JS那样修改后就进行DOM的重渲染，会造成巨大的性能消耗。</strong>同样这与react优化后的diff算法也有关系。</p><p><strong>结论：</strong><br><strong>1. setState只在合成事件和钩子函数中是”异步”的，在原生事件和setTimeout中都是同步的。</strong><br><strong>2. setState的”异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的”异步”，当然可以通过第二个参数setState(partialState, callback)中的callback拿到更新后的结果。</strong><br><strong>3. setState的批量更新优化也是建立在”异步”（合成事件、钩子函数）之上的。在原生事件和setTimeout中不会批量更新，在”异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。</strong></p><ul><li><p>setState 中的批量更新<br>在setState的时候React内部会创建一个updateQueue，通过firstUpdate、lastUpdate、lastUpdate.next 去维护一个更新的队列，在最终的perforWork中，相同的key会被覆盖，只会对最后一次的setState进行更新。</p></li><li><p>为什么原生事件中 setState 可以同步拿到更新后的state的值？<br>原生事件自带的事件监听addEventListener，或者用原生js、jq直接document.querySelector().onclick这种绑定事件的实行都属于原生事件。<br>由于原生事件没有走合成事件的那一大堆逻辑，直接触发click事件，到requestWork，在requestWork里由于expirationTime===Sync的原因，直接走了performSyncWork去更新，并不想合成事件或者钩子函数中被return，所以原生事件中的setState能同步拿到更新后的state的值。</p></li><li><p>为什么 setTimeout 的 setSate 可以同步拿到更新后的 state 的值？<br>由于interactiveUpdates文件中，setTimeout( () =&gt; { this.setState() }, 0) 在try代码块中，当你try代码执行到setTimeout的时候，把它丢到了队列里，并没有去执行，而是限制性finally代码块，等finally执行完了，isBatchingUpdates又变为了false，导致最红去执行队列的setState时候，requestWork走的是和原生事件一样的 expirationTime === Sync，直接走了performSyncWork去更新，表现就会和原生事件一样了。</p></li></ul><h3 id="3、在哪些钩子函数里调用setState不会引起组件重新渲染"><a href="#3、在哪些钩子函数里调用setState不会引起组件重新渲染" class="headerlink" title="3、在哪些钩子函数里调用setState不会引起组件重新渲染"></a>3、在哪些钩子函数里调用setState不会引起组件重新渲染</h3><ol><li><p>componentWillMount<br>因为这个钩子函数是在组件挂载到DOM前调用，且只会被调用一次。</p></li><li><p>componentWillReceiveProps<br>因为<code>componentWillReceiveProps</code>中判断<code>props</code>是否发生变，若变化了，<code>this.setState</code>将引起<code>state</code>变化，从而引起<code>render</code>，此时就没必要再做第二次因重传<code>props</code>引起的<code>render</code>了，不然重复做一样的渲染了。</p></li></ol><h2 id="二、输出结果"><a href="#二、输出结果" class="headerlink" title="二、输出结果"></a>二、输出结果</h2><h3 id="1、输出结果是什么，如何改进"><a href="#1、输出结果是什么，如何改进" class="headerlink" title="1、输出结果是什么，如何改进"></a>1、输出结果是什么，如何改进</h3><pre><code class="hljs javascript">state = &#123;    <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-title">ComponentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.setState(&#123;        <span class="hljs-attr">num</span>: <span class="hljs-built_in">this</span>.state.num + <span class="hljs-number">1</span>    &#125;, <span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.num) <span class="hljs-comment">// 1</span>    &#125;)    <span class="hljs-built_in">this</span>.setState(&#123;        <span class="hljs-attr">num</span>:<span class="hljs-built_in">this</span>.state.num + <span class="hljs-number">1</span>    &#125;, <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.num) <span class="hljs-comment">// 1</span>    &#125;)&#125;</code></pre><p>两次都打印1的原因是：回调函数仅仅可以获取到当前修改后的state，再次执行setState方法<strong>获取到的state值依然为挂载后初始state值</strong>。</p><p>解决办法：</p><pre><code class="hljs javascript">state = &#123;    <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-title">ComponentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.setState(        <span class="hljs-function"><span class="hljs-params">preState</span> =&gt;</span> &#123;            <span class="hljs-attr">num</span>: preState.num + <span class="hljs-number">1</span>        &#125;, <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.num) <span class="hljs-comment">// 1</span>        &#125;    )    <span class="hljs-built_in">this</span>.setState(        <span class="hljs-function"><span class="hljs-params">preState</span> =&gt;</span> &#123;            <span class="hljs-attr">num</span>: preState.num + <span class="hljs-number">1</span>        &#125;, <span class="hljs-function">()=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.num) <span class="hljs-comment">// 2</span>        &#125;    )&#125;</code></pre><p>实现原理 是setState本身可以接受函数作为参数，而在这里我们使用的参数就是上一次的state。</p><h2 id="2、输出结果是什么"><a href="#2、输出结果是什么" class="headerlink" title="2、输出结果是什么"></a>2、输出结果是什么</h2><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  state = &#123;    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>  &#125;;​  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">// 生命周期中调用</span>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;lifecycle: &quot;</span> + <span class="hljs-built_in">this</span>.state.count);    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// setTimeout中调用</span>      <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout: &quot;</span> + <span class="hljs-built_in">this</span>.state.count);    &#125;, <span class="hljs-number">0</span>);    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div2&quot;</span>).addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-built_in">this</span>.increment2);  &#125;​  increment = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 合成事件中调用</span>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;react event: &quot;</span> + <span class="hljs-built_in">this</span>.state.count);  &#125;;​  increment2 = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 原生事件中调用</span>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;dom event: &quot;</span> + <span class="hljs-built_in">this</span>.state.count);  &#125;;​  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>couont: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.increment&#125;</span>&gt;</span></span><span class="xml">          click me and count+1</span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span>click me and count+1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    );  &#125;&#125;</code></pre><blockquote><p> 参考<br><a href="https://zhuanlan.zhihu.com/p/50335551">setState异步、同步与进阶</a><br><a href="https://zhuanlan.zhihu.com/p/61847529">React的setState你真的用对了吗？</a><br><a href="https://juejin.cn/post/6844903636749778958#comment">你真的理解setState吗？</a>  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、生命周期相关&quot;&gt;&lt;a href=&quot;#一、生命周期相关&quot; class=&quot;headerlink&quot; title=&quot;一、生命周期相关&quot;&gt;&lt;/a&gt;一、生命周期相关&lt;/h2&gt;&lt;h3 id=&quot;1、React-V16生命周期发生了什么变化？&quot;&gt;&lt;a href=&quot;#1、Reac</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>hexo help</title>
    <link href="http://example.com/2021/03/03/hello-world/"/>
    <id>http://example.com/2021/03/03/hello-world/</id>
    <published>2021-03-03T11:34:24.000Z</published>
    <updated>2021-03-03T11:34:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>清除缓存 &amp;&amp; 生成 &amp;&amp; 启动服务预览</p><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>部署到服务器</p><pre><code class="hljs bash">hexo d</code></pre><h2 id="命令简写"><a href="#命令简写" class="headerlink" title="命令简写"></a>命令简写</h2><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo new <span class="hljs-string">&quot;我的博客&quot;</span> <span class="hljs-comment">#新建文章</span>hexo g == hexo generate <span class="hljs-comment">#生成</span>hexo s == hexo server <span class="hljs-comment">#启动服务预览</span>hexo d == hexo deploy <span class="hljs-comment">#部署</span>  hexo server <span class="hljs-comment">#Hexo会监视文件变动并自动更新，无须重启服务器</span>hexo server -s <span class="hljs-comment">#静态模式</span>hexo server -p 5000 <span class="hljs-comment">#更改端口</span>hexo server -i 192.168.1.1 <span class="hljs-comment">#自定义 IP</span>hexo clean <span class="hljs-comment">#清除缓存，若是网页正常情况下可以忽略这条命令</span>刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://example.com/2021/02/22/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/nginx/"/>
    <id>http://example.com/2021/02/22/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/nginx/</id>
    <published>2021-02-22T11:38:06.000Z</published>
    <updated>2021-02-22T11:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/01/HMLZ7bmBI23PkxD.png" alt="nginx.png"></p><h2 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1 负载均衡"></a>1 负载均衡</h2><p>当用户访问web的时候，首先访问到的是负载均衡器，再通过负载均衡器将请求转发给后台服务器。<br>负载均衡的几种常用方式：</p><ul><li>轮询（默认）</li></ul><pre><code class="hljs javacript">// nginx.configupstream backserver &#123;  server 192.168.0.1;  server 192.168.0.2;&#125;</code></pre><ul><li>权重（weight）—指定不同ip的权重，权重越高，访问越大，适用于不同性能的服务器</li></ul><pre><code class="hljs javacript">// nginx.configupstream backserver &#123;    server 192.168.0.1 weight=2;  server 192.168.0.2 weight=8;&#125;</code></pre><ul><li>相应时间来分配—公平竞争，谁快谁处理， 不过需要依赖第三方插件nginx-upstream-fair</li></ul><pre><code class="hljs javacript">// nginx.configupstream backserver &#123;  server 192.168.0.1;  server 192.168.0.2;  fair;&#125;server &#123;  listen 80;  server_name localhost;  location &#123;    proxy_pass  http://backserver;    &#125;&#125;</code></pre><p>nginx自带健康检查模块<code>（ngx_upstream_module）</code>，本质上是服务器心跳的检查，通过定时轮询向集群里的服务器健康检查请求，用来检查服务器是否处于异常状态。<br>健康检查涉及到两个配置属性：</p><ul><li>fail_timeout：设定服务器认为不可用的时间段以及统计失败尝试次数的时间段，默认为10S</li><li>max_fails：设定Nginx与服务器通信尝试失败的次数，默认为1次</li></ul><pre><code class="hljs javacript">upstream backserver&#123;  server 192.168.0.1 max_fails=1 fail_timeout=40s;  server 192.168.0.2  max_fails=1 fail_timeout=40s;&#125;</code></pre><h2 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2 反向代理"></a>2 反向代理</h2><p>nginx代理服务器承担着中间人的角色，起到分配和沟通的作用。</p><ul><li>反向代理的作用：<ul><li>防火墙作用：让用户无法通过请求直接访问真正的服务器，通过nginx过滤掉没有权限或者非法请求，来保障内部服务器的安全。</li><li>负载均衡</li></ul></li><li>如何使用反向代理：通过location功能匹配指定的URI，然后把接收的符合匹配URI的请求通过proxy_pass转移给之前定义好的upstream节点池。</li></ul><pre><code class="hljs javacript">// nginx.configserver&#123;    listen 80;    server_name localhost;    location&#123;        proxy_pass http://127.0.0.1:8000;（upstream）      &#125;&#125;</code></pre><h2 id="3-Https设置"><a href="#3-Https设置" class="headerlink" title="3 Https设置"></a>3 Https设置</h2><p>Nginx常用来配置Https认证，主要有两个步骤：签署第三方可信任的SSL证书 和 配置Https</p><ul><li><p>签署第三方可信任的SSL：<br>配置Https要用到私钥example.key文件和example.crt证书文件，而申请证书文件的时候要用到example.csr文件。</p></li><li><p>Nginx配置Https：<br>要开启Https服务，在配置文件信息块（server）必须使用监听命令listen的ssl参数和定义服务器证书文件和私钥文件：</p></li></ul><pre><code class="hljs javacript">// nginx.configserver&#123;  #ssl参数  listen   443 ssl;  //监听443端口，因为443端口是https的默认端口。80为http的默认端口  server_name  example.com;  #证书文件  ssl_certificate    example.com.crt;  #私钥文件  ssl_certificate_key    example.com.key;&#125;</code></pre><ul><li>ssl_certificate：证书的绝对路径</li><li>ssl_certificate_key：密钥的绝对路径;</li></ul><h2 id="4-其他常用设置"><a href="#4-其他常用设置" class="headerlink" title="4 其他常用设置"></a>4 其他常用设置</h2><h3 id="（1）IP白名单"><a href="#（1）IP白名单" class="headerlink" title="（1）IP白名单"></a>（1）IP白名单</h3><p>通过配置nginx白名单，规定哪些IP可以访问你的服务器，防爬虫必备</p><h3 id="（2）适配PC与移动环境"><a href="#（2）适配PC与移动环境" class="headerlink" title="（2）适配PC与移动环境"></a>（2）适配PC与移动环境</h3><p>获取请求客户端的userAgent，从而知道当前用户终端是PC端还是移动端，并重定向到PC站和H5站</p><h3 id="（3）配置gzip"><a href="#（3）配置gzip" class="headerlink" title="（3）配置gzip"></a>（3）配置gzip</h3><p>开启nginx gzip压缩，静态资源的大小会大大减少，从而节省带宽，提高传输效率。</p><h3 id="（4）配置跨域请求"><a href="#（4）配置跨域请求" class="headerlink" title="（4）配置跨域请求"></a>（4）配置跨域请求</h3><p>当出现403跨域错误或其他跨域错误时，给nginx服务器配置相应的header参数</p><h2 id="5-如何使用nginx"><a href="#5-如何使用nginx" class="headerlink" title="5 如何使用nginx"></a>5 如何使用nginx</h2><p>本地nginx的基本使用：</p><ul><li>启动——<code>sudo nginx</code></li><li>修改<code>nginx.conf</code>配置——<code>vim /usr/local/etc/nginx/nginx.conf</code></li><li>检查语法是否正常——<code>sudo nginx –t</code></li><li>重启<code>nginx</code>——<code>sudo nginx –s reload</code></li><li>创建软连接——便于管理多个<code>nginx</code></li></ul><p>当我们需要管理多个网站的<code>nginx</code>，<code>nginx</code>文件放在一起是最好的管理方式。<br>我们把配置文件丢在<code>/nginx/conf.d/</code>文件夹下，假如我们程序文件夹下有一个<code>nginx</code>配置文件：<code>/home/app.nginx.conf</code>，只需要给这个文件创建一个软连接到<code>/nginx/conf.d/</code>下即可：<br><code>ln -s /home/app/app.example.com.nginx.conf /etc/nginx/conf.d/app.nginx.conf</code><br>这样操作之后，我们修改配置文件后，<code>/nginx/conf.d/</code>下与之对应的配置文件也会被修改，修改后重启<code>nginx</code>即可使用新的配置属性。</p><h2 id="6-停止Nginx服务的四种方法"><a href="#6-停止Nginx服务的四种方法" class="headerlink" title="6 停止Nginx服务的四种方法"></a>6 停止Nginx服务的四种方法</h2><ul><li>从容停止服务<br>这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。</li></ul><pre><code class="hljs cos">nginx -<span class="hljs-keyword">s</span> <span class="hljs-keyword">quit</span></code></pre><ul><li>立即停止服务<br>这种方法比较强硬，无论进程是否在工作，都直接停止进程。</li></ul><pre><code class="hljs arduino">nginx -s stop</code></pre><ul><li>systemctl 停止<br>systemctl属于Linux命令</li></ul><pre><code class="hljs arduino">systemctl stop nginx.service</code></pre><ul><li>killall 方法杀死进程<br>直接杀死进程，在上面无效的情况下使用，态度强硬，简单粗暴！</li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">killall nginx</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/01/HMLZ7bmBI23PkxD.png&quot; alt=&quot;nginx.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-负载均衡&quot;&gt;&lt;a href=&quot;#1-负载均衡&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>React step 1 —— React初级使用</title>
    <link href="http://example.com/2021/02/22/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/02/22/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E8%A7%A3%E6%9E%90/</id>
    <published>2021-02-22T11:38:03.000Z</published>
    <updated>2021-02-22T11:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、XSS"><a href="#一、XSS" class="headerlink" title="一、XSS"></a>一、XSS</h2><p><code>XSS（Cross-site Scripting）</code>，跨站脚本攻击是指通过存在安全漏洞的web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。<br>XSS的原理是恶意攻击者通过向Web页面插入恶意可执行的网页脚本代码，当用户浏览该页时，嵌入其Web里面的脚本代码会被执行，从而达到窃取用户信息或侵犯用户安全隐私的目的。</p><p>XSS的攻击方式大致分为非持久型XSS（反射型XSS）和持久型XSS（存储型XSS）</p><h3 id="1-反射型XSS-非持久型XSS"><a href="#1-反射型XSS-非持久型XSS" class="headerlink" title="(1) 反射型XSS (非持久型XSS)"></a>(1) 反射型XSS (非持久型XSS)</h3><p>反射型XSS 一般是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数会被HTML解析并执行。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 攻击方式一： 通过执行URL上注入的脚本，盗取用户敏感信息：</span><span class="hljs-comment">// 比如：通过UTL  `https://xxx.com/xxx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;` </span><span class="hljs-comment">// 注入可执行的脚本代码, 获取用户的cookie</span><span class="hljs-comment">// 攻击方式二：通过用户请求 注入在URL上的链接，将攻击者提供的脚本将在用户的浏览器中执行：</span><span class="hljs-comment">// 某网站具有搜索功能，该功能通过 URL 参数接收用户提供的搜索词：</span><span class="hljs-comment">// https: //xxx.com/search?query=123</span><span class="hljs-comment">// 服务器在对此 URL 的响应中回显提供的搜索词：</span><span class="hljs-comment">// &lt;p&gt;您搜索的是: 123&lt;/p&gt;</span><span class="hljs-comment">// 如果服务器不对数据进行转义等处理，则攻击者可以构造如下链接进行攻击：</span><span class="hljs-comment">// https://xxx.com/search?query=&lt;img src=&quot;empty.png&quot; onerror =&quot;alert(&#x27;xss&#x27;)&quot;&gt;</span><span class="hljs-comment">// 该 URL 将导致以下响应，并运行 alert(&#x27;xss&#x27;)：</span><span class="hljs-comment">// &lt;p&gt;您搜索的是: &lt;img src=&quot;empty.png&quot; onerror =&quot;alert(&#x27;xss&#x27;)&quot;&gt;&lt;/p&gt;</span><span class="hljs-comment">// 如果有用户请求攻击者的 URL ，则攻击者提供的脚本将在用户的浏览器中执行。</span></code></pre><p>不过大部分的浏览器如Chrome内置了一些XSS过滤器，可以防止大部分的反射型XSS攻击。</p><p>非持久性XSS有以下几个特征：</p><ul><li>XSS 脚本来自当前 HTTP 请求，不经过服务器存储，直接通过一次HTTP的请求完成攻击</li><li>攻击者需要诱骗用户点击链接才能发起攻击</li></ul><h3 id="2-持久型XSS（存储型XSS）"><a href="#2-持久型XSS（存储型XSS）" class="headerlink" title="(2)持久型XSS（存储型XSS）"></a>(2)持久型XSS（存储型XSS）</h3><p>持久型XSS（存储型XSS）一般存在于form表单提交等交互功能，如文章留言、评论、提交文本信息等，攻击者将带有可执行的HTML代码或script代码通过表单内容经正常功能提交进入数据库持久保存，当前端页面通过后端从数据库读出注入的代码时，浏览器恰好将其渲染执行。<br>持久型XSS（存储型XSS）不需要诱骗点击，只需要在提交表单的地方完成注入即可，但是这种XSS攻击的成本相对还是很高。</p><p>攻击成功需要满足以下几点：</p><ul><li>POST请求提交表单后端没有做转义直接入库</li><li>后端从数据库取出数据后没做转义直接输出给前端</li><li>前端拿到后端的数据没做转义直接渲染成 DOM</li></ul><h3 id="3-如何防御-XSS"><a href="#3-如何防御-XSS" class="headerlink" title="(3) 如何防御 XSS"></a>(3) 如何防御 XSS</h3><ul><li><p>服务端防御措施：</p><p>  1）CSP</p><p>  CSP的本质上是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配合规则，如何拦截是由浏览器自己实现的。</p><p>  通常可以通过两种方式开启CSP：</p><p>  1.设置 HTTP的Header中Content-Security-Policy<br>  2.设置meta标签的方式</p><p>  比如设置HTTP Header：</p>  <pre><code class="hljs text">// 只允许加载本站资源Content-Security-Policy: default-src &#x27;self&#x27;// 只允许加载HTTPS协议图片Content-Security-Policy: img-src https://* // 允许加载任何来源框架Content-Security-Policy: child-src &#x27;none&#x27;</code></pre><p>  对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行他的攻击代码，并且CSP的兼容性也很好。</p><p>  2）转义字符</p><p>  用户的输入永远不可信任，最普遍的做法是转义输入输出内容，对引号、尖括号、斜杠进行转义。</p>  <pre><code class="hljs javascript">str.replace(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>)str.replace(<span class="hljs-regexp">/&lt;/g</span>), <span class="hljs-string">&#x27;$lt;&#x27;</span>)<span class="hljs-comment">// 但是对于显示富文本来说，不能通过上面的方法转义所有字符，因为这样会把需要的格式也过滤掉。</span><span class="hljs-comment">// 这是需要通过白名单过滤的方法（黑名单也可以，但是需要过滤的的标签和标签属性太多，推荐使用白名单）</span><span class="hljs-comment">// 实例用js-xss来实现</span><span class="hljs-keyword">const</span> jsXSs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;xss&#x27;</span>)<span class="hljs-keyword">let</span> html = jsXss(<span class="hljs-string">&#x27;&lt;h1 id=&#x27;</span>title<span class="hljs-string">&#x27;&gt;XSS Code&lt;/h1&gt;&lt;script&gt;alert(&#x27;</span>xss<span class="hljs-string">&#x27;)&lt;/script&gt;&#x27;</span>)</code></pre><p>  3）httpOnly cookie<br>  这是预防xss攻击最有效的防御手段，可以避免网页的cookie被JavaScript代码恶意窃取。</p></li><li><p>非持久型XSS防御措施：</p><ul><li>Web 页面渲染的所有内容和和渲染的所有数据必须来自服务端</li><li>尽量不要从URL、document.referrer（上一个页面的URL）、document.forms等这种DOM API中获取数据直接渲染</li><li>尽量不要使用eval、new Function()、document.write()、innerHTML、window.setTimeout、document.createElement()等可执行字符串的方法</li><li>如果做不到以上几点，也必须对涉及DOM渲染的方法传入的字符串参数做escape转义</li><li>前端渲染的时候对任何的字段都需要做escape转义编码</li></ul></li></ul><h2 id="二、CSRF"><a href="#二、CSRF" class="headerlink" title="二、CSRF"></a>二、CSRF</h2><p><code>CSRF（Cross Site Request Forgery）</code> 即跨站伪造请求，是一种常见的web攻击。它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p><p>完成CSRF需要满足三个条件：</p><ul><li>1)用户已经登录了站点A，并在本地记录了cookie</li><li>2)用户在没有登出站点A的情况下（也就是Cookie生效的情况下），从该网站访问了恶意攻击者提供的引诱危险站点B（B站点要求访问站点A）</li><li>3)站点A没有做任何CSRF攻击</li></ul><p>防范CSRF攻击可以遵循以下几种原则：</p><ul><li>Get请求不对数据进行修改</li><li>不让第三方网站访问用户cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者token</li></ul><p>如何防御：</p><ul><li><p>1）SameSite<br>可以对Cookie设置SameSite属性。该属性表示Cookie不能随着跨域请求发送，可以很大程度上减少CSRF攻击，但是该属性不是所有浏览器都兼容。</p></li><li><p>2）Referer Check<br>HTTP Referer 是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，用来获取请求者的信息。<br>服务器可以通过检查请求者的来源来防御CSRF攻击。通过检查HTTP包中的头Referer的值是不是这个页面，来判断是不是CSRF攻击。<br>但是某些情况下，如从https跳转到http，浏览器处于安全考虑，不会发送referer，此时服务器就无法check了，因此不能完全依赖Referer Check作为防御CSRF的主要手段。</p></li><li><p>3）Anti CSRF Token<br>Token可以在用户登陆后产生并存在session或cookie中，然后每次    请求时，服务器验证token的有效性和真实性。由于token的存在，攻击者无法再构造出一个完整的 URL实施CSRF攻击。</p></li><li><p>4）验证码<br>应用程序与用户交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成请求。验证码可以很好的遏制CSRF攻击，但是验证码降低了用户体验，只能在关键业务点设置验证码。</p></li></ul><h2 id="三、SQL注入"><a href="#三、SQL注入" class="headerlink" title="三、SQL注入"></a>三、SQL注入</h2><p>一次SQL注入包括以下几个过程：</p><ul><li>获取用户请求参数</li><li>拼接到代码中</li><li>SQL语句按照我们构造参数的语义执行成功</li></ul><p>SQL注入必备的条件：1、可以控制输入的数据；2、服务器要执行的代码拼接了控制的数据。<br>SQL注入的本质是：数据和代码未分离，即数据当作代码来执行。</p><p>如何防御：</p><ul><li>1）严格限制Web应用的数据库的操作权限；</li><li>2）后台代码检查输入的数据是否符合预期；</li><li>3）对进入数据库的特殊字符（如*&lt;&gt;&amp;|等）进行转义处理，或编码转换；</li><li>4）所有的检查语句建议使用数据库提供的参数化查询接口，即不要直接拼接SQL语句</li></ul><h2 id="四、OS命令注入攻击"><a href="#四、OS命令注入攻击" class="headerlink" title="四、OS命令注入攻击"></a>四、OS命令注入攻击</h2><p>OS命令注入与 SQL注入差不多，只不过OS命令注入是针对操作系统的。<br>OS命令注入攻击是指通过web应用，执行非法的操作系统命令达到攻击的目的，只要能调用shell函数的地方就存在被攻击的风险。<br>比如：黑客构造命令提交到web应用程序，web应用程序提取命令并且拼接到被执行的命令中，因黑客构造的命令打破了原有命令结构，导致web应用执行了黑客构造的命令。</p><p>如何防御：</p><ul><li>1）后端对前端提交内容进行规则检查（比如正则表达式）</li><li>2）在调用系统命令前对所有传入参数进行转义过滤</li><li>3）不要直接拼接命令语句，借助一些工具做拼接、转义处理，例如NodeJS的 shell-escape npm包</li></ul><h2 id="五、点击劫持"><a href="#五、点击劫持" class="headerlink" title="五、点击劫持"></a>五、点击劫持</h2><p>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱惑用户点击。  </p><p>特点：</p><ul><li>隐蔽性高，骗取用户操作</li><li>UI-覆盖攻击</li><li>利用iframe或其他标签的属性</li></ul><p>如何防御：</p><ul><li><p>1）X-Frame-Options<br>X-Frame-Options是一个Http相应头，这个相应头就是为了防御iframe嵌套的点击劫持攻击，在现在浏览器中有一个很好的支持。<br>X-Frame-Options有3个值可选：</p><ul><li>Deny：表示页面不允许通过iframe的方式展示</li><li>SameOrion：表示页面允许通过相同的域名下通过iframe的方式展示</li><li>AllowFrom：表示页面可以在指定来源的iframe中展示</li></ul></li><li><p>2）JavaScript防御<br>对于不支持X-Frame-Options的远古浏览器来说，只能通过JS的方式来防御点击劫持了。</p></li></ul><h2 id="六、URL跳转漏洞"><a href="#六、URL跳转漏洞" class="headerlink" title="六、URL跳转漏洞"></a>六、URL跳转漏洞</h2><p>借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致安全问题。<br>其原理是黑客构造恶意链接（链接需要进行伪装，尽可能迷惑），发布到QQ群或者贴吧、论坛中，当用户点击后经过服务器或者浏览器解析后，跳转到恶意的网站中。<br>恶意链接一般是在熟悉的链接后面加上一个恶意的网站，这样才能迷惑用户。<br>一般通过Header头跳转、JavaScript跳转、META标签跳转等方式实现。</p><p>例如：<br><code>http://www.baidu.com?act=go&amp;url=http://t.cn/RVTatrd</code><br><code>http://www.qq.com?flag=1&amp; jumpTo=http://t.cn/RVTatrd</code><br><code>http://www.taobao.com?jumpUrl= http://t.cn/RVTatrd</code></p><p>如何防御：</p><ul><li><p>1）Referer限制<br>保证跳转来源地址的可靠性和有效性，避免恶意用户自己生成跳转链接</p></li><li><p>2）加入有效的token<br>通过在URL中加入用户不可控的token对生成的链接进行校验，从而避免恶意用户生成自己的链接而被利用。缺点：如果功能本身要求比较开放，可能导致有一定的限制。</p></li></ul><h2 id="七、React-如何防止-XSS-攻击"><a href="#七、React-如何防止-XSS-攻击" class="headerlink" title="七、React 如何防止 XSS 攻击"></a>七、React 如何防止 XSS 攻击</h2><p>无论使用哪种攻击方式，其本质就是将恶意代码注入到应用中，浏览器去默认执行。<br>React 官方中提到了 React DOM 在渲染所有输入内容之前，默认会进行转义。<br>它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串，因此恶意代码无法成功注入，从而有效地防止了 XSS 攻击。</p><h3 id="1、React-的防止措施"><a href="#1、React-的防止措施" class="headerlink" title="1、React 的防止措施"></a>1、React 的防止措施</h3><h4 id="1-自动转义"><a href="#1-自动转义" class="headerlink" title="(1) 自动转义"></a>(1) 自动转义</h4><p>React 在渲染 HTML 内容和渲染 DOM 属性时都会将 “‘&amp;&lt;&gt; 这几个字符进行转义，转义部分源码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (index = match.index; index &lt; str.length; index++) &#123;  <span class="hljs-keyword">switch</span> (str.charCodeAt(index)) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">34</span>: <span class="hljs-comment">// &quot;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;quot;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-comment">// &amp;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;amp;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>: <span class="hljs-comment">// &#x27;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;#x27;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">60</span>: <span class="hljs-comment">// &lt;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;lt;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">62</span>: <span class="hljs-comment">// &gt;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">continue</span>;    &#125;  &#125;</code></pre><p>这段代码是 React 在渲染到浏览器前进行的转义，可以看到对浏览器有特殊含义的字符都被转义了，恶意代码在渲染到 HTML 前都被转成了字符串，如下：</p><pre><code class="hljs html">一段恶意代码:<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;empty.png&quot;</span> <span class="hljs-attr">onerror</span> =<span class="hljs-string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span> 转义后输出到 html 中:<span class="hljs-symbol">&amp;lt;</span>img src=<span class="hljs-symbol">&amp;quot;</span>empty.png<span class="hljs-symbol">&amp;quot;</span> onerror =<span class="hljs-symbol">&amp;quot;</span>alert(<span class="hljs-symbol">&amp;#x27;</span>xss<span class="hljs-symbol">&amp;#x27;</span>)<span class="hljs-symbol">&amp;quot;</span><span class="hljs-symbol">&amp;gt;</span></code></pre><p>这样就有效的防止了 XSS 攻击。</p><h4 id="2-JSX-语法"><a href="#2-JSX-语法" class="headerlink" title="(2) JSX 语法"></a>(2) JSX 语法</h4><p><code>JSX</code> 实际上是一种语法糖，<code>Babel</code> 会把 <code>JSX</code> 编译成 <code>React.createElement()</code> 的函数调用，最终返回一个 <code>ReactElement</code>，以下为这几个步骤对应的代码：</p><pre><code class="hljs javaScript"><span class="hljs-comment">// JSX</span><span class="hljs-keyword">const</span> element = (  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;greeting&quot;</span>&gt;</span></span><span class="xml">    Hello, world!</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>);<span class="hljs-comment">// 通过 babel 编译后的代码</span><span class="hljs-keyword">const</span> element = React.createElement(  <span class="hljs-string">&#x27;h1&#x27;</span>,  &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;greeting&#x27;</span>&#125;,  <span class="hljs-string">&#x27;Hello, world!&#x27;</span>);<span class="hljs-comment">// React.createElement() 方法返回的 ReactElement</span><span class="hljs-keyword">const</span> element = &#123;  <span class="hljs-attr">$$typeof</span>: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;react.element&#x27;</span>),  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;h1&#x27;</span>,  <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span>,  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;Hello, world!&#x27;</span>,      <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;greeting&#x27;</span>     &#125;  ...&#125;</code></pre><p>我们可以看到，最终渲染的内容是在 Children 属性中，那了解了 JSX 的原理后，我们来试试能否通过构造特殊的 Children 进行 XSS 注入，来看下面一段代码：</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> storedData = <span class="hljs-string">`&#123;</span><span class="hljs-string">  &quot;ref&quot;:null,</span><span class="hljs-string">  &quot;type&quot;:&quot;body&quot;,</span><span class="hljs-string">  &quot;props&quot;:&#123;</span><span class="hljs-string">  &quot;dangerouslySetInnerHTML&quot;:&#123;</span><span class="hljs-string">  &quot;__html&quot;:&quot;&lt;img src=\&quot;empty.png\&quot; onerror =\&quot;alert(&#x27;xss&#x27;)\&quot;/&gt;&quot;</span><span class="hljs-string">      &#125;</span><span class="hljs-string">  &#125;</span><span class="hljs-string">&#125;`</span>;<span class="hljs-comment">// 转成 JSON</span><span class="hljs-keyword">const</span> parsedData = <span class="hljs-built_in">JSON</span>.parse(storedData);<span class="hljs-comment">// 将数据渲染到页面</span>render () &#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> &#123;parsedData&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>; &#125;</code></pre><p>这段代码中， 运行后会报以下错误，提示不是有效的 ReactChild</p><pre><code class="hljs javaScript">Uncaught (<span class="hljs-keyword">in</span> promise) <span class="hljs-built_in">Error</span>: Objects are not valid <span class="hljs-keyword">as</span> a React child (found: object <span class="hljs-keyword">with</span> keys &#123;ref, type, props&#125;). If you meant to render a collection <span class="hljs-keyword">of</span> children, use an array instead.</code></pre><p>那究竟是哪里出问题了？我们看一下 ReactElement 的源码：</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> symbolFor = <span class="hljs-built_in">Symbol</span>.for;REACT_ELEMENT_TYPE = symbolFor(<span class="hljs-string">&#x27;react.element&#x27;</span>);<span class="hljs-keyword">const</span> ReactElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, key, ref, self, source, owner, props</span>) </span>&#123;  <span class="hljs-keyword">const</span> element = &#123;    <span class="hljs-comment">// 这个 tag 唯一标识了此为 ReactElement</span>    <span class="hljs-attr">$$typeof</span>: REACT_ELEMENT_TYPE,    <span class="hljs-comment">// 元素的内置属性</span>    <span class="hljs-attr">type</span>: type,    <span class="hljs-attr">key</span>: key,    <span class="hljs-attr">ref</span>: ref,    <span class="hljs-attr">props</span>: props,    <span class="hljs-comment">// 记录创建此元素的组件</span>    <span class="hljs-attr">_owner</span>: owner,  &#125;;  ...  <span class="hljs-keyword">return</span> element;&#125;</code></pre><p>注意到其中有个属性是 <code>$$typeof</code>，它是用来标记此对象是一个 <code>ReactElement</code>，<code>React</code> 在进行渲染前会通过此属性进行校验，校验不通过将会抛出上面的错误。<br><code>React</code> 利用这个属性来防止通过构造特殊的 <code>Children</code> 来进行的 <code>XSS</code> 攻击，原因是 <code>$$typeof</code> 是个 <code>Symbol</code> 类型，进行 <code>JSON</code> 转换后会 <code>Symbol</code> 值会丢失，无法在前后端进行传输。<br>如果用户提交了特殊的 <code>Children</code>，也无法进行渲染，利用此特性，可以防止存储型的 <code>XSS</code> 攻击。</p><h3 id="2、React-中可能引起漏洞的一些写法"><a href="#2、React-中可能引起漏洞的一些写法" class="headerlink" title="2、React 中可能引起漏洞的一些写法"></a>2、React 中可能引起漏洞的一些写法</h3><h4 id="1-使用-dangerouslySetInnerHTML"><a href="#1-使用-dangerouslySetInnerHTML" class="headerlink" title="(1) 使用 dangerouslySetInnerHTML"></a>(1) 使用 dangerouslySetInnerHTML</h4><p>dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供 innerHTML 的替换方案。通常来讲，使用代码直接设置 HTML 存在风险，因为很容易使用户暴露在 XSS 攻击下，因为当使用 dangerouslySetInnerHTML 时，React 将不会对输入进行任何处理并直接渲染到 HTML 中，如果攻击者在 dangerouslySetInnerHTML 传入了恶意代码，那么浏览器将会运行恶意代码。看下源码：</p><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonChildrenInnerMarkup</span>(<span class="hljs-params">props</span>) </span>&#123;<span class="hljs-comment">// 有dangerouslySetInnerHTML属性，会不经转义就渲染__html的内容</span>  <span class="hljs-keyword">const</span> innerHTML = props.dangerouslySetInnerHTML;   <span class="hljs-keyword">if</span> (innerHTML != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">if</span> (innerHTML.__html != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> innerHTML.__html;    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">const</span> content = props.children;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> content === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> content === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;      <span class="hljs-keyword">return</span> escapeTextForBrowser(content);    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre><p>所以平时开发时最好避免使用 dangerouslySetInnerHTML，如果不得不使用的话，前端或服务端必须对输入进行相关验证，例如对特殊输入进行过滤、转义等处理。<br>前端这边处理的话，推荐使用白名单过滤 <code>(https://jsxss.com/zh/index.html)</code>，通过白名单控制允许的 HTML 标签及各标签的属性。</p><h4 id="2-通过用户提供的对象来创建-React-组件"><a href="#2-通过用户提供的对象来创建-React-组件" class="headerlink" title="(2) 通过用户提供的对象来创建 React 组件"></a>(2) 通过用户提供的对象来创建 React 组件</h4><p>举个例子：</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 用户的输入</span><span class="hljs-keyword">const</span> userProvidePropsString = <span class="hljs-string">`&#123;&quot;dangerouslySetInnerHTML&quot;:&#123;&quot;__html&quot;:&quot;&lt;img onerror=&#x27;alert(\&quot;xss\&quot;);&#x27; src=&#x27;empty.png&#x27; /&gt;&quot;&#125;&#125;&quot;`</span>;<span class="hljs-comment">// 经过 JSON 转换</span><span class="hljs-keyword">const</span> userProvideProps = <span class="hljs-built_in">JSON</span>.parse(userProvidePropsString);<span class="hljs-comment">// userProvideProps = &#123;</span><span class="hljs-comment">//   dangerouslySetInnerHTML: &#123;</span><span class="hljs-comment">//     &quot;__html&quot;: `&lt;img onerror=&#x27;alert(&quot;xss&quot;);&#x27; src=&#x27;empty.png&#x27; /&gt;`</span><span class="hljs-comment">//      &#125;</span><span class="hljs-comment">// &#125;;</span><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;     <span class="hljs-comment">// 出于某种原因解析用户提供的 JSON 并将对象作为 props 传递</span>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &#123;<span class="hljs-attr">...userProvideProps</span>&#125; /&gt;</span></span> &#125;</code></pre><p>这段代码将用户提供的数据进行 JSON 转换后直接当做 div 的属性，当用户构造了类似例子中的特殊字符串时，页面就会被注入恶意代码，所以要注意平时在开发中不要直接使用用户的输入作为属性。</p><h4 id="3-使用用户输入的值来渲染-a-标签的-href-属性，或类似-img-标签的-src-属性等"><a href="#3-使用用户输入的值来渲染-a-标签的-href-属性，或类似-img-标签的-src-属性等" class="headerlink" title="(3) 使用用户输入的值来渲染 a 标签的 href 属性，或类似 img 标签的 src 属性等"></a>(3) 使用用户输入的值来渲染 a 标签的 href 属性，或类似 img 标签的 src 属性等</h4><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> userWebsite = <span class="hljs-string">&quot;javascript:alert(&#x27;xss&#x27;);&quot;</span>;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#123;userWebsite&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span></code></pre><p>如果没有对该 URL 进行过滤以防止通过 javascript: 或 data: 来执行 JavaScript，则攻击者可以构造 XSS 攻击，此处会有潜在的安全问题。用户提供的 URL 需要在前端或者服务端在入库之前进行验证并过滤。</p><blockquote><p><a href="https://github.com/ljianshu/Blog/issues/56">常见六大Web安全攻防解析</a><br><a href="https://mp.weixin.qq.com/s/yf0jhXiCXw8oTbjoUI3tYw">浅谈 React 中的 XSS 攻击</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、XSS&quot;&gt;&lt;a href=&quot;#一、XSS&quot; class=&quot;headerlink&quot; title=&quot;一、XSS&quot;&gt;&lt;/a&gt;一、XSS&lt;/h2&gt;&lt;p&gt;&lt;code&gt;XSS（Cross-site Scripting）&lt;/code&gt;，跨站脚本攻击是指通过存在安全漏洞的we</summary>
      
    
    
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="web安全" scheme="http://example.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器与JS运行机制</title>
    <link href="http://example.com/2021/02/22/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8EJS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/02/22/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8EJS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-02-22T11:38:00.000Z</published>
    <updated>2021-02-22T11:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript预解析"><a href="#一、JavaScript预解析" class="headerlink" title="一、JavaScript预解析"></a>一、JavaScript预解析</h2><p>JavaScript代码运行分为两个阶段：</p><ul><li>(1) 预解析</li></ul><p>所有函数定义提前，函数体提升(当然不包括如var box = function() {} )<br>形参声明并赋值<br>变量声明(不赋值)</p><ul><li>(2) 执行</li></ul><p>按照js运行机制从，从上到下执行</p><h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><ul><li><strong>进程是cpu资源分配的最小单位</strong>（是能够拥有资源和独立运行的最小单位）</li><li><strong>线程是cpu调度的最小单位</strong>（线程是建立在进程的基础上的一次程序运行单位，一个进程可以有多个线程</li></ul><p>举例：此处有多个工厂，每个工厂有1个或多个工人。此时<strong>工厂就好比进程</strong>，有单独专属自己的工厂资源；<strong>工人就好比是线程</strong>，多个工人在工厂中写作工作。工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可以共享内存。并且每个工厂之间相互独立存在。<br><img src="https://i.loli.net/2020/12/02/fvhtrWzeMkpCR15.png" alt="进程和线程.png"></p><ul><li>应用程序必须运行在某个进程的某个线程上</li><li>一个进程至少有一个运行的线程：主线程，进程启动后自动创建</li></ul><h2 id="三、浏览器进程"><a href="#三、浏览器进程" class="headerlink" title="三、浏览器进程"></a>三、浏览器进程</h2><p>浏览器内核是指支持浏览器运行的最核心的部分，分为渲染引擎和JS引擎。现在JS引擎比较独立，内核更加倾向于说渲染引擎</p><p><strong>(1)浏览器内核分类</strong></p><ul><li>Chrome、Safari： Webkit (Bink)</li><li>Firefox：Gecko</li><li>IE：Trident</li><li>360、搜狗等国内浏览器：Trident+Webkit</li><li>…</li></ul><p><strong>(2)浏览器进程</strong></p><ul><li>浏览器是多进程的</li><li>浏览器之所以能运行，是因为系统给它的进程分配了资源（cpu、内存）</li><li>简单来说，每打一个Tab页，就相当于创建了一个独立的浏览器进程</li></ul><p>浏览器进程的组成：</p><ul><li><strong>Browser进程</strong><br>浏览器的主进程，负责协调、主控，只有一个。<br>负责内容：浏览器页面显示；与用户交互（前进、后退等）；网络资源的管理、下载；各个页面的管理，创建和销毁其他进程等</li><li><strong>第三方插件进程</strong><br> 每种类型的插件对应一个进程，仅当插件使用时才创建</li><li><strong>GPU进程</strong><br>最多一个，用于3D绘制等</li><li><strong>浏览器渲染进程</strong>（浏览器内核，Renderer进程，内部是多线程的）<br>默认 每个Tab页面一个进程，互不影响<br>负责内容：页面渲染；脚本执行；事件处理</li></ul><p>浏览器是多线程的优势：避免单个Tab页崩溃或单个插件崩溃影响其他整个浏览器，可以充分多核优势，方便使用沙盒模型隔离插件等进程，提高浏览器的稳定性。缺点是，内存和cpu消耗会更大，有点空间换时间的意思。</p><p>Borwser进程与浏览器内核（Renderer进程）的通信过程：</p><ul><li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程<ul><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和GPU进程来帮助渲染</li><li>当然可能会有JS线程操作DOM（可能会造成回流并重绘）</li><li>最后Renderer进程将结果传递给Browser进程</li></ul></li><li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</li><li>Browser进程收到结果并将结果绘制出来</li></ul><h2 id="四、浏览器渲染进程"><a href="#四、浏览器渲染进程" class="headerlink" title="四、浏览器渲染进程"></a>四、浏览器渲染进程</h2><p>对于前端操作来说 ，最重要的是渲染进程，并且<strong>渲染进程也是多线程的</strong>。<br>渲染进程包含哪些线程？</p><ul><li><strong>GUI渲染线程</strong><ul><li>负责渲染浏览器页面，解析HTML、CSS，构建DOM树和RenderObject树，布局和绘制等</li><li>负责重绘（Repaint）和回流（Reflow）</li><li>GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI线程会保存在一个队列里等 js引擎空闲时执行。</li></ul></li><li><strong>JS引擎线程</strong><ul><li>负责处理JavaScript脚本，执行代码</li></ul></li><li><strong>事件触发线程</strong><ul><li>主要负责将准备好的事件交给JS引擎线程执行<br>比如setTimeout定时器计数结束、ajax等异步请求成功并触发回调函数、用户触发点击事件等，该线程会将整装待发的事件加入到任务队列的队尾，等待JS引擎线程的执行。</li></ul></li><li><strong>定时器触发线程</strong><ul><li>主要负责异步定时器一类的函数处理，如setTimeout、setInterval<br>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理。当计数完毕后，事件触发线程会将计数完毕的事件加入到任务队列的尾部，等待JS引擎线程执行。</li></ul></li><li><strong>异步HTTP请求线程</strong><ul><li>负责执行异步请求一类的函数，如：ajax、axios、promise等<br>主线程依次执行代码是，遇到异步请求，会将异步请求函数交给该线程处理。当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS引擎线程执行。</li></ul></li></ul><h2 id="五、事件循环"><a href="#五、事件循环" class="headerlink" title="五、事件循环"></a>五、事件循环</h2><h3 id="1-浏览器中的事件循环"><a href="#1-浏览器中的事件循环" class="headerlink" title="1 浏览器中的事件循环"></a><strong>1 浏览器中的事件循环</strong></h3><p>JavaScript语言是单线程的，意思是同一时间只能做一件事。后来为了有效利用多核CPU的计算能力，HTML5提出Web Server标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，并且子线程不能操作DOM。所以新标准并没有改变JavaScript单线程的本质。</p><p>简单描述JS的执行机制：</p><ol><li>首先判断JS是同步任务还是异步任务，同步任务就进入主线程执行，异步任务进入event table</li><li>异步任务在event table中注册函数，异步函数又分为宏任务(macro-task)和微任务(micro-task)，当满足触发条件后，宏任务被推入宏任务队列(macro-task queue)，微任务被推入微任务队列(micro-task queue)</li><li>同步任务在主线程中一直执行，直到同步任务执行完毕，主线程空闲空闲时，才去微任务队列(micro-task queue)中查看是否有可执行的异步任务，如果有就推入主线程中执行</li><li>直到全部微任务依次执行完毕后，主线程空闲，再去宏任务队列(macro-task queue) 查看是否有可执行的异步任务，如果有就推入主线程中执行<br>以上四步循环执行，就是event loop。  </li></ol><p>一个完整的Event Loop过程：</p><p>① 所有的同步任务都在主线程上执行，形成一个执行栈(exection context stack)，我们可以认为执行栈是一个函数调用的栈结构，遵循先进后出的原则。除了主线程的执行栈，还存在一个任务队列(task queue)，任务队列分为宏任务队列(macro-task queue)和微任务队列(micro-task queue)。<br>一开始执行栈为空，宏任务队列(macro-task queue)里只有一个script代码(整体代码)，微任务队列(micro-task queue)队列为空。<br>② 宏任务队列(macro-task queue)中的全局上下文(script标签)会被推入执行栈，同步代码执行。在执行的过程中会判断是同步任务还是异步任务，同步任务依次执行，异步任务会通过对一些接口的调用而产生新的macro-task和micro-task(只要异步任务有了运行结果，就会在对应的任务队列中放置一个事件，等待调用)。同步代码执行完了，script脚本会行和出队的过程。<br>③ 上一步出队的是一个macro-task，这一步要处理的是micro-task。需要注意的是，当macro-task出队时，任务是一个一个执行的，而micro-task出队时，任务是一队一队执行的。因此，我们处理micro-task这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。<br>④ 执行渲染操作，更新页面<br>⑤ 检查是否存在Web worker任务，如果有，则对其进行进行处理<br>⑥ 上述过程重复循环，直到两个队列都清空<br><img src="https://i.loli.net/2020/12/02/ZTb26DuxecrvmJt.jpg" alt="event-loop.jpg"></p><p>宏任务队列可以有多个，而微任务队列只有一个：  </p><ul><li>常见的macro-task：setTimeout、setInterval、script(整套代码)、I/O操作、UI渲染等；  </li><li>常见的micro-task：new Promise().then(回调)、process.nextTick、MutationObserver(HTML5新特性)等</li></ul><h3 id="2-Node中的事件循环"><a href="#2-Node中的事件循环" class="headerlink" title="2 Node中的事件循环"></a><strong>2 Node中的事件循环</strong></h3><p>Node中的事件循环与浏览器的是完全不同不同的东西。Node采用V8作为js的解析引擎，而I/O处理方面使用自己设计的libuv。<br>libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统的一些底层特性，对外提供API，事件循环也是在它里面实现：<br><img src="https://i.loli.net/2020/12/02/2dRg1pCtJw5894s.png" alt="node-eventLoop.png"></p><p>NodeJS运行机制如下：</p><ul><li><p>V8引擎解析JavaScript脚本</p></li><li><p>解析后的代码调用Node API</p></li><li><p>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎</p></li><li><p>V8引擎再将结果返回给用户</p><p>libuv引擎的事件循环分为6个阶段：</p></li></ul><ol><li><p>timers阶段：执行timers（setTimeout和setInterval）的回调</p></li><li><p>I/O callbacks阶段：处理上一轮循环少数未执行的的I/O回调</p></li><li><p>idel、prepare阶段：仅Node内部使用</p></li><li><p>poll阶段：获取新的I/O事件，执行I/O回调</p></li><li><p>check阶段：执行setImmediate()回调</p></li><li><p>close callbacks阶段：执行socket的close事件回调<br>绝大部分的异步任务都在timers、poll、check这个3个阶段处理</p><p>NodeJS执行环境下的特殊情况：<br>1）<strong>setTimeout和setImmediate</strong><br>二者非常相似，区别主要在于调用时机不同：</p></li></ol><ul><li>setImmediate设计在poll阶段完成时执行，即check阶段</li><li>setTimeout设计在poll阶段为空闲时，且设定阶段到达后执行，但它在timers阶段执行</li></ul><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>);&#125;,<span class="hljs-number">0</span>);setImmediate(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">immediate</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>);&#125;);</code></pre><p>对于以上代码，setTimeout可能执行在前，也可能执行在后；<br>取决于setImmediate的准备时间；因为当setTimeout指定时间小于4ms，则增加到4ms（4ms是H5de新标准，2010年以前的浏览器是10ms）</p><p>但是如果二者在I/O callback内部回调时，总是先执行setImmediate，后执行setTimeout:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>);    &#125;, <span class="hljs-number">0</span>)    setImmediate(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>)    &#125;)&#125;)<span class="hljs-comment">// immediate</span><span class="hljs-comment">// timeout</span><span class="hljs-comment">// 因为这两个代码都写在I/O回调中，I/O回调是在poll阶段执行，当回调执行完毕后队列清空，发现SetImmediate回调，所以立即跳转到check阶段执行回调。</span>&#125;);</code></pre><p>2）<strong>process.nextTick</strong></p><p>process.nextTick是独立于Event Loop之外的，它有一个自己的队列，会优先于其他micro-task队列执行：</p><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timer1&#x27;</span>)    <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)&#125;)&#125;, <span class="hljs-number">0</span>)process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick&#x27;</span>)process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick&#x27;</span>)process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick&#x27;</span>)process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick&#x27;</span>)&#125;)   &#125;) &#125;)&#125;)<span class="hljs-comment">// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</span></code></pre><h3 id="3-浏览器与Node的Event-Loop差异"><a href="#3-浏览器与Node的Event-Loop差异" class="headerlink" title="3 浏览器与Node的Event Loop差异"></a><strong>3 浏览器与Node的Event Loop差异</strong></h3><p><strong>浏览器环境下，micro-task的任务队列是每个macro-task执行之后执行；</strong><br><strong>Node环境下，在node10及其以前版本，micro-task会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会执行micro-task队列的任务</strong><br><strong>Node在node11版本开始，Event Loop的运行原来发生了变化，一旦一个阶段里的宏任务执行完，就会立即执行微任务队列，这一点与浏览器一直。</strong></p><p><img src="https://i.loli.net/2020/12/02/KAmfl3ceQICY64i.png" alt="diff-eventLoop.png"></p><h3 id="4-Web-worker"><a href="#4-Web-worker" class="headerlink" title="4 Web worker"></a><strong>4 Web worker</strong></h3><p>由于JS是单线程，当遇到计算密集型或高延迟的任务，用户界面可能会短暂“冻结”，不能做其他操作。<br>于是HTML5提出Web Worker，它允许JavaScript创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者。主线程运行的同时，Worker线程在后台运行，两者互不干扰，等到Worker完成计算任务，在把结果返回给主线程。<br>Web Worker的优点是可以承担一些密集型或高延迟任务，使主线程流畅，不被阻塞或拖慢。<br>缺点：</p><ul><li>不能跨域加载JS</li><li>Worker内部代码不能访问DOM</li><li>不是所有浏览器都支持这个新特性</li></ul><p>Web Worker使用方法：</p><ul><li><p>主线程调用Worker线程：</p><ol><li>主线程通过new Worker()调用Worker构造函数，新建一个Worker线程</li><li>主线程调用worker.postMessage()方法，向Worker发消息</li><li>主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息</li></ol></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程：</span><span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;number&#x27;</span>)<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> number = input.value<span class="hljs-comment">//1、创建一个Worker对象</span><span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>)<span class="hljs-comment">// 3、绑定接收消息的监听</span>worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;主线程接收分线程返回的数据: &#x27;</span>+event.data)alert(event.data)&#125;<span class="hljs-comment">// 2、向分线程发送消息</span>worker.postMessage(number)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;主线程向分线程发送数据: &#x27;</span>+number)&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// window</span></code></pre><p>Worker线程响应：</p><ol><li>Worker内部通过onmseeage()监听事件</li><li>通过postMessage(data)方法向主线程发送数据</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">//worker.js文件</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">return</span> n&lt;=<span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : fibonacci(n-<span class="hljs-number">1</span>) + fibonacci(n-<span class="hljs-number">2</span>)  <span class="hljs-comment">//递归调用</span>&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<span class="hljs-comment">//[object DedicatedWorkerGlobalScope]</span><span class="hljs-built_in">this</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<span class="hljs-keyword">var</span> number = event.data<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;分线程接收到主线程发送的数据: &#x27;</span>+number)<span class="hljs-comment">//计算</span><span class="hljs-keyword">var</span> result = fibonacci(number)postMessage(result)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;分线程向主线程返回数据: &#x27;</span>+result)<span class="hljs-comment">// alert(result)  alert是window的方法, 在分线程不能调用</span><span class="hljs-comment">// 分线程中的全局对象不再是window, 所以在分线程中不可能更新界面</span>&#125;</code></pre><blockquote><p>参考资料：<br><a href="https://github.com/ljianshu/Blog/issues/54">https://github.com/ljianshu/Blog/issues/54</a><br><a href="https://juejin.im/post/5bb05494e51d450e7428da59">https://juejin.im/post/5bb05494e51d450e7428da59</a><br><a href="https://juejin.im/post/5bee1e1ff265da61590b3fff">深入浅出JavaScript运行机制</a><br><a href="https://segmentfault.com/a/1190000012806637">10分钟理解JS引擎的执行机制</a><br><a href="https://www.jianshu.com/p/5e90253b5907">浏览器组成</a><br><a href="https://mp.weixin.qq.com/s/bWGjZlBhlIfdSwRDK8XDHQ">全面梳理JS引擎的运行机制</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、JavaScript预解析&quot;&gt;&lt;a href=&quot;#一、JavaScript预解析&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript预解析&quot;&gt;&lt;/a&gt;一、JavaScript预解析&lt;/h2&gt;&lt;p&gt;JavaScript代码运行分为两个</summary>
      
    
    
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>js - Foo.getName()</title>
    <link href="http://example.com/2021/02/22/%E9%A2%98%E7%9B%AE/Foo.getName/"/>
    <id>http://example.com/2021/02/22/%E9%A2%98%E7%9B%AE/Foo.getName/</id>
    <published>2021-02-22T11:37:22.000Z</published>
    <updated>2021-02-22T11:37:22.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;foo.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;foo.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);&#125;<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);&#125;foo.getName();getName();foo().getName();getName();<span class="hljs-keyword">new</span> foo().getName();<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> foo().getName();</code></pre><p>关于 <code>new new foo().getName()</code>:<br>1、执行优先级： <code>new foo() &gt;  foo() &gt; new foo </code><br>2、拆解步骤：<br>    （1）<code>var a = new foo();</code><br>        =&gt; <code>new a.getName()</code><br>    （2）<code>new a.getName();</code></p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-built_in">Promise</span>.resolve()    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>))    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>))<span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)        resolve()    &#125;)&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>))<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([promise2, promise1]))    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">obj</span>: <span class="hljs-number">5</span> &#125;&#125;<span class="hljs-keyword">let</span> promise3 = <span class="hljs-built_in">Promise</span>.resolve()    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>))    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">9</span>))<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> main())</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span</summary>
      
    
    
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
    <category term="手写" scheme="http://example.com/tags/%E6%89%8B%E5%86%99/"/>
    
  </entry>
  
</feed>
